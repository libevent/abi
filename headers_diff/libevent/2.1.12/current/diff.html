<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
    <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="keywords" content="Libevent, header, diff" />
    <meta name="description" content="Diff for header files between 2.1.12 and current versions of libevent" />
    <link rel="stylesheet" type="text/css" href="../../../../css/common.css" />
    <link rel="stylesheet" type="text/css" href="../../../../css/headers_diff.css" />
    
    
    <title>
        Libevent: headers diff between 2.1.12 and current versions
    </title>
    
    </head>

<body>
<table width='100%' cellpadding='0' cellspacing='0'><tr><td><table cellpadding='0' cellspacing='0'><tr><td align='center'><h1 class='tool'><a title='ABI tracker for Libevent' href='../../../../timeline/libevent/index.html' class='tool'>ABI<br/>Tracker</a></h1></td><td width='30px;'></td><td><h1>(Libevent)</h1></td></tr></table><hr/>
<br/>
<br/>
<h1>Headers diff: <span class='version'>2.1.12</span> vs <span class='version'>current</span></h1><br/><br/> 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr id="part-1" bgcolor="orange"><th>&nbsp;event.h (2.1.12)&nbsp;</th><th> </th><th>&nbsp;event.h (current)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-1" class="change" ><th><small>skipping to change at</small><a href="#part-1"><em> line 57<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-1"><em> line 57<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left">#ifdef EVENT__HAVE_SYS_TIME_H</td><td> </td><td class="right">#ifdef EVENT__HAVE_SYS_TIME_H</td></tr>
      <tr><td class="left">#include &lt;sys/time.h&gt;</td><td> </td><td class="right">#include &lt;sys/time.h&gt;</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left">#ifdef EVENT__HAVE_STDINT_H</td><td> </td><td class="right">#ifdef EVENT__HAVE_STDINT_H</td></tr>
      <tr><td class="left">#include &lt;stdint.h&gt;</td><td> </td><td class="right">#include &lt;stdint.h&gt;</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left">#include &lt;stdarg.h&gt;</td><td> </td><td class="right">#include &lt;stdarg.h&gt;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* For int types. */</td><td> </td><td class="right">/* For int types. */</td></tr>
      <tr id="diff0001"></tr>
      <tr><td class="lblock">#include &lt;evutil.h&gt;</td><td> </td><td class="rblock">#include &lt;ev<span class="insert">ent2/</span>util.h&gt;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef _WIN32</td><td> </td><td class="right">#ifdef _WIN32</td></tr>
      <tr><td class="left">#ifndef WIN32_LEAN_AND_MEAN</td><td> </td><td class="right">#ifndef WIN32_LEAN_AND_MEAN</td></tr>
      <tr><td class="left">#define WIN32_LEAN_AND_MEAN</td><td> </td><td class="right">#define WIN32_LEAN_AND_MEAN</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left">#include &lt;winsock2.h&gt;</td><td> </td><td class="right">#include &lt;winsock2.h&gt;</td></tr>
      <tr><td class="left">#include &lt;windows.h&gt;</td><td> </td><td class="right">#include &lt;windows.h&gt;</td></tr>
      <tr><td class="left">#undef WIN32_LEAN_AND_MEAN</td><td> </td><td class="right">#undef WIN32_LEAN_AND_MEAN</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr id="end" bgcolor="gray"><th colspan="5" align="center">&nbsp;End of changes. 1 change blocks.&nbsp;</th></tr>
     <tr class="stats"><th><i>1 lines changed or deleted</i></th><th><i> </i></th><th><i>1 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr id="part-1" bgcolor="orange"><th>&nbsp;buffer.h (2.1.12)&nbsp;</th><th> </th><th>&nbsp;buffer.h (current)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-1" class="change" ><th><small>skipping to change at</small><a href="#part-1"><em> line 31<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-1"><em> line 31<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</td><td> </td><td class="right"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</td></tr>
      <tr><td class="left"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</td><td> </td><td class="right"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</td></tr>
      <tr><td class="left"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</td><td> </td><td class="right"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</td></tr>
      <tr><td class="left"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</td><td> </td><td class="right"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#ifndef EVENT2_BUFFER_H_INCLUDED_</td><td> </td><td class="right">#ifndef EVENT2_BUFFER_H_INCLUDED_</td></tr>
      <tr><td class="left">#define EVENT2_BUFFER_H_INCLUDED_</td><td> </td><td class="right">#define EVENT2_BUFFER_H_INCLUDED_</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @file event2/buffer.h</td><td> </td><td class="right">/** @file event2/buffer.h</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0001"></tr>
      <tr><td class="lblock">  Functions for buffering data for network sending or receiving.</td><td> </td><td class="rblock">  <span class="insert">@brief </span>Functions for buffering data for network sending or receiving.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  An evbuffer can be used for preparing data before sending it to</td><td> </td><td class="right">  An evbuffer can be used for preparing data before sending it to</td></tr>
      <tr><td class="left">  the network or conversely for reading data from the network.</td><td> </td><td class="right">  the network or conversely for reading data from the network.</td></tr>
      <tr><td class="left">  Evbuffers try to avoid memory copies as much as possible.  As a</td><td> </td><td class="right">  Evbuffers try to avoid memory copies as much as possible.  As a</td></tr>
      <tr><td class="left">  result, evbuffers can be used to pass data around without actually</td><td> </td><td class="right">  result, evbuffers can be used to pass data around without actually</td></tr>
      <tr><td class="left">  incurring the overhead of copying the data.</td><td> </td><td class="right">  incurring the overhead of copying the data.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  A new evbuffer can be allocated with evbuffer_new(), and can be</td><td> </td><td class="right">  A new evbuffer can be allocated with evbuffer_new(), and can be</td></tr>
      <tr><td class="left">  freed with evbuffer_free().  Most users will be using evbuffers via</td><td> </td><td class="right">  freed with evbuffer_free().  Most users will be using evbuffers via</td></tr>
      <tr><td class="left">  the bufferevent interface.  To access a bufferevent's evbuffers, use</td><td> </td><td class="right">  the bufferevent interface.  To access a bufferevent's evbuffers, use</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-2" class="change" ><th><small>skipping to change at</small><a href="#part-2"><em> line 162<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-2"><em> line 162<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">struct evbuffer *evbuffer_new(void);</td><td> </td><td class="right">struct evbuffer *evbuffer_new(void);</td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">  Deallocate storage for an evbuffer.</td><td> </td><td class="right">  Deallocate storage for an evbuffer.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  @param buf pointer to the evbuffer to be freed</td><td> </td><td class="right">  @param buf pointer to the evbuffer to be freed</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">void evbuffer_free(struct evbuffer *buf);</td><td> </td><td class="right">void evbuffer_free(struct evbuffer *buf);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr id="diff0002"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">  <span class="insert">Set maximum read buffer size</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  Default is 4096 and it works fine most of time, so before increasing the</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  default check carefully, since this has some negative effects (like memor</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">y</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  fragmentation and unfair resource distribution, i.e. some events will mak</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">e</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  less progress than others).</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  @param buf pointer to the evbuffer</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  @param max buffer size</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  @return 0 on success, -1 on failure (if max &gt; INT_MAX).</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">EVENT2_EXPORT_SYMBOL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int evbuffer_set_max_read(struct evbuffer *buf, size_t max);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  Get maximum read buffer size</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  @param buf pointer to the evbuffer</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  @return current maximum buffer read</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">EVENT2_EXPORT_SYMBOL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">size_t evbuffer_get_max_read(struct evbuffer *buf);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="left">   Enable locking on an evbuffer so that it can safely be used by multiple</td><td> </td><td class="right">   Enable locking on an evbuffer so that it can safely be used by multiple</td></tr>
      <tr><td class="left">   threads at the same time.</td><td> </td><td class="right">   threads at the same time.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   NOTE: when locking is enabled, the lock will be held when callbacks are</td><td> </td><td class="right">   NOTE: when locking is enabled, the lock will be held when callbacks are</td></tr>
      <tr><td class="left">   invoked.  This could result in deadlock if you aren't careful.  Plan</td><td> </td><td class="right">   invoked.  This could result in deadlock if you aren't careful.  Plan</td></tr>
      <tr><td class="left">   accordingly!</td><td> </td><td class="right">   accordingly!</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   @param buf An evbuffer to make lockable.</td><td> </td><td class="right">   @param buf An evbuffer to make lockable.</td></tr>
      <tr><td class="left">   @param lock A lock object, or NULL if we should allocate our own.</td><td> </td><td class="right">   @param lock A lock object, or NULL if we should allocate our own.</td></tr>
      <tr><td class="left">   @return 0 on success, -1 on failure.</td><td> </td><td class="right">   @return 0 on success, -1 on failure.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-3" class="change" ><th><small>skipping to change at</small><a href="#part-3"><em> line 209<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-3"><em> line 232<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> * information.</td><td> </td><td class="right"> * information.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * This flag is on by default for bufferevents that can take advantage</td><td> </td><td class="right"> * This flag is on by default for bufferevents that can take advantage</td></tr>
      <tr><td class="left"> * of it; you should never actually need to set it on a bufferevent's</td><td> </td><td class="right"> * of it; you should never actually need to set it on a bufferevent's</td></tr>
      <tr><td class="left"> * output buffer.</td><td> </td><td class="right"> * output buffer.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#define EVBUFFER_FLAG_DRAINS_TO_FD 1</td><td> </td><td class="right">#define EVBUFFER_FLAG_DRAINS_TO_FD 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Change the flags that are set for an evbuffer by adding more.</td><td> </td><td class="right">/** Change the flags that are set for an evbuffer by adding more.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr id="diff0003"></tr>
      <tr><td class="lblock"> * @param <span class="delete">buffer</span> the evbuffer that the callback is watching.</td><td> </td><td class="rblock"> * @param <span class="insert">buf</span> the evbuffer that the callback is watching.</td></tr>
      <tr><td class="lblock"> <span class="delete">* @param cb the callback whose status we want to change.</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> * @param flags One or more EVBUFFER_FLAG_* options</td><td> </td><td class="right"> * @param flags One or more EVBUFFER_FLAG_* options</td></tr>
      <tr><td class="left"> * @return 0 on success, -1 on failure.</td><td> </td><td class="right"> * @return 0 on success, -1 on failure.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">int evbuffer_set_flags(struct evbuffer *buf, ev_uint64_t flags);</td><td> </td><td class="right">int evbuffer_set_flags(struct evbuffer *buf, ev_uint64_t flags);</td></tr>
      <tr><td class="left">/** Change the flags that are set for an evbuffer by removing some.</td><td> </td><td class="right">/** Change the flags that are set for an evbuffer by removing some.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr id="diff0004"></tr>
      <tr><td class="lblock"> * @param <span class="delete">buffer</span> the evbuffer that the callback is watching.</td><td> </td><td class="rblock"> * @param <span class="insert">buf</span> the evbuffer that the callback is watching.</td></tr>
      <tr><td class="lblock"> <span class="delete">* @param cb the callback whose status we want to change.</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> * @param flags One or more EVBUFFER_FLAG_* options</td><td> </td><td class="right"> * @param flags One or more EVBUFFER_FLAG_* options</td></tr>
      <tr><td class="left"> * @return 0 on success, -1 on failure.</td><td> </td><td class="right"> * @return 0 on success, -1 on failure.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">int evbuffer_clear_flags(struct evbuffer *buf, ev_uint64_t flags);</td><td> </td><td class="right">int evbuffer_clear_flags(struct evbuffer *buf, ev_uint64_t flags);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">  Returns the total number of bytes stored in the evbuffer</td><td> </td><td class="right">  Returns the total number of bytes stored in the evbuffer</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  @param buf pointer to the evbuffer</td><td> </td><td class="right">  @param buf pointer to the evbuffer</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-4" class="change" ><th><small>skipping to change at</small><a href="#part-4"><em> line 531<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-4"><em> line 552<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">  @return 0 if successful, or -1 if an error occurred</td><td> </td><td class="right">  @return 0 if successful, or -1 if an error occurred</td></tr>
      <tr><td class="left">*/</td><td> </td><td class="right">*/</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">int evbuffer_add_file(struct evbuffer *outbuf, int fd, ev_off_t offset,</td><td> </td><td class="right">int evbuffer_add_file(struct evbuffer *outbuf, int fd, ev_off_t offset,</td></tr>
      <tr><td class="left">    ev_off_t length);</td><td> </td><td class="right">    ev_off_t length);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">  An evbuffer_file_segment holds a reference to a range of a file --</td><td> </td><td class="right">  An evbuffer_file_segment holds a reference to a range of a file --</td></tr>
      <tr><td class="left">  possibly the whole file! -- for use in writing from an evbuffer to a</td><td> </td><td class="right">  possibly the whole file! -- for use in writing from an evbuffer to a</td></tr>
      <tr id="diff0005"></tr>
      <tr><td class="lblock">  socket.  It could be implemented with <span class="delete">mmap,</span> sendfile, <span class="delete">splice,</span> or (if all</td><td> </td><td class="rblock">  socket.  It could be implemented with <span class="insert">mmap or</span> sendfile, or (if all else</td></tr>
      <tr><td class="lblock">  else fails) by just pulling all the data into RAM.  A single</td><td> </td><td class="rblock">  fails) by just pulling all the data into RAM. A single <span class="insert">evbuffer_file_segm</span></td></tr>
      <tr><td class="lblock">  <span class="delete">evbuffer_file_segment</span> can be added more than once, and to more than one</td><td> </td><td class="rblock"><span class="insert">ent</span></td></tr>
      <tr><td class="lblock">  evbuffer.</td><td> </td><td class="rblock">  can be added more than once, and to more than one evbuffer.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">struct evbuffer_file_segment;</td><td> </td><td class="right">struct evbuffer_file_segment;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">    Flag for creating evbuffer_file_segment: If this flag is set, then when</td><td> </td><td class="right">    Flag for creating evbuffer_file_segment: If this flag is set, then when</td></tr>
      <tr><td class="left">    the evbuffer_file_segment is freed and no longer in use by any</td><td> </td><td class="right">    the evbuffer_file_segment is freed and no longer in use by any</td></tr>
      <tr><td class="left">    evbuffer, the underlying fd is closed.</td><td> </td><td class="right">    evbuffer, the underlying fd is closed.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#define EVBUF_FS_CLOSE_ON_FREE    0x01</td><td> </td><td class="right">#define EVBUF_FS_CLOSE_ON_FREE    0x01</td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">   Flag for creating evbuffer_file_segment: Disable memory-map based</td><td> </td><td class="right">   Flag for creating evbuffer_file_segment: Disable memory-map based</td></tr>
      <tr><td class="left">   implementations.</td><td> </td><td class="right">   implementations.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#define EVBUF_FS_DISABLE_MMAP     0x02</td><td> </td><td class="right">#define EVBUF_FS_DISABLE_MMAP     0x02</td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">   Flag for creating evbuffer_file_segment: Disable direct fd-to-fd</td><td> </td><td class="right">   Flag for creating evbuffer_file_segment: Disable direct fd-to-fd</td></tr>
      <tr id="diff0006"></tr>
      <tr><td class="lblock">   implementations (<span class="delete">including sendfile and splic</span>e).</td><td> </td><td class="rblock">   implementations (<span class="insert">sendfil</span>e).</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   You might want to use this option if data needs to be taken from the</td><td> </td><td class="right">   You might want to use this option if data needs to be taken from the</td></tr>
      <tr><td class="left">   evbuffer by any means other than writing it to the network: the sendfile</td><td> </td><td class="right">   evbuffer by any means other than writing it to the network: the sendfile</td></tr>
      <tr><td class="left">   backend is fast, but it only works for sending files directly to the</td><td> </td><td class="right">   backend is fast, but it only works for sending files directly to the</td></tr>
      <tr><td class="left">   network.</td><td> </td><td class="right">   network.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#define EVBUF_FS_DISABLE_SENDFILE 0x04</td><td> </td><td class="right">#define EVBUF_FS_DISABLE_SENDFILE 0x04</td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">   Flag for creating evbuffer_file_segment: Do not allocate a lock for this</td><td> </td><td class="right">   Flag for creating evbuffer_file_segment: Do not allocate a lock for this</td></tr>
      <tr><td class="left">   segment.  If this option is set, then neither the segment nor any</td><td> </td><td class="right">   segment.  If this option is set, then neither the segment nor any</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-5" class="change" ><th><small>skipping to change at</small><a href="#part-5"><em> line 579<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-5"><em> line 599<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">   for reference.</td><td> </td><td class="right">   for reference.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef void (*evbuffer_file_segment_cleanup_cb)(</td><td> </td><td class="right">typedef void (*evbuffer_file_segment_cleanup_cb)(</td></tr>
      <tr><td class="left">    struct evbuffer_file_segment const* seg, int flags, void* arg);</td><td> </td><td class="right">    struct evbuffer_file_segment const* seg, int flags, void* arg);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">   Create and return a new evbuffer_file_segment for reading data from a</td><td> </td><td class="right">   Create and return a new evbuffer_file_segment for reading data from a</td></tr>
      <tr><td class="left">   file and sending it out via an evbuffer.</td><td> </td><td class="right">   file and sending it out via an evbuffer.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   This function avoids unnecessary data copies between userland and</td><td> </td><td class="right">   This function avoids unnecessary data copies between userland and</td></tr>
      <tr id="diff0007"></tr>
      <tr><td class="lblock">   kernel.  Where available, it uses sendfile<span class="delete"> or splice</span>.</td><td> </td><td class="rblock">   kernel.  Where available, it uses sendfile.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   The file descriptor must not be closed so long as any evbuffer is using</td><td> </td><td class="right">   The file descriptor must not be closed so long as any evbuffer is using</td></tr>
      <tr><td class="left">   this segment.</td><td> </td><td class="right">   this segment.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   The results of using evbuffer_remove() or evbuffer_pullup() or any other</td><td> </td><td class="right">   The results of using evbuffer_remove() or evbuffer_pullup() or any other</td></tr>
      <tr><td class="left">   function that reads bytes from an evbuffer on any evbuffer containing</td><td> </td><td class="right">   function that reads bytes from an evbuffer on any evbuffer containing</td></tr>
      <tr><td class="left">   the newly returned segment are undefined, unless you pass the</td><td> </td><td class="right">   the newly returned segment are undefined, unless you pass the</td></tr>
      <tr><td class="left">   EVBUF_FS_DISABLE_SENDFILE flag to this function.</td><td> </td><td class="right">   EVBUF_FS_DISABLE_SENDFILE flag to this function.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   @param fd an open file to read from.</td><td> </td><td class="right">   @param fd an open file to read from.</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr id="end" bgcolor="gray"><th colspan="5" align="center">&nbsp;End of changes. 7 change blocks.&nbsp;</th></tr>
     <tr class="stats"><th><i>11 lines changed or deleted</i></th><th><i> </i></th><th><i>34 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr id="part-1" bgcolor="orange"><th>&nbsp;buffer_compat.h (2.1.12)&nbsp;</th><th> </th><th>&nbsp;buffer_compat.h (current)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-1" class="change" ><th><small>skipping to change at</small><a href="#part-1"><em> line 34<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-1"><em> line 34<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</td><td> </td><td class="right"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifndef EVENT2_BUFFER_COMPAT_H_INCLUDED_</td><td> </td><td class="right">#ifndef EVENT2_BUFFER_COMPAT_H_INCLUDED_</td></tr>
      <tr><td class="left">#define EVENT2_BUFFER_COMPAT_H_INCLUDED_</td><td> </td><td class="right">#define EVENT2_BUFFER_COMPAT_H_INCLUDED_</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#include &lt;event2/visibility.h&gt;</td><td> </td><td class="right">#include &lt;event2/visibility.h&gt;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @file event2/buffer_compat.h</td><td> </td><td class="right">/** @file event2/buffer_compat.h</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0001"></tr>
      <tr><td class="lblock">       <span class="delete">Obsolete and deprecated versions of the functions in buffer.h: provi
</span>ded</td><td> </td><td class="rblock">       <span class="insert">@brief Obsolete and deprecated versions of the functions in buffer.h
: provi</span>ded</td></tr>
      <tr><td class="left">       only for backward compatibility.</td><td> </td><td class="right">       only for backward compatibility.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">   Obsolete alias for evbuffer_readln(buffer, NULL, EVBUFFER_EOL_ANY).</td><td> </td><td class="right">   Obsolete alias for evbuffer_readln(buffer, NULL, EVBUFFER_EOL_ANY).</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   @deprecated This function is deprecated because its behavior is not corr
ect</td><td> </td><td class="right">   @deprecated This function is deprecated because its behavior is not corr
ect</td></tr>
      <tr><td class="left">      for almost any protocol, and also because it's wholly subsumed by</td><td> </td><td class="right">      for almost any protocol, and also because it's wholly subsumed by</td></tr>
      <tr><td class="left">      evbuffer_readln().</td><td> </td><td class="right">      evbuffer_readln().</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr id="end" bgcolor="gray"><th colspan="5" align="center">&nbsp;End of changes. 1 change blocks.&nbsp;</th></tr>
     <tr class="stats"><th><i>1 lines changed or deleted</i></th><th><i> </i></th><th><i>1 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr id="part-1" bgcolor="orange"><th>&nbsp;bufferevent.h (2.1.12)&nbsp;</th><th> </th><th>&nbsp;bufferevent.h (current)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-1" class="change" ><th><small>skipping to change at</small><a href="#part-1"><em> line 33<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-1"><em> line 33<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</td><td> </td><td class="right"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</td></tr>
      <tr><td class="left"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</td><td> </td><td class="right"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</td></tr>
      <tr><td class="left"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</td><td> </td><td class="right"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#ifndef EVENT2_BUFFEREVENT_H_INCLUDED_</td><td> </td><td class="right">#ifndef EVENT2_BUFFEREVENT_H_INCLUDED_</td></tr>
      <tr><td class="left">#define EVENT2_BUFFEREVENT_H_INCLUDED_</td><td> </td><td class="right">#define EVENT2_BUFFEREVENT_H_INCLUDED_</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">   @file event2/bufferevent.h</td><td> </td><td class="right">   @file event2/bufferevent.h</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0001"></tr>
      <tr><td class="lblock">  Functions for buffering data for network sending or receiving.  <span class="delete">Buffereve</span></td><td> </td><td class="rblock">  <span class="insert">@brief</span> Functions for buffering data for network sending or receiving.</td></tr>
      <tr><td class="lblock"><span class="delete">nts</span></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="lblock">  are higher level than evbuffers: each has an underlying <span class="delete">evbuffer</span> for <span class="delete">read</span></td><td> </td><td class="rblock">  <span class="insert">Bufferevents</span> are higher level than evbuffers: each has an underlying <span class="insert">evbu</span></td></tr>
      <tr><td class="lblock"><span class="delete">ing</span></td><td> </td><td class="rblock"><span class="insert">ffer</span> for <span class="insert">reading</span></td></tr>
      <tr><td class="left">  and one for writing, and callbacks that are invoked under certain</td><td> </td><td class="right">  and one for writing, and callbacks that are invoked under certain</td></tr>
      <tr><td class="left">  circumstances.</td><td> </td><td class="right">  circumstances.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  A bufferevent provides input and output buffers that get filled and</td><td> </td><td class="right">  A bufferevent provides input and output buffers that get filled and</td></tr>
      <tr><td class="left">  drained automatically.  The user of a bufferevent no longer deals</td><td> </td><td class="right">  drained automatically.  The user of a bufferevent no longer deals</td></tr>
      <tr><td class="left">  directly with the I/O, but instead is reading from input and writing</td><td> </td><td class="right">  directly with the I/O, but instead is reading from input and writing</td></tr>
      <tr><td class="left">  to output buffers.</td><td> </td><td class="right">  to output buffers.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  Once initialized, the bufferevent structure can be used repeatedly</td><td> </td><td class="right">  Once initialized, the bufferevent structure can be used repeatedly</td></tr>
      <tr><td class="left">  with bufferevent_enable() and bufferevent_disable().</td><td> </td><td class="right">  with bufferevent_enable() and bufferevent_disable().</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-2" class="change" ><th><small>skipping to change at</small><a href="#part-2"><em> line 212<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-2"><em> line 213<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">   and configure the bufferevent so that a BEV_EVENT_CONNECTED event will b
e</td><td> </td><td class="right">   and configure the bufferevent so that a BEV_EVENT_CONNECTED event will b
e</td></tr>
      <tr><td class="left">   yielded when it is done connecting.</td><td> </td><td class="right">   yielded when it is done connecting.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   @param bufev an existing bufferevent allocated with</td><td> </td><td class="right">   @param bufev an existing bufferevent allocated with</td></tr>
      <tr><td class="left">       bufferevent_socket_new().</td><td> </td><td class="right">       bufferevent_socket_new().</td></tr>
      <tr><td class="left">   @param addr the address we should connect to</td><td> </td><td class="right">   @param addr the address we should connect to</td></tr>
      <tr><td class="left">   @param socklen The length of the address</td><td> </td><td class="right">   @param socklen The length of the address</td></tr>
      <tr><td class="left">   @return 0 on success, -1 on failure.</td><td> </td><td class="right">   @return 0 on success, -1 on failure.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr id="diff0002"></tr>
      <tr><td class="lblock">int bufferevent_socket_connect(struct bufferevent *<span class="delete">, const struct sockaddr 
*, int</span>);</td><td> </td><td class="rblock">int bufferevent_socket_connect(struct bufferevent *<span class="insert">bufev, const struct sock
addr *addr, int socklen</span>);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">struct evdns_base;</td><td> </td><td class="right">struct evdns_base;</td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">   Resolve the hostname 'hostname' and connect to it as with</td><td> </td><td class="right">   Resolve the hostname 'hostname' and connect to it as with</td></tr>
      <tr><td class="left">   bufferevent_socket_connect().</td><td> </td><td class="right">   bufferevent_socket_connect().</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   @param bufev An existing bufferevent allocated with bufferevent_socket_n
ew()</td><td> </td><td class="right">   @param bufev An existing bufferevent allocated with bufferevent_socket_n
ew()</td></tr>
      <tr><td class="left">   @param evdns_base Optionally, an evdns_base to use for resolving hostnam
es</td><td> </td><td class="right">   @param evdns_base Optionally, an evdns_base to use for resolving hostnam
es</td></tr>
      <tr><td class="left">      asynchronously. May be set to NULL for a blocking resolve.</td><td> </td><td class="right">      asynchronously. May be set to NULL for a blocking resolve.</td></tr>
      <tr><td class="left">   @param family A preferred address family to resolve addresses to, or</td><td> </td><td class="right">   @param family A preferred address family to resolve addresses to, or</td></tr>
      <tr><td class="left">      AF_UNSPEC for no preference.  Only AF_INET, AF_INET6, and AF_UNSPEC a
re</td><td> </td><td class="right">      AF_UNSPEC for no preference.  Only AF_INET, AF_INET6, and AF_UNSPEC a
re</td></tr>
      <tr><td class="left">      supported.</td><td> </td><td class="right">      supported.</td></tr>
      <tr><td class="left">   @param hostname The hostname to resolve; see below for notes on recogniz
ed</td><td> </td><td class="right">   @param hostname The hostname to resolve; see below for notes on recogniz
ed</td></tr>
      <tr><td class="left">      formats</td><td> </td><td class="right">      formats</td></tr>
      <tr><td class="left">   @param port The port to connect to on the resolved address.</td><td> </td><td class="right">   @param port The port to connect to on the resolved address.</td></tr>
      <tr><td class="left">   @return 0 if successful, -1 on failure.</td><td> </td><td class="right">   @return 0 if successful, -1 on failure.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0003"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">   <span class="insert">@see bufferevent_socket_connect_hostname_hints()</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">EVENT2_EXPORT_SYMBOL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int bufferevent_socket_connect_hostname(struct bufferevent *bufev,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    struct evdns_base *evdns_base, int family, const char *hostname, int po</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">rt);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   Resolve the hostname 'hostname' and connect to it as with</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   bufferevent_socket_connect().</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   @param bufev An existing bufferevent allocated with bufferevent_socket_n</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ew()</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   @param evdns_base Optionally, an evdns_base to use for resolving hostnam</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">es</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">      asynchronously. May be set to NULL for a blocking resolve.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   @param hints_in points to an addrinfo structure that specifies criteria </span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">for</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">      selecting the socket address structures to be used</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   @param hostname The hostname to resolve; see below for notes on recogniz</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ed</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">      formats</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   @param port The port to connect to on the resolved address.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   @return 0 if successful, -1 on failure.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">   Recognized hostname formats are:</td><td> </td><td class="right">   Recognized hostname formats are:</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       www.example.com (hostname)</td><td> </td><td class="right">       www.example.com (hostname)</td></tr>
      <tr><td class="left">       1.2.3.4         (ipv4address)</td><td> </td><td class="right">       1.2.3.4         (ipv4address)</td></tr>
      <tr><td class="left">       ::1             (ipv6address)</td><td> </td><td class="right">       ::1             (ipv6address)</td></tr>
      <tr><td class="left">       [::1]           ([ipv6address])</td><td> </td><td class="right">       [::1]           ([ipv6address])</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   Performance note: If you do not provide an evdns_base, this function</td><td> </td><td class="right">   Performance note: If you do not provide an evdns_base, this function</td></tr>
      <tr><td class="left">   may block while it waits for a DNS response.         This is probably no
t</td><td> </td><td class="right">   may block while it waits for a DNS response.         This is probably no
t</td></tr>
      <tr><td class="left">   what you want.</td><td> </td><td class="right">   what you want.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr id="diff0004"></tr>
      <tr><td class="lblock">int <span class="delete">bufferevent_socket_connect_hostname(struct</span> bufferevent <span class="delete">*,</span></td><td> </td><td class="rblock">int <span class="insert">bufferevent_socket_connect_hostname_hints(struct</span> bufferevent <span class="insert">*bufev,</span></td></tr>
      <tr><td class="lblock">    struct evdns_base <span class="delete">*, int,</span> const char <span class="delete">*, int);</span></td><td> </td><td class="rblock">    struct evdns_base <span class="insert">*evdns_base, const struct evutil_addrinfo *hints_in,</span> </td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">const char <span class="insert">*hostname, int port);</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">   Return the error code for the last failed DNS lookup attempt made by</td><td> </td><td class="right">   Return the error code for the last failed DNS lookup attempt made by</td></tr>
      <tr><td class="left">   bufferevent_socket_connect_hostname().</td><td> </td><td class="right">   bufferevent_socket_connect_hostname().</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   @param bev The bufferevent object.</td><td> </td><td class="right">   @param bev The bufferevent object.</td></tr>
      <tr><td class="left">   @return DNS error code.</td><td> </td><td class="right">   @return DNS error code.</td></tr>
      <tr><td class="left">   @see evutil_gai_strerror()</td><td> </td><td class="right">   @see evutil_gai_strerror()</td></tr>
      <tr><td class="left">*/</td><td> </td><td class="right">*/</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-3" class="change" ><th><small>skipping to change at</small><a href="#part-3"><em> line 358<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-3"><em> line 379<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">  Changes the file descriptor on which the bufferevent operates.</td><td> </td><td class="right">  Changes the file descriptor on which the bufferevent operates.</td></tr>
      <tr><td class="left">  Not supported for all bufferevent types.</td><td> </td><td class="right">  Not supported for all bufferevent types.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  @param bufev the bufferevent object for which to change the file descript
or</td><td> </td><td class="right">  @param bufev the bufferevent object for which to change the file descript
or</td></tr>
      <tr><td class="left">  @param fd the file descriptor to operate on</td><td> </td><td class="right">  @param fd the file descriptor to operate on</td></tr>
      <tr><td class="left">*/</td><td> </td><td class="right">*/</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">int bufferevent_setfd(struct bufferevent *bufev, evutil_socket_t fd);</td><td> </td><td class="right">int bufferevent_setfd(struct bufferevent *bufev, evutil_socket_t fd);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr id="diff0005"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">  <span class="insert">Replaces the file descriptor on which the bufferevent operates.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  Not supported for all bufferevent types.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  Unlike bufferevent_setfd() it will close previous file descriptor (if any</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">).</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  @param bufev the bufferevent object for which to change the file descript</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">or</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  @param fd the file descriptor to operate on</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">*/</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">EVENT2_EXPORT_SYMBOL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int bufferevent_replacefd(struct bufferevent *bufev, evutil_socket_t fd);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="left">   Returns the file descriptor associated with a bufferevent, or -1 if</td><td> </td><td class="right">   Returns the file descriptor associated with a bufferevent, or -1 if</td></tr>
      <tr><td class="left">   no file descriptor is associated with the bufferevent.</td><td> </td><td class="right">   no file descriptor is associated with the bufferevent.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">evutil_socket_t bufferevent_getfd(struct bufferevent *bufev);</td><td> </td><td class="right">evutil_socket_t bufferevent_getfd(struct bufferevent *bufev);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">   Returns the underlying bufferevent associated with a bufferevent (if</td><td> </td><td class="right">   Returns the underlying bufferevent associated with a bufferevent (if</td></tr>
      <tr><td class="left">   the bufferevent is a wrapper), or NULL if there is no underlying buffere
vent.</td><td> </td><td class="right">   the bufferevent is a wrapper), or NULL if there is no underlying buffere
vent.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-4" class="change" ><th><small>skipping to change at</small><a href="#part-4"><em> line 408<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-4"><em> line 441<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">int bufferevent_write_buffer(struct bufferevent *bufev, struct evbuffer *bu
f);</td><td> </td><td class="right">int bufferevent_write_buffer(struct bufferevent *bufev, struct evbuffer *bu
f);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">  Read data from a bufferevent buffer.</td><td> </td><td class="right">  Read data from a bufferevent buffer.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  The bufferevent_read() function is used to read data from the input buffe
r.</td><td> </td><td class="right">  The bufferevent_read() function is used to read data from the input buffe
r.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  @param bufev the bufferevent to be read from</td><td> </td><td class="right">  @param bufev the bufferevent to be read from</td></tr>
      <tr><td class="left">  @param data pointer to a buffer that will store the data</td><td> </td><td class="right">  @param data pointer to a buffer that will store the data</td></tr>
      <tr><td class="left">  @param size the size of the data buffer, in bytes</td><td> </td><td class="right">  @param size the size of the data buffer, in bytes</td></tr>
      <tr id="diff0006"></tr>
      <tr><td class="lblock">  @return the amount of data read, in bytes.</td><td> </td><td class="rblock">  @return the amount of data read, in bytes. <span class="insert">If 0 is returned, it is possib</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">le</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  that there is no data in the buffer or that the read failed.</span></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">size_t bufferevent_read(struct bufferevent *bufev, void *data, size_t size)
;</td><td> </td><td class="right">size_t bufferevent_read(struct bufferevent *bufev, void *data, size_t size)
;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">  Read data from a bufferevent buffer into an evbuffer.         This avoids</td><td> </td><td class="right">  Read data from a bufferevent buffer into an evbuffer.         This avoids</td></tr>
      <tr><td class="left">  memory copies.</td><td> </td><td class="right">  memory copies.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  @param bufev the bufferevent to be read from</td><td> </td><td class="right">  @param bufev the bufferevent to be read from</td></tr>
      <tr><td class="left">  @param buf the evbuffer to which to add data</td><td> </td><td class="right">  @param buf the evbuffer to which to add data</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-5" class="change" ><th><small>skipping to change at</small><a href="#part-5"><em> line 889<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-5"><em> line 923<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">/** Remove 'bev' from its current rate-limit group (if any). */</td><td> </td><td class="right">/** Remove 'bev' from its current rate-limit group (if any). */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">int bufferevent_remove_from_rate_limit_group(struct bufferevent *bev);</td><td> </td><td class="right">int bufferevent_remove_from_rate_limit_group(struct bufferevent *bev);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">   Set the size limit for single read operation.</td><td> </td><td class="right">   Set the size limit for single read operation.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   Set to 0 for a reasonable default.</td><td> </td><td class="right">   Set to 0 for a reasonable default.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   Return 0 on success and -1 on failure.</td><td> </td><td class="right">   Return 0 on success and -1 on failure.</td></tr>
      <tr id="diff0007"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">   <span class="insert">@see evbuffer_set_max_read()</span></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">int bufferevent_set_max_single_read(struct bufferevent *bev, size_t size);</td><td> </td><td class="right">int bufferevent_set_max_single_read(struct bufferevent *bev, size_t size);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">   Set the size limit for single write operation.</td><td> </td><td class="right">   Set the size limit for single write operation.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   Set to 0 for a reasonable default.</td><td> </td><td class="right">   Set to 0 for a reasonable default.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   Return 0 on success and -1 on failure.</td><td> </td><td class="right">   Return 0 on success and -1 on failure.</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr id="end" bgcolor="gray"><th colspan="5" align="center">&nbsp;End of changes. 7 change blocks.&nbsp;</th></tr>
     <tr class="stats"><th><i>8 lines changed or deleted</i></th><th><i> </i></th><th><i>52 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr id="part-1" bgcolor="orange"><th>&nbsp;bufferevent_compat.h (2.1.12)&nbsp;</th><th> </th><th>&nbsp;bufferevent_compat.h (current)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-1" class="change" ><th><small>skipping to change at</small><a href="#part-1"><em> line 31<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-1"><em> line 31<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT</td><td> </td><td class="right"> * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT</td></tr>
      <tr><td class="left"> * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE
,</td><td> </td><td class="right"> * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE
,</td></tr>
      <tr><td class="left"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</td><td> </td><td class="right"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</td></tr>
      <tr><td class="left"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</td><td> </td><td class="right"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</td></tr>
      <tr><td class="left"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</td><td> </td><td class="right"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</td></tr>
      <tr><td class="left"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</td><td> </td><td class="right"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#ifndef EVENT2_BUFFEREVENT_COMPAT_H_INCLUDED_</td><td> </td><td class="right">#ifndef EVENT2_BUFFEREVENT_COMPAT_H_INCLUDED_</td></tr>
      <tr><td class="left">#define EVENT2_BUFFEREVENT_COMPAT_H_INCLUDED_</td><td> </td><td class="right">#define EVENT2_BUFFEREVENT_COMPAT_H_INCLUDED_</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0001"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** @file event2/bufferevent_compat.h</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @brief Deprecated versions of the functions in bufferevent.h: provided</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * only for backwards compatibility.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">#include &lt;event2/visibility.h&gt;</td><td> </td><td class="right">#include &lt;event2/visibility.h&gt;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#define evbuffercb bufferevent_data_cb</td><td> </td><td class="right">#define evbuffercb bufferevent_data_cb</td></tr>
      <tr><td class="left">#define everrorcb bufferevent_event_cb</td><td> </td><td class="right">#define everrorcb bufferevent_event_cb</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">  Create a new bufferevent for an fd.</td><td> </td><td class="right">  Create a new bufferevent for an fd.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  This function is deprecated.  Use bufferevent_socket_new and</td><td> </td><td class="right">  This function is deprecated.  Use bufferevent_socket_new and</td></tr>
      <tr><td class="left">  bufferevent_set_callbacks instead.</td><td> </td><td class="right">  bufferevent_set_callbacks instead.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-2" class="change" ><th><small>skipping to change at</small><a href="#part-2"><em> line 84<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-2"><em> line 90<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">         error occurred</td><td> </td><td class="right">         error occurred</td></tr>
      <tr><td class="left">  @see bufferevent_base_set(), bufferevent_free()</td><td> </td><td class="right">  @see bufferevent_base_set(), bufferevent_free()</td></tr>
      <tr><td class="left">  */</td><td> </td><td class="right">  */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">struct bufferevent *bufferevent_new(evutil_socket_t fd,</td><td> </td><td class="right">struct bufferevent *bufferevent_new(evutil_socket_t fd,</td></tr>
      <tr><td class="left">    evbuffercb readcb, evbuffercb writecb, everrorcb errorcb, void *cbarg);</td><td> </td><td class="right">    evbuffercb readcb, evbuffercb writecb, everrorcb errorcb, void *cbarg);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">  Set the read and write timeout for a buffered event.</td><td> </td><td class="right">  Set the read and write timeout for a buffered event.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0002"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">  <span class="insert">@deprecated Use bufferevent_set_timeouts instead.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">  @param bufev the bufferevent to be modified</td><td> </td><td class="right">  @param bufev the bufferevent to be modified</td></tr>
      <tr><td class="left">  @param timeout_read the read timeout</td><td> </td><td class="right">  @param timeout_read the read timeout</td></tr>
      <tr><td class="left">  @param timeout_write the write timeout</td><td> </td><td class="right">  @param timeout_write the write timeout</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">void bufferevent_settimeout(struct bufferevent *bufev,</td><td> </td><td class="right">void bufferevent_settimeout(struct bufferevent *bufev,</td></tr>
      <tr><td class="left">    int timeout_read, int timeout_write);</td><td> </td><td class="right">    int timeout_read, int timeout_write);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#define EVBUFFER_READ          BEV_EVENT_READING</td><td> </td><td class="right">#define EVBUFFER_READ          BEV_EVENT_READING</td></tr>
      <tr><td class="left">#define EVBUFFER_WRITE         BEV_EVENT_WRITING</td><td> </td><td class="right">#define EVBUFFER_WRITE         BEV_EVENT_WRITING</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr id="end" bgcolor="gray"><th colspan="5" align="center">&nbsp;End of changes. 2 change blocks.&nbsp;</th></tr>
     <tr class="stats"><th><i>0 lines changed or deleted</i></th><th><i> </i></th><th><i>8 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr id="part-1" bgcolor="orange"><th>&nbsp;bufferevent_ssl.h (2.1.12)&nbsp;</th><th> </th><th>&nbsp;bufferevent_ssl.h (current)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-1" class="change" ><th><small>skipping to change at</small><a href="#part-1"><em> line 31<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-1"><em> line 31<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</td><td> </td><td class="right"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</td></tr>
      <tr><td class="left"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</td><td> </td><td class="right"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</td></tr>
      <tr><td class="left"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</td><td> </td><td class="right"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</td></tr>
      <tr><td class="left"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</td><td> </td><td class="right"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#ifndef EVENT2_BUFFEREVENT_SSL_H_INCLUDED_</td><td> </td><td class="right">#ifndef EVENT2_BUFFEREVENT_SSL_H_INCLUDED_</td></tr>
      <tr><td class="left">#define EVENT2_BUFFEREVENT_SSL_H_INCLUDED_</td><td> </td><td class="right">#define EVENT2_BUFFEREVENT_SSL_H_INCLUDED_</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @file event2/bufferevent_ssl.h</td><td> </td><td class="right">/** @file event2/bufferevent_ssl.h</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0001"></tr>
      <tr><td class="lblock">    OpenSSL support for bufferevents.</td><td> </td><td class="rblock">    <span class="insert">@brief </span>OpenSSL support for bufferevents.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#include &lt;event2/visibility.h&gt;</td><td> </td><td class="right">#include &lt;event2/visibility.h&gt;</td></tr>
      <tr><td class="left">#include &lt;event2/event-config.h&gt;</td><td> </td><td class="right">#include &lt;event2/event-config.h&gt;</td></tr>
      <tr><td class="left">#include &lt;event2/bufferevent.h&gt;</td><td> </td><td class="right">#include &lt;event2/bufferevent.h&gt;</td></tr>
      <tr><td class="left">#include &lt;event2/util.h&gt;</td><td> </td><td class="right">#include &lt;event2/util.h&gt;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">extern "C" {</td><td> </td><td class="right">extern "C" {</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0002"></tr>
      <tr><td class="lblock"><span class="delete">/* This is what openssl's SSL objects are underneath. */</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">struct ssl_st;</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock">                                                                           </td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">   The state of an SSL object to be used when creating a new</td><td> </td><td class="right">   The state of an SSL object to be used when creating a new</td></tr>
      <tr><td class="left">   SSL bufferevent.</td><td> </td><td class="right">   SSL bufferevent.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">enum bufferevent_ssl_state {</td><td> </td><td class="right">enum bufferevent_ssl_state {</td></tr>
      <tr><td class="left">       BUFFEREVENT_SSL_OPEN = 0,</td><td> </td><td class="right">       BUFFEREVENT_SSL_OPEN = 0,</td></tr>
      <tr><td class="left">       BUFFEREVENT_SSL_CONNECTING = 1,</td><td> </td><td class="right">       BUFFEREVENT_SSL_CONNECTING = 1,</td></tr>
      <tr><td class="left">       BUFFEREVENT_SSL_ACCEPTING = 2</td><td> </td><td class="right">       BUFFEREVENT_SSL_ACCEPTING = 2</td></tr>
      <tr><td class="left">};</td><td> </td><td class="right">};</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0003"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** Control how to report dirty SSL shutdowns.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    If the peer (or the network, or an attacker) closes the TCP</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    connection before closing the SSL channel, and the protocol is SSL &gt;= v</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">3,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    this is a "dirty" shutdown.  If BUFFEREVENT_SSL_DIRTY_SHUTDOWN is not s</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">et</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    (default), this is reported as BEV_EVENT_ERROR.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    If instead BUFFEREVENT_SSL_DIRTY_SHUTDOWN is set, a dirty shutdown is</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    reported as BEV_EVENT_EOF.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    (Note that if the protocol is &lt; SSLv3, you will always receive</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    BEV_EVENT_EOF, since SSL 2 and earlier cannot distinguish a secure</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    connection close from a dirty one.  This is one reason (among many)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    not to use SSL 2.)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">*/</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define BUFFEREVENT_SSL_DIRTY_SHUTDOWN 1</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** Control writes in the SSL bufferevents.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    By default SSL bufferevent will peek bytes from the buffer as the arriv</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ed.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    with respect to the segment boundaries in the buffer.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    However, by ignoring these segment boundaries number of packets to send</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    can be decreased.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    This flags will ignore the segment boundaries.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    Useful in conjunction with http layer.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">*/</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define BUFFEREVENT_SSL_BATCH_WRITE 2</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#if defined(EVENT__HAVE_OPENSSL) || defined(EVENT__HAVE_MBEDTLS)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Get flags of the SSL bufferevent.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @see BUFFEREVENT_SSL_*</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return flags or SIZE_MAX in case of error (if bufferevent is not SSL).</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">EVENT2_EXPORT_SYMBOL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ev_uint64_t bufferevent_ssl_get_flags(struct bufferevent *bev);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** Change the flags that are set for an ssl bufferevent by adding more.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param bev the ssl bufferevent.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param flags One or more BUFFEREVENT_SSL_* options</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return old flags success, EV_UINT64_MAX on failure.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">EVENT2_EXPORT_SYMBOL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ev_uint64_t bufferevent_ssl_set_flags(struct bufferevent *bev, ev_uint64_t </span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">flags);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** Change the flags that are set for an ssl bufferevent by removing some.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param bev the bufferevent.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param flags One or more BUFFEREVENT_SSL_* options</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return old flags success, EV_UINT64_MAX on failure.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">EVENT2_EXPORT_SYMBOL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ev_uint64_t bufferevent_ssl_clear_flags(struct bufferevent *bev, ev_uint64_</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">t flags);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#endif /* defined(EVENT__HAVE_OPENSSL) || defined(EVENT__HAVE_MBEDTLS) */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">#if defined(EVENT__HAVE_OPENSSL) || defined(EVENT_IN_DOXYGEN_)</td><td> </td><td class="right">#if defined(EVENT__HAVE_OPENSSL) || defined(EVENT_IN_DOXYGEN_)</td></tr>
      <tr id="diff0004"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* This is what openssl's SSL objects are underneath. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">struct ssl_st;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">   Create a new SSL bufferevent to send its data over another bufferevent.</td><td> </td><td class="right">   Create a new SSL bufferevent to send its data over another bufferevent.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   @param base An event_base to use to detect reading and writing.  It</td><td> </td><td class="right">   @param base An event_base to use to detect reading and writing.  It</td></tr>
      <tr><td class="left">      must also be the base for the underlying bufferevent.</td><td> </td><td class="right">      must also be the base for the underlying bufferevent.</td></tr>
      <tr><td class="left">   @param underlying A socket to use for this SSL</td><td> </td><td class="right">   @param underlying A socket to use for this SSL</td></tr>
      <tr><td class="left">   @param ssl A SSL* object from openssl.</td><td> </td><td class="right">   @param ssl A SSL* object from openssl.</td></tr>
      <tr><td class="left">   @param state The current state of the SSL connection</td><td> </td><td class="right">   @param state The current state of the SSL connection</td></tr>
      <tr><td class="left">   @param options One or more bufferevent_options</td><td> </td><td class="right">   @param options One or more bufferevent_options</td></tr>
      <tr><td class="left">   @return A new bufferevent on success, or NULL on failure</td><td> </td><td class="right">   @return A new bufferevent on success, or NULL on failure</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-2" class="change" ><th><small>skipping to change at</small><a href="#part-2"><em> line 93<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-2"><em> line 150<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">   @return A new bufferevent on success, or NULL on failure.</td><td> </td><td class="right">   @return A new bufferevent on success, or NULL on failure.</td></tr>
      <tr><td class="left">*/</td><td> </td><td class="right">*/</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">struct bufferevent *</td><td> </td><td class="right">struct bufferevent *</td></tr>
      <tr><td class="left">bufferevent_openssl_socket_new(struct event_base *base,</td><td> </td><td class="right">bufferevent_openssl_socket_new(struct event_base *base,</td></tr>
      <tr><td class="left">    evutil_socket_t fd,</td><td> </td><td class="right">    evutil_socket_t fd,</td></tr>
      <tr><td class="left">    struct ssl_st *ssl,</td><td> </td><td class="right">    struct ssl_st *ssl,</td></tr>
      <tr><td class="left">    enum bufferevent_ssl_state state,</td><td> </td><td class="right">    enum bufferevent_ssl_state state,</td></tr>
      <tr><td class="left">    int options);</td><td> </td><td class="right">    int options);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0005"></tr>
      <tr><td class="lblock">/** <span class="delete">Control how to report dirty SSL shutdowns.</span></td><td> </td><td class="rblock">/**</td></tr>
      <tr><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"> <span class="insert">* Get value of the BUFFEREVENT_SSL_DIRTY_SHUTDOWN flag.</span></td></tr>
      <tr><td class="lblock"><span class="delete">    If the peer (or the network, or an attacker) closes the TCP</span></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"><span class="delete">    connection before closing the SSL channel, and the protocol is SSL &gt;= v</span></td><td> </td><td class="rblock"><span class="insert"> * @see BUFFEREVENT_SSL_DIRTY_SHUTDOWN</span></td></tr>
      <tr><td class="lblock"><span class="delete">3,</span></td><td> </td><td class="rblock"><span class="insert"> * @deprecated</span> This <span class="insert">function</span> is <span class="insert">deprecated,</span> use <span class="insert">bufferevent_ssl_get_flags()</span></td></tr>
      <tr><td class="lblock"><span class="delete">    this is a "dirty" shutdown.  If allow_dirty_shutdown is 0 (default),</span></td><td> </td><td class="rblock"><span class="insert"> instead.</span></td></tr>
      <tr><td class="lblock"><span class="delete">    this is reported as BEV_EVENT_ERROR.</span></td><td> </td><td class="rblock"><span class="insert"> * @see bufferevent_ssl_get_flags()</span></td></tr>
      <tr><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"> */</td></tr>
      <tr><td class="lblock"><span class="delete">    If instead allow_dirty_shutdown=1, a dirty shutdown is reported as</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">    BEV_EVENT_EOF.</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">    (Note that if the protocol is &lt; SSLv3, you will always receive</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">    BEV_EVENT_EOF, since SSL 2 and earlier cannot distinguish a secure</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">    connection close from a dirty one.</span>  This is <span class="delete">one reason (among many)</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">    not to</span> use <span class="delete">SSL 2.)</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock">*/</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock">                                                                           </td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">int bufferevent_openssl_get_allow_dirty_shutdown(struct bufferevent *bev);</td><td> </td><td class="right">int bufferevent_openssl_get_allow_dirty_shutdown(struct bufferevent *bev);</td></tr>
      <tr id="diff0006"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Set value of the BUFFEREVENT_SSL_DIRTY_SHUTDOWN flag.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @see BUFFEREVENT_SSL_DIRTY_SHUTDOWN</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @deprecated This function is deprecated, use bufferevent_ssl_set_flags()</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> instead.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @see bufferevent_ssl_set_flags()</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">void bufferevent_openssl_set_allow_dirty_shutdown(struct bufferevent *bev,</td><td> </td><td class="right">void bufferevent_openssl_set_allow_dirty_shutdown(struct bufferevent *bev,</td></tr>
      <tr><td class="left">    int allow_dirty_shutdown);</td><td> </td><td class="right">    int allow_dirty_shutdown);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Return the underlying openssl SSL * object for an SSL bufferevent. */</td><td> </td><td class="right">/** Return the underlying openssl SSL * object for an SSL bufferevent. */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">struct ssl_st *</td><td> </td><td class="right">struct ssl_st *</td></tr>
      <tr><td class="left">bufferevent_openssl_get_ssl(struct bufferevent *bufev);</td><td> </td><td class="right">bufferevent_openssl_get_ssl(struct bufferevent *bufev);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Tells a bufferevent to begin SSL renegotiation. */</td><td> </td><td class="right">/** Tells a bufferevent to begin SSL renegotiation. */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">int bufferevent_ssl_renegotiate(struct bufferevent *bev);</td><td> </td><td class="right">int bufferevent_ssl_renegotiate(struct bufferevent *bev);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Return the most recent OpenSSL error reported on an SSL bufferevent. */</td><td> </td><td class="right">/** Return the most recent OpenSSL error reported on an SSL bufferevent. */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">unsigned long bufferevent_get_openssl_error(struct bufferevent *bev);</td><td> </td><td class="right">unsigned long bufferevent_get_openssl_error(struct bufferevent *bev);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr id="diff0007"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#if defined(EVENT__HAVE_MBEDTLS) || defined(EVENT_IN_DOXYGEN_)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">struct mbedtls_ssl_context;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">struct mbedtls_ssl_config;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef struct mbedtls_ssl_context mbedtls_dyncontext;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   Create a new SSL bufferevent to send its data over another bufferevent.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   @param base An event_base to use to detect reading and writing.  It</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">      must also be the base for the underlying bufferevent.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   @param underlying A socket to use for this SSL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   @param ssl A SSL* object from openssl.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   @param state The current state of the SSL connection</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   @param options One or more bufferevent_options</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   @return A new bufferevent on success, or NULL on failure</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">*/</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">EVENT2_EXPORT_SYMBOL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">struct bufferevent *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">bufferevent_mbedtls_filter_new(struct event_base *base,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    struct bufferevent *underlying,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    mbedtls_dyncontext *ssl,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    enum bufferevent_ssl_state state,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    int options);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   Create a new SSL bufferevent to send its data over an SSL * on a socket.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   @param base An event_base to use to detect reading and writing</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   @param fd A socket to use for this SSL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   @param ssl A SSL* object from mbedtls.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   @param state The current state of the SSL connection</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   @param options One or more bufferevent_options</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   @return A new bufferevent on success, or NULL on failure.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">*/</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">EVENT2_EXPORT_SYMBOL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">struct bufferevent *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">bufferevent_mbedtls_socket_new(struct event_base *base,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    evutil_socket_t fd,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    mbedtls_dyncontext *ssl,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    enum bufferevent_ssl_state state,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    int options);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Get value of the BUFFEREVENT_SSL_DIRTY_SHUTDOWN flag.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @see BUFFEREVENT_SSL_DIRTY_SHUTDOWN</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @deprecated This function is deprecated, use bufferevent_ssl_get_flags()</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> instead.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @see bufferevent_ssl_get_flags()</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">EVENT2_EXPORT_SYMBOL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int bufferevent_mbedtls_get_allow_dirty_shutdown(struct bufferevent *bev);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Set value of the BUFFEREVENT_SSL_DIRTY_SHUTDOWN flag.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @see BUFFEREVENT_SSL_DIRTY_SHUTDOWN</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @deprecated This function is deprecated, use bufferevent_ssl_set_flags()</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> instead.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @see bufferevent_ssl_set_flags()</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">EVENT2_EXPORT_SYMBOL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">void bufferevent_mbedtls_set_allow_dirty_shutdown(struct bufferevent *bev,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    int allow_dirty_shutdown);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** Return the underlying mbedtls SSL * object for an SSL bufferevent. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">EVENT2_EXPORT_SYMBOL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">struct mbedtls_ssl_context *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">bufferevent_mbedtls_get_ssl(struct bufferevent *bufev);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** Tells a bufferevent to begin SSL renegotiation. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">EVENT2_EXPORT_SYMBOL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int bufferevent_mbedtls_renegotiate(struct bufferevent *bev);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** Return the most recent MbedTLS error reported on an SSL bufferevent. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">EVENT2_EXPORT_SYMBOL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">unsigned long bufferevent_get_mbedtls_error(struct bufferevent *bev);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** Create a new heap-based MbedTLS context for use it in bufferevent_mbedt</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ls_* functions */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">EVENT2_EXPORT_SYMBOL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">mbedtls_dyncontext *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">bufferevent_mbedtls_dyncontext_new(struct mbedtls_ssl_config *conf);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** Deallocate heap-based MbedTLS context */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">EVENT2_EXPORT_SYMBOL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">void</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">bufferevent_mbedtls_dyncontext_free(mbedtls_dyncontext *ctx);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#endif</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">}</td><td> </td><td class="right">}</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#endif /* EVENT2_BUFFEREVENT_SSL_H_INCLUDED_ */</td><td> </td><td class="right">#endif /* EVENT2_BUFFEREVENT_SSL_H_INCLUDED_ */</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr id="end" bgcolor="gray"><th colspan="5" align="center">&nbsp;End of changes. 7 change blocks.&nbsp;</th></tr>
     <tr class="stats"><th><i>21 lines changed or deleted</i></th><th><i> </i></th><th><i>171 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr id="part-1" bgcolor="orange"><th>&nbsp;bufferevent_struct.h (2.1.12)&nbsp;</th><th> </th><th>&nbsp;bufferevent_struct.h (current)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-1" class="change" ><th><small>skipping to change at</small><a href="#part-1"><em> line 90<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-1"><em> line 90<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">       struct event ev_read;</td><td> </td><td class="right">       struct event ev_read;</td></tr>
      <tr><td class="left">       /** A write event that triggers when a timeout has happened or a soc
ket</td><td> </td><td class="right">       /** A write event that triggers when a timeout has happened or a soc
ket</td></tr>
      <tr><td class="left">           is ready to write data.  Only used by some subtypes of</td><td> </td><td class="right">           is ready to write data.  Only used by some subtypes of</td></tr>
      <tr><td class="left">           bufferevent. */</td><td> </td><td class="right">           bufferevent. */</td></tr>
      <tr><td class="left">       struct event ev_write;</td><td> </td><td class="right">       struct event ev_write;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       /** An input buffer. Only the bufferevent is allowed to add data to</td><td> </td><td class="right">       /** An input buffer. Only the bufferevent is allowed to add data to</td></tr>
      <tr><td class="left">           this buffer, though the user is allowed to drain it. */</td><td> </td><td class="right">           this buffer, though the user is allowed to drain it. */</td></tr>
      <tr><td class="left">       struct evbuffer *input;</td><td> </td><td class="right">       struct evbuffer *input;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0001"></tr>
      <tr><td class="lblock">       /** An <span class="delete">in</span>put buffer. Only the bufferevent is allowed to drain data</td><td> </td><td class="rblock">       /** An <span class="insert">out</span>put buffer. Only the bufferevent is allowed to drain data</td></tr>
      <tr><td class="left">           from this buffer, though the user is allowed to add it. */</td><td> </td><td class="right">           from this buffer, though the user is allowed to add it. */</td></tr>
      <tr><td class="left">       struct evbuffer *output;</td><td> </td><td class="right">       struct evbuffer *output;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       struct event_watermark wm_read;</td><td> </td><td class="right">       struct event_watermark wm_read;</td></tr>
      <tr><td class="left">       struct event_watermark wm_write;</td><td> </td><td class="right">       struct event_watermark wm_write;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       bufferevent_data_cb readcb;</td><td> </td><td class="right">       bufferevent_data_cb readcb;</td></tr>
      <tr><td class="left">       bufferevent_data_cb writecb;</td><td> </td><td class="right">       bufferevent_data_cb writecb;</td></tr>
      <tr><td class="left">       /* This should be called 'eventcb', but renaming it would break</td><td> </td><td class="right">       /* This should be called 'eventcb', but renaming it would break</td></tr>
      <tr><td class="left">        * backward compatibility */</td><td> </td><td class="right">        * backward compatibility */</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr id="end" bgcolor="gray"><th colspan="5" align="center">&nbsp;End of changes. 1 change blocks.&nbsp;</th></tr>
     <tr class="stats"><th><i>1 lines changed or deleted</i></th><th><i> </i></th><th><i>1 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr id="part-1" bgcolor="orange"><th>&nbsp;dns.h (2.1.12)&nbsp;</th><th> </th><th>&nbsp;dns.h (current)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-1" class="change" ><th><small>skipping to change at</small><a href="#part-1"><em> line 52<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-1"><em> line 52<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * You may wish to replace the word "Parts" with something else depending o
n</td><td> </td><td class="right"> * You may wish to replace the word "Parts" with something else depending o
n</td></tr>
      <tr><td class="left"> * the amount of original code.</td><td> </td><td class="right"> * the amount of original code.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * (Derivative works does not include programs which link against, run or i
nclude</td><td> </td><td class="right"> * (Derivative works does not include programs which link against, run or i
nclude</td></tr>
      <tr><td class="left"> * the source verbatim in their source distributions)</td><td> </td><td class="right"> * the source verbatim in their source distributions)</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @file event2/dns.h</td><td> </td><td class="right">/** @file event2/dns.h</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr id="diff0001"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* @brief Provides a few APIs to use for resolving DNS names, and a facilit</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">y</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * for implementing simple DNS servers.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="left"> * Welcome, gentle reader</td><td> </td><td class="right"> * Welcome, gentle reader</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Async DNS lookups are really a whole lot harder than they should be,</td><td> </td><td class="right"> * Async DNS lookups are really a whole lot harder than they should be,</td></tr>
      <tr><td class="left"> * mostly stemming from the fact that the libc resolver has never been</td><td> </td><td class="right"> * mostly stemming from the fact that the libc resolver has never been</td></tr>
      <tr><td class="left"> * very good at them. Before you use this library you should see if libc</td><td> </td><td class="right"> * very good at them. Before you use this library you should see if libc</td></tr>
      <tr><td class="left"> * can do the job for you with the modern async call getaddrinfo_a</td><td> </td><td class="right"> * can do the job for you with the modern async call getaddrinfo_a</td></tr>
      <tr><td class="left"> * (see http://www.imperialviolet.org/page25.html#e498). Otherwise,</td><td> </td><td class="right"> * (see http://www.imperialviolet.org/page25.html#e498). Otherwise,</td></tr>
      <tr><td class="left"> * please continue.</td><td> </td><td class="right"> * please continue.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * The library keeps track of the state of nameservers and will avoid</td><td> </td><td class="right"> * The library keeps track of the state of nameservers and will avoid</td></tr>
      <tr><td class="left"> * them when they go down. Otherwise it will round robin between them.</td><td> </td><td class="right"> * them when they go down. Otherwise it will round robin between them.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Quick start guide:</td><td> </td><td class="right"> * Quick start guide:</td></tr>
      <tr id="diff0002"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @code</span></td></tr>
      <tr><td class="left"> *   #include "evdns.h"</td><td> </td><td class="right"> *   #include "evdns.h"</td></tr>
      <tr><td class="left"> *   void callback(int result, char type, int count, int ttl,</td><td> </td><td class="right"> *   void callback(int result, char type, int count, int ttl,</td></tr>
      <tr><td class="left"> *              void *addresses, void *arg);</td><td> </td><td class="right"> *              void *addresses, void *arg);</td></tr>
      <tr><td class="left"> *   evdns_resolv_conf_parse(DNS_OPTIONS_ALL, "/etc/resolv.conf");</td><td> </td><td class="right"> *   evdns_resolv_conf_parse(DNS_OPTIONS_ALL, "/etc/resolv.conf");</td></tr>
      <tr><td class="left"> *   evdns_resolve("www.hostname.com", 0, callback, NULL);</td><td> </td><td class="right"> *   evdns_resolve("www.hostname.com", 0, callback, NULL);</td></tr>
      <tr id="diff0003"></tr>
      <tr><td class="lblock"> *</td><td> </td><td class="rblock"> *<span class="insert">@endcode</span></td></tr>
      <tr><td class="left"> * When the lookup is complete the callback function is called. The</td><td> </td><td class="right"> * When the lookup is complete the callback function is called. The</td></tr>
      <tr><td class="left"> * first argument will be one of the DNS_ERR_* defines in evdns.h.</td><td> </td><td class="right"> * first argument will be one of the DNS_ERR_* defines in evdns.h.</td></tr>
      <tr><td class="left"> * Hopefully it will be DNS_ERR_NONE, in which case type will be</td><td> </td><td class="right"> * Hopefully it will be DNS_ERR_NONE, in which case type will be</td></tr>
      <tr><td class="left"> * DNS_IPv4_A, count will be the number of IP addresses, ttl is the time</td><td> </td><td class="right"> * DNS_IPv4_A, count will be the number of IP addresses, ttl is the time</td></tr>
      <tr><td class="left"> * which the data can be cached for (in seconds), addresses will point</td><td> </td><td class="right"> * which the data can be cached for (in seconds), addresses will point</td></tr>
      <tr><td class="left"> * to an array of uint32_t's and arg will be whatever you passed to</td><td> </td><td class="right"> * to an array of uint32_t's and arg will be whatever you passed to</td></tr>
      <tr><td class="left"> * evdns_resolve.</td><td> </td><td class="right"> * evdns_resolve.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Searching:</td><td> </td><td class="right"> * Searching:</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-2" class="change" ><th><small>skipping to change at</small><a href="#part-2"><em> line 109<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-2"><em> line 113<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * The order of searches depends on the number of dots in the name. If the</td><td> </td><td class="right"> * The order of searches depends on the number of dots in the name. If the</td></tr>
      <tr><td class="left"> * number is greater than the ndots setting then the names is first tried</td><td> </td><td class="right"> * number is greater than the ndots setting then the names is first tried</td></tr>
      <tr><td class="left"> * globally. Otherwise each search domain is appended in turn.</td><td> </td><td class="right"> * globally. Otherwise each search domain is appended in turn.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * The ndots setting can either be set from a resolv.conf, or by calling</td><td> </td><td class="right"> * The ndots setting can either be set from a resolv.conf, or by calling</td></tr>
      <tr><td class="left"> * evdns_search_ndots_set.</td><td> </td><td class="right"> * evdns_search_ndots_set.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * For example, with ndots set to 1 (the default) and a search domain list 
of</td><td> </td><td class="right"> * For example, with ndots set to 1 (the default) and a search domain list 
of</td></tr>
      <tr><td class="left"> * ["myhome.net"]:</td><td> </td><td class="right"> * ["myhome.net"]:</td></tr>
      <tr id="diff0004"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">*</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * &lt;pre&gt;</span></td></tr>
      <tr><td class="left"> *  Query: www</td><td> </td><td class="right"> *  Query: www</td></tr>
      <tr><td class="left"> *  Order: www.myhome.net, www.</td><td> </td><td class="right"> *  Order: www.myhome.net, www.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> *  Query: www.abc</td><td> </td><td class="right"> *  Query: www.abc</td></tr>
      <tr><td class="left"> *  Order: www.abc., www.abc.myhome.net</td><td> </td><td class="right"> *  Order: www.abc., www.abc.myhome.net</td></tr>
      <tr id="diff0005"></tr>
      <tr><td class="lblock"> *</td><td> </td><td class="rblock"> *<span class="insert"> &lt;/pre&gt;</span></td></tr>
      <tr><td class="left"> * Internals:</td><td> </td><td class="right"> * Internals:</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Requests are kept in two queues. The first is the inflight queue. In</td><td> </td><td class="right"> * Requests are kept in two queues. The first is the inflight queue. In</td></tr>
      <tr><td class="left"> * this queue requests have an allocated transaction id and nameserver.</td><td> </td><td class="right"> * this queue requests have an allocated transaction id and nameserver.</td></tr>
      <tr><td class="left"> * They will soon be transmitted if they haven't already been.</td><td> </td><td class="right"> * They will soon be transmitted if they haven't already been.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * The second is the waiting queue. The size of the inflight ring is</td><td> </td><td class="right"> * The second is the waiting queue. The size of the inflight ring is</td></tr>
      <tr><td class="left"> * limited and all other requests wait in waiting queue for space. This</td><td> </td><td class="right"> * limited and all other requests wait in waiting queue for space. This</td></tr>
      <tr><td class="left"> * bounds the number of concurrent requests so that we don't flood the</td><td> </td><td class="right"> * bounds the number of concurrent requests so that we don't flood the</td></tr>
      <tr><td class="left"> * nameserver. Several algorithms require a full walk of the inflight</td><td> </td><td class="right"> * nameserver. Several algorithms require a full walk of the inflight</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-3" class="change" ><th><small>skipping to change at</small><a href="#part-3"><em> line 179<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-3"><em> line 185<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">/** The request was canceled via a call to evdns_cancel_request */</td><td> </td><td class="right">/** The request was canceled via a call to evdns_cancel_request */</td></tr>
      <tr><td class="left">#define DNS_ERR_CANCEL 69</td><td> </td><td class="right">#define DNS_ERR_CANCEL 69</td></tr>
      <tr><td class="left">/** There were no answers and no error condition in the DNS packet.</td><td> </td><td class="right">/** There were no answers and no error condition in the DNS packet.</td></tr>
      <tr><td class="left"> * This can happen when you ask for an address that exists, but a record</td><td> </td><td class="right"> * This can happen when you ask for an address that exists, but a record</td></tr>
      <tr><td class="left"> * type that doesn't. */</td><td> </td><td class="right"> * type that doesn't. */</td></tr>
      <tr><td class="left">#define DNS_ERR_NODATA 70</td><td> </td><td class="right">#define DNS_ERR_NODATA 70</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#define DNS_IPv4_A 1</td><td> </td><td class="right">#define DNS_IPv4_A 1</td></tr>
      <tr><td class="left">#define DNS_PTR 2</td><td> </td><td class="right">#define DNS_PTR 2</td></tr>
      <tr><td class="left">#define DNS_IPv6_AAAA 3</td><td> </td><td class="right">#define DNS_IPv6_AAAA 3</td></tr>
      <tr id="diff0006"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define DNS_CNAME 4</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0007"></tr>
      <tr><td class="lblock">#define DNS_QUERY_NO_SEARCH <span class="delete">1</span></td><td> </td><td class="rblock"><span class="insert">/** Disable searching for the query. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">#define DNS_QUERY_NO_SEARCH <span class="insert">0x01</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** Use TCP connections ("virtual circuits") for queries rather than UDP da</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">tagrams. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define DNS_QUERY_USEVC 0x02</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** Ignore trancation flag in responses (don't fallback to TCP connections)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define DNS_QUERY_IGNTC 0x04</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** Make a separate callback for CNAME in answer */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define DNS_CNAME_CALLBACK 0x80</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Allow searching */</td><td> </td><td class="right">/* Allow searching */</td></tr>
      <tr><td class="left">#define DNS_OPTION_SEARCH 1</td><td> </td><td class="right">#define DNS_OPTION_SEARCH 1</td></tr>
      <tr><td class="left">/* Parse "nameserver" and add default if no such section */</td><td> </td><td class="right">/* Parse "nameserver" and add default if no such section */</td></tr>
      <tr><td class="left">#define DNS_OPTION_NAMESERVERS 2</td><td> </td><td class="right">#define DNS_OPTION_NAMESERVERS 2</td></tr>
      <tr><td class="left">/* Parse additional options like:</td><td> </td><td class="right">/* Parse additional options like:</td></tr>
      <tr><td class="left"> * - timeout:</td><td> </td><td class="right"> * - timeout:</td></tr>
      <tr><td class="left"> * - getaddrinfo-allow-skew:</td><td> </td><td class="right"> * - getaddrinfo-allow-skew:</td></tr>
      <tr><td class="left"> * - max-timeouts:</td><td> </td><td class="right"> * - max-timeouts:</td></tr>
      <tr><td class="left"> * - max-inflight:</td><td> </td><td class="right"> * - max-inflight:</td></tr>
      <tr><td class="left"> * - attempts:</td><td> </td><td class="right"> * - attempts:</td></tr>
      <tr><td class="left"> * - randomize-case:</td><td> </td><td class="right"> * - randomize-case:</td></tr>
      <tr><td class="left"> * - initial-probe-timeout:</td><td> </td><td class="right"> * - initial-probe-timeout:</td></tr>
      <tr id="diff0008"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* - max-probe-timeout:</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * - probe-backoff-factor:</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * - tcp-idle-timeout:</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * - edns-udp-size:</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * - use-vc</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * - ignore-tc</span></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#define DNS_OPTION_MISC 4</td><td> </td><td class="right">#define DNS_OPTION_MISC 4</td></tr>
      <tr><td class="left">/* Load hosts file (i.e. "/etc/hosts") */</td><td> </td><td class="right">/* Load hosts file (i.e. "/etc/hosts") */</td></tr>
      <tr><td class="left">#define DNS_OPTION_HOSTSFILE 8</td><td> </td><td class="right">#define DNS_OPTION_HOSTSFILE 8</td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * All above:</td><td> </td><td class="right"> * All above:</td></tr>
      <tr><td class="left"> * - DNS_OPTION_SEARCH</td><td> </td><td class="right"> * - DNS_OPTION_SEARCH</td></tr>
      <tr><td class="left"> * - DNS_OPTION_NAMESERVERS</td><td> </td><td class="right"> * - DNS_OPTION_NAMESERVERS</td></tr>
      <tr><td class="left"> * - DNS_OPTION_MISC</td><td> </td><td class="right"> * - DNS_OPTION_MISC</td></tr>
      <tr><td class="left"> * - DNS_OPTION_HOSTSFILE</td><td> </td><td class="right"> * - DNS_OPTION_HOSTSFILE</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-4" class="change" ><th><small>skipping to change at</small><a href="#part-4"><em> line 244<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-4"><em> line 264<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">/** Flag for evdns_base_new: process resolv.conf.  */</td><td> </td><td class="right">/** Flag for evdns_base_new: process resolv.conf.  */</td></tr>
      <tr><td class="left">#define EVDNS_BASE_INITIALIZE_NAMESERVERS 1</td><td> </td><td class="right">#define EVDNS_BASE_INITIALIZE_NAMESERVERS 1</td></tr>
      <tr><td class="left">/** Flag for evdns_base_new: Do not prevent the libevent event loop from</td><td> </td><td class="right">/** Flag for evdns_base_new: Do not prevent the libevent event loop from</td></tr>
      <tr><td class="left"> * exiting when we have no active dns requests. */</td><td> </td><td class="right"> * exiting when we have no active dns requests. */</td></tr>
      <tr><td class="left">#define EVDNS_BASE_DISABLE_WHEN_INACTIVE 0x8000</td><td> </td><td class="right">#define EVDNS_BASE_DISABLE_WHEN_INACTIVE 0x8000</td></tr>
      <tr><td class="left">/** Flag for evdns_base_new: If EVDNS_BASE_INITIALIZE_NAMESERVERS isset, do
 not</td><td> </td><td class="right">/** Flag for evdns_base_new: If EVDNS_BASE_INITIALIZE_NAMESERVERS isset, do
 not</td></tr>
      <tr><td class="left"> * add default nameserver if there are no nameservers in resolv.conf</td><td> </td><td class="right"> * add default nameserver if there are no nameservers in resolv.conf</td></tr>
      <tr><td class="left"> * @see DNS_OPTION_NAMESERVERS_NO_DEFAULT */</td><td> </td><td class="right"> * @see DNS_OPTION_NAMESERVERS_NO_DEFAULT */</td></tr>
      <tr><td class="left">#define EVDNS_BASE_NAMESERVERS_NO_DEFAULT 0x10000</td><td> </td><td class="right">#define EVDNS_BASE_NAMESERVERS_NO_DEFAULT 0x10000</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0009"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* No errors */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define EVDNS_ERROR_NONE 0</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* Failed to open file */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define EVDNS_ERROR_FAILED_TO_OPEN_FILE 1</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* Failed to stat file */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define EVDNS_ERROR_FAILED_TO_STAT_FILE 2</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* File too large */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define EVDNS_ERROR_FILE_TOO_LARGE 3</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* Out of memory */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define EVDNS_ERROR_OUT_OF_MEMORY 4</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* Short read from file */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define EVDNS_ERROR_SHORT_READ_FROM_FILE 5</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* No nameservers configured */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define EVDNS_ERROR_NO_NAMESERVERS_CONFIGURED 6</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">  Initialize the asynchronous DNS library.</td><td> </td><td class="right">  Initialize the asynchronous DNS library.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  This function initializes support for non-blocking name resolution by</td><td> </td><td class="right">  This function initializes support for non-blocking name resolution by</td></tr>
      <tr><td class="left">  calling evdns_resolv_conf_parse() on UNIX and</td><td> </td><td class="right">  calling evdns_resolv_conf_parse() on UNIX and</td></tr>
      <tr><td class="left">  evdns_config_windows_nameservers() on Windows.</td><td> </td><td class="right">  evdns_config_windows_nameservers() on Windows.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  @param event_base the event base to associate the dns client with</td><td> </td><td class="right">  @param event_base the event base to associate the dns client with</td></tr>
      <tr><td class="left">  @param flags any of EVDNS_BASE_INITIALIZE_NAMESERVERS|</td><td> </td><td class="right">  @param flags any of EVDNS_BASE_INITIALIZE_NAMESERVERS|</td></tr>
      <tr><td class="left">    EVDNS_BASE_DISABLE_WHEN_INACTIVE|EVDNS_BASE_NAMESERVERS_NO_DEFAULT</td><td> </td><td class="right">    EVDNS_BASE_DISABLE_WHEN_INACTIVE|EVDNS_BASE_NAMESERVERS_NO_DEFAULT</td></tr>
      <tr><td class="left">  @return evdns_base object if successful, or NULL if an error occurred.</td><td> </td><td class="right">  @return evdns_base object if successful, or NULL if an error occurred.</td></tr>
      <tr><td class="left">  @see evdns_base_free()</td><td> </td><td class="right">  @see evdns_base_free()</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr id="diff0010"></tr>
      <tr><td class="lblock">struct evdns_base * evdns_base_new(struct event_base *event_base, int <span class="delete">initi
alize_nameservers</span>);</td><td> </td><td class="rblock">struct evdns_base * evdns_base_new(struct event_base *event_base, int <span class="insert">flags
</span>);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">  Shut down the asynchronous DNS resolver and terminate all active requests
.</td><td> </td><td class="right">  Shut down the asynchronous DNS resolver and terminate all active requests
.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  If the 'fail_requests' option is enabled, all active requests will return</td><td> </td><td class="right">  If the 'fail_requests' option is enabled, all active requests will return</td></tr>
      <tr><td class="left">  an empty result with the error flag set to DNS_ERR_SHUTDOWN. Otherwise,</td><td> </td><td class="right">  an empty result with the error flag set to DNS_ERR_SHUTDOWN. Otherwise,</td></tr>
      <tr><td class="left">  the requests will be silently discarded.</td><td> </td><td class="right">  the requests will be silently discarded.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0011"></tr>
      <tr><td class="lblock">  @param <span class="delete">evdns_</span>base the evdns base to free</td><td> </td><td class="rblock">  @param base the evdns base to free</td></tr>
      <tr><td class="left">  @param fail_requests if zero, active requests will be aborted; if non-zer
o,</td><td> </td><td class="right">  @param fail_requests if zero, active requests will be aborted; if non-zer
o,</td></tr>
      <tr><td class="left">               active requests will return DNS_ERR_SHUTDOWN.</td><td> </td><td class="right">               active requests will return DNS_ERR_SHUTDOWN.</td></tr>
      <tr><td class="left">  @see evdns_base_new()</td><td> </td><td class="right">  @see evdns_base_new()</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">void evdns_base_free(struct evdns_base *base, int fail_requests);</td><td> </td><td class="right">void evdns_base_free(struct evdns_base *base, int fail_requests);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">   Remove all hosts entries that have been loaded into the event_base via</td><td> </td><td class="right">   Remove all hosts entries that have been loaded into the event_base via</td></tr>
      <tr><td class="left">   evdns_base_load_hosts or via event_base_resolv_conf_parse.</td><td> </td><td class="right">   evdns_base_load_hosts or via event_base_resolv_conf_parse.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0012"></tr>
      <tr><td class="lblock">   @param <span class="delete">evdns_</span>base the evdns base to remove outdated host addresses from</td><td> </td><td class="rblock">   @param base the evdns base to remove outdated host addresses from</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">void evdns_base_clear_host_addresses(struct evdns_base *base);</td><td> </td><td class="right">void evdns_base_clear_host_addresses(struct evdns_base *base);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">  Convert a DNS error code to a string.</td><td> </td><td class="right">  Convert a DNS error code to a string.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  @param err the DNS error code</td><td> </td><td class="right">  @param err the DNS error code</td></tr>
      <tr><td class="left">  @return a string containing an explanation of the error code</td><td> </td><td class="right">  @return a string containing an explanation of the error code</td></tr>
      <tr><td class="left">*/</td><td> </td><td class="right">*/</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-5" class="change" ><th><small>skipping to change at</small><a href="#part-5"><em> line 384<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-5"><em> line 419<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">evdns_base_nameserver_sockaddr_add(struct evdns_base *base,</td><td> </td><td class="right">evdns_base_nameserver_sockaddr_add(struct evdns_base *base,</td></tr>
      <tr><td class="left">    const struct sockaddr *sa, ev_socklen_t len, unsigned flags);</td><td> </td><td class="right">    const struct sockaddr *sa, ev_socklen_t len, unsigned flags);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">struct evdns_request;</td><td> </td><td class="right">struct evdns_request;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">  Lookup an A record for a given name.</td><td> </td><td class="right">  Lookup an A record for a given name.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  @param base the evdns_base to which to apply this operation</td><td> </td><td class="right">  @param base the evdns_base to which to apply this operation</td></tr>
      <tr><td class="left">  @param name a DNS hostname</td><td> </td><td class="right">  @param name a DNS hostname</td></tr>
      <tr id="diff0013"></tr>
      <tr><td class="lblock">  @param flags either 0, or <span class="delete">DNS_QUERY_NO_SEARCH to disable searching for th
is query</span>.</td><td> </td><td class="rblock">  @param flags either 0, or <span class="insert">combination of DNS_QUERY_* flags</span>.</td></tr>
      <tr><td class="left">  @param callback a callback function to invoke when the request is complet
ed</td><td> </td><td class="right">  @param callback a callback function to invoke when the request is complet
ed</td></tr>
      <tr><td class="left">  @param ptr an argument to pass to the callback function</td><td> </td><td class="right">  @param ptr an argument to pass to the callback function</td></tr>
      <tr><td class="left">  @return an evdns_request object if successful, or NULL if an error occurr
ed.</td><td> </td><td class="right">  @return an evdns_request object if successful, or NULL if an error occurr
ed.</td></tr>
      <tr><td class="left">  @see evdns_resolve_ipv6(), evdns_resolve_reverse(), evdns_resolve_reverse
_ipv6(), evdns_cancel_request()</td><td> </td><td class="right">  @see evdns_resolve_ipv6(), evdns_resolve_reverse(), evdns_resolve_reverse
_ipv6(), evdns_cancel_request()</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">struct evdns_request *evdns_base_resolve_ipv4(struct evdns_base *base, cons
t char *name, int flags, evdns_callback_type callback, void *ptr);</td><td> </td><td class="right">struct evdns_request *evdns_base_resolve_ipv4(struct evdns_base *base, cons
t char *name, int flags, evdns_callback_type callback, void *ptr);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">  Lookup an AAAA record for a given name.</td><td> </td><td class="right">  Lookup an AAAA record for a given name.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  @param base the evdns_base to which to apply this operation</td><td> </td><td class="right">  @param base the evdns_base to which to apply this operation</td></tr>
      <tr><td class="left">  @param name a DNS hostname</td><td> </td><td class="right">  @param name a DNS hostname</td></tr>
      <tr id="diff0014"></tr>
      <tr><td class="lblock">  @param flags either 0, or <span class="delete">DNS_QUERY_NO_SEARCH to disable searching for th
is query</span>.</td><td> </td><td class="rblock">  @param flags either 0, or <span class="insert">combination of DNS_QUERY_* flags</span>.</td></tr>
      <tr><td class="left">  @param callback a callback function to invoke when the request is complet
ed</td><td> </td><td class="right">  @param callback a callback function to invoke when the request is complet
ed</td></tr>
      <tr><td class="left">  @param ptr an argument to pass to the callback function</td><td> </td><td class="right">  @param ptr an argument to pass to the callback function</td></tr>
      <tr><td class="left">  @return an evdns_request object if successful, or NULL if an error occurr
ed.</td><td> </td><td class="right">  @return an evdns_request object if successful, or NULL if an error occurr
ed.</td></tr>
      <tr><td class="left">  @see evdns_resolve_ipv4(), evdns_resolve_reverse(), evdns_resolve_reverse
_ipv6(), evdns_cancel_request()</td><td> </td><td class="right">  @see evdns_resolve_ipv4(), evdns_resolve_reverse(), evdns_resolve_reverse
_ipv6(), evdns_cancel_request()</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">struct evdns_request *evdns_base_resolve_ipv6(struct evdns_base *base, cons
t char *name, int flags, evdns_callback_type callback, void *ptr);</td><td> </td><td class="right">struct evdns_request *evdns_base_resolve_ipv6(struct evdns_base *base, cons
t char *name, int flags, evdns_callback_type callback, void *ptr);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">struct in_addr;</td><td> </td><td class="right">struct in_addr;</td></tr>
      <tr><td class="left">struct in6_addr;</td><td> </td><td class="right">struct in6_addr;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">  Lookup a PTR record for a given IP address.</td><td> </td><td class="right">  Lookup a PTR record for a given IP address.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  @param base the evdns_base to which to apply this operation</td><td> </td><td class="right">  @param base the evdns_base to which to apply this operation</td></tr>
      <tr><td class="left">  @param in an IPv4 address</td><td> </td><td class="right">  @param in an IPv4 address</td></tr>
      <tr id="diff0015"></tr>
      <tr><td class="lblock">  @param flags either 0, or <span class="delete">DNS_QUERY_NO_SEARCH to disable searching for th
is query</span>.</td><td> </td><td class="rblock">  @param flags either 0, or <span class="insert">combination of DNS_QUERY_* flags</span>.</td></tr>
      <tr><td class="left">  @param callback a callback function to invoke when the request is complet
ed</td><td> </td><td class="right">  @param callback a callback function to invoke when the request is complet
ed</td></tr>
      <tr><td class="left">  @param ptr an argument to pass to the callback function</td><td> </td><td class="right">  @param ptr an argument to pass to the callback function</td></tr>
      <tr><td class="left">  @return an evdns_request object if successful, or NULL if an error occurr
ed.</td><td> </td><td class="right">  @return an evdns_request object if successful, or NULL if an error occurr
ed.</td></tr>
      <tr><td class="left">  @see evdns_resolve_reverse_ipv6(), evdns_cancel_request()</td><td> </td><td class="right">  @see evdns_resolve_reverse_ipv6(), evdns_cancel_request()</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">struct evdns_request *evdns_base_resolve_reverse(struct evdns_base *base, c
onst struct in_addr *in, int flags, evdns_callback_type callback, void *ptr
);</td><td> </td><td class="right">struct evdns_request *evdns_base_resolve_reverse(struct evdns_base *base, c
onst struct in_addr *in, int flags, evdns_callback_type callback, void *ptr
);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">  Lookup a PTR record for a given IPv6 address.</td><td> </td><td class="right">  Lookup a PTR record for a given IPv6 address.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  @param base the evdns_base to which to apply this operation</td><td> </td><td class="right">  @param base the evdns_base to which to apply this operation</td></tr>
      <tr><td class="left">  @param in an IPv6 address</td><td> </td><td class="right">  @param in an IPv6 address</td></tr>
      <tr id="diff0016"></tr>
      <tr><td class="lblock">  @param flags either 0, or <span class="delete">DNS_QUERY_NO_SEARCH to disable searching for th
is query</span>.</td><td> </td><td class="rblock">  @param flags either 0, or <span class="insert">combination of DNS_QUERY_* flags</span>.</td></tr>
      <tr><td class="left">  @param callback a callback function to invoke when the request is complet
ed</td><td> </td><td class="right">  @param callback a callback function to invoke when the request is complet
ed</td></tr>
      <tr><td class="left">  @param ptr an argument to pass to the callback function</td><td> </td><td class="right">  @param ptr an argument to pass to the callback function</td></tr>
      <tr><td class="left">  @return an evdns_request object if successful, or NULL if an error occurr
ed.</td><td> </td><td class="right">  @return an evdns_request object if successful, or NULL if an error occurr
ed.</td></tr>
      <tr><td class="left">  @see evdns_resolve_reverse_ipv6(), evdns_cancel_request()</td><td> </td><td class="right">  @see evdns_resolve_reverse_ipv6(), evdns_cancel_request()</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">struct evdns_request *evdns_base_resolve_reverse_ipv6(struct evdns_base *ba
se, const struct in6_addr *in, int flags, evdns_callback_type callback, voi
d *ptr);</td><td> </td><td class="right">struct evdns_request *evdns_base_resolve_reverse_ipv6(struct evdns_base *ba
se, const struct in6_addr *in, int flags, evdns_callback_type callback, voi
d *ptr);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">  Cancels a pending DNS resolution request.</td><td> </td><td class="right">  Cancels a pending DNS resolution request.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-6" class="change" ><th><small>skipping to change at</small><a href="#part-6"><em> line 454<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-6"><em> line 489<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">*/</td><td> </td><td class="right">*/</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">void evdns_cancel_request(struct evdns_base *base, struct evdns_request *re
q);</td><td> </td><td class="right">void evdns_cancel_request(struct evdns_base *base, struct evdns_request *re
q);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">  Set the value of a configuration option.</td><td> </td><td class="right">  Set the value of a configuration option.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  The currently available configuration options are:</td><td> </td><td class="right">  The currently available configuration options are:</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">    ndots, timeout, max-timeouts, max-inflight, attempts, randomize-case,</td><td> </td><td class="right">    ndots, timeout, max-timeouts, max-inflight, attempts, randomize-case,</td></tr>
      <tr id="diff0017"></tr>
      <tr><td class="lblock">    bind-to, initial-probe-timeout, getaddrinfo-allow-skew,</td><td> </td><td class="rblock">    bind-to, initial-probe-timeout, <span class="insert">max-probe-timeout, probe-backoff-factor</span></td></tr>
      <tr><td class="lblock">    so-rcvbuf, <span class="delete">so-sndbuf.</span></td><td> </td><td class="rblock"><span class="insert">,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">    getaddrinfo-allow-skew, so-rcvbuf, <span class="insert">so-sndbuf, tcp-idle-timeout, use-vc,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    ignore-tc, edns-udp-size.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  - probe-backoff-factor</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    Backoff factor of probe timeout</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  - max-probe-timeout</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    Maximum timeout between two probe packets will change initial-probe-tim</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">eout</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    when this value is smaller</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  In versions before Libevent 2.0.3-alpha, the option name needed to end wi
th</td><td> </td><td class="right">  In versions before Libevent 2.0.3-alpha, the option name needed to end wi
th</td></tr>
      <tr><td class="left">  a colon.</td><td> </td><td class="right">  a colon.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0018"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">  <span class="insert">In case of options without values (use-vc, ingore-tc) val should be an em</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">pty</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  string or NULL.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">  @param base the evdns_base to which to apply this operation</td><td> </td><td class="right">  @param base the evdns_base to which to apply this operation</td></tr>
      <tr><td class="left">  @param option the name of the configuration option to be modified</td><td> </td><td class="right">  @param option the name of the configuration option to be modified</td></tr>
      <tr><td class="left">  @param val the value to be set</td><td> </td><td class="right">  @param val the value to be set</td></tr>
      <tr><td class="left">  @return 0 if successful, or -1 if an error occurred</td><td> </td><td class="right">  @return 0 if successful, or -1 if an error occurred</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">int evdns_base_set_option(struct evdns_base *base, const char *option, cons
t char *val);</td><td> </td><td class="right">int evdns_base_set_option(struct evdns_base *base, const char *option, cons
t char *val);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">  Parse a resolv.conf file.</td><td> </td><td class="right">  Parse a resolv.conf file.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  The 'flags' parameter determines what information is parsed from the</td><td> </td><td class="right">  The 'flags' parameter determines what information is parsed from the</td></tr>
      <tr><td class="left">  resolv.conf file. See the man page for resolv.conf for the format of this</td><td> </td><td class="right">  resolv.conf file. See the man page for resolv.conf for the format of this</td></tr>
      <tr><td class="left">  file.</td><td> </td><td class="right">  file.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  The following directives are not parsed from the file: sortlist, rotate,</td><td> </td><td class="right">  The following directives are not parsed from the file: sortlist, rotate,</td></tr>
      <tr><td class="left">  no-check-names, inet6, debug.</td><td> </td><td class="right">  no-check-names, inet6, debug.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0019"></tr>
      <tr><td class="lblock">  If this function encounters an error, the possible return values are: <span class="delete">1 =</span></td><td> </td><td class="rblock">  If this function encounters an error, the possible return values are:</td></tr>
      <tr><td class="lblock">  failed to open <span class="delete">file, 2 =</span> failed to stat <span class="delete">file, 3 =</span> file too <span class="delete">large, 4 =</span> out</td><td> </td><td class="rblock">   <span class="insert">EVDNS_ERROR_FAILED_TO_OPEN_FILE (1) -</span> failed to open <span class="insert">file</span></td></tr>
      <tr><td class="lblock"> of</td><td> </td><td class="rblock"><span class="insert">   EVDNS_ERROR_FAILED_TO_STAT_FILE (2) -</span> failed to stat <span class="insert">file</span></td></tr>
      <tr><td class="lblock">  <span class="delete">memory, 5 =</span> short read from <span class="delete">file, 6 =</span> no nameservers <span class="delete">listed in the file</span></td><td> </td><td class="rblock"><span class="insert">   EVDNS_ERROR_FILE_TOO_LARGE (3) -</span> file too <span class="insert">large</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   EVDNS_ERROR_OUT_OF_MEMORY (4) -</span> out of <span class="insert">memory</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   EVDNS_ERROR_SHORT_READ_FROM_FILE (5) -</span> short read from <span class="insert">file</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   EVDNS_ERROR_NO_NAMESERVERS_CONFIGURED (6) -</span> no nameservers <span class="insert">configured.</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  @param base the evdns_base to which to apply this operation</td><td> </td><td class="right">  @param base the evdns_base to which to apply this operation</td></tr>
      <tr><td class="left">  @param flags any of DNS_OPTION_NAMESERVERS|DNS_OPTION_SEARCH|DNS_OPTION_M
ISC|</td><td> </td><td class="right">  @param flags any of DNS_OPTION_NAMESERVERS|DNS_OPTION_SEARCH|DNS_OPTION_M
ISC|</td></tr>
      <tr><td class="left">    DNS_OPTION_HOSTSFILE|DNS_OPTIONS_ALL|DNS_OPTION_NAMESERVERS_NO_DEFAULT</td><td> </td><td class="right">    DNS_OPTION_HOSTSFILE|DNS_OPTIONS_ALL|DNS_OPTION_NAMESERVERS_NO_DEFAULT</td></tr>
      <tr><td class="left">  @param filename the path to the resolv.conf file</td><td> </td><td class="right">  @param filename the path to the resolv.conf file</td></tr>
      <tr><td class="left">  @return 0 if successful, or various positive error codes if an error</td><td> </td><td class="right">  @return 0 if successful, or various positive error codes if an error</td></tr>
      <tr><td class="left">    occurred (see above)</td><td> </td><td class="right">    occurred (see above)</td></tr>
      <tr><td class="left">  @see resolv.conf(3), evdns_config_windows_nameservers()</td><td> </td><td class="right">  @see resolv.conf(3), evdns_config_windows_nameservers()</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-7" class="change" ><th><small>skipping to change at</small><a href="#part-7"><em> line 568<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-7"><em> line 618<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">  Set the callback function to handle DNS log messages.  If this</td><td> </td><td class="right">  Set the callback function to handle DNS log messages.  If this</td></tr>
      <tr><td class="left">  callback is not set, evdns log messages are handled with the regular</td><td> </td><td class="right">  callback is not set, evdns log messages are handled with the regular</td></tr>
      <tr><td class="left">  Libevent logging system.</td><td> </td><td class="right">  Libevent logging system.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  @param fn the callback to be invoked when a log message is generated</td><td> </td><td class="right">  @param fn the callback to be invoked when a log message is generated</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">void evdns_set_log_fn(evdns_debug_log_fn_type fn);</td><td> </td><td class="right">void evdns_set_log_fn(evdns_debug_log_fn_type fn);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0020"></tr>
      <tr><td class="lblock"><span class="delete">/**</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">   Set a callback that will be invoked to generate transaction IDs.  By</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">   default, we pick transaction IDs based on the current clock time, which</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">   is bad for security.</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">   @param fn the new callback, or NULL to use the default.</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">   NOTE: This function has no effect in Libevent 2.0.4-alpha and later,</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">   since Libevent now provides its own secure RNG.</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> */</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">EVENT2_EXPORT_SYMBOL</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">void evdns_set_transaction_id_fn(ev_uint16_t (*fn)(void));</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">/**</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">   Set a callback used to generate random bytes.  By default, we use</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">   the same function as passed to evdns_set_transaction_id_fn to generate</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">   bytes two at a time.  If a function is provided here, it's also used</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">   to generate transaction IDs.</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">   NOTE: This function has no effect in Libevent 2.0.4-alpha and later,</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">   since Libevent now provides its own secure RNG.</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">*/</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">EVENT2_EXPORT_SYMBOL</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">void evdns_set_random_bytes_fn(void (*fn)(char *, size_t));</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock">                                                                           </td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left">/*</td><td> </td><td class="right">/*</td></tr>
      <tr><td class="left"> * Functions used to implement a DNS server.</td><td> </td><td class="right"> * Functions used to implement a DNS server.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">struct evdns_server_request;</td><td> </td><td class="right">struct evdns_server_request;</td></tr>
      <tr><td class="left">struct evdns_server_question;</td><td> </td><td class="right">struct evdns_server_question;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">   A callback to implement a DNS server.  The callback function receives a 
DNS</td><td> </td><td class="right">   A callback to implement a DNS server.  The callback function receives a 
DNS</td></tr>
      <tr><td class="left">   request.  It should then optionally add a number of answers to the reply</td><td> </td><td class="right">   request.  It should then optionally add a number of answers to the reply</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-8" class="change" ><th><small>skipping to change at</small><a href="#part-8"><em> line 634<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-8"><em> line 659<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#define EVDNS_QTYPE_AXFR 252</td><td> </td><td class="right">#define EVDNS_QTYPE_AXFR 252</td></tr>
      <tr><td class="left">#define EVDNS_QTYPE_ALL         255</td><td> </td><td class="right">#define EVDNS_QTYPE_ALL         255</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#define EVDNS_CLASS_INET   1</td><td> </td><td class="right">#define EVDNS_CLASS_INET   1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* flags that can be set in answers; as part of the err parameter */</td><td> </td><td class="right">/* flags that can be set in answers; as part of the err parameter */</td></tr>
      <tr><td class="left">#define EVDNS_FLAGS_AA 0x400</td><td> </td><td class="right">#define EVDNS_FLAGS_AA 0x400</td></tr>
      <tr><td class="left">#define EVDNS_FLAGS_RD 0x080</td><td> </td><td class="right">#define EVDNS_FLAGS_RD 0x080</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0021"></tr>
      <tr><td class="lblock">/** Create a new DNS server port.</td><td> </td><td class="rblock">/** Create a new <span class="insert">UDP </span>DNS server port.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">    @param base The event base to handle events for the server port.</td><td> </td><td class="right">    @param base The event base to handle events for the server port.</td></tr>
      <tr><td class="left">    @param socket A UDP socket to accept DNS requests.</td><td> </td><td class="right">    @param socket A UDP socket to accept DNS requests.</td></tr>
      <tr><td class="left">    @param flags Always 0 for now.</td><td> </td><td class="right">    @param flags Always 0 for now.</td></tr>
      <tr><td class="left">    @param callback A function to invoke whenever we get a DNS request</td><td> </td><td class="right">    @param callback A function to invoke whenever we get a DNS request</td></tr>
      <tr><td class="left">      on the socket.</td><td> </td><td class="right">      on the socket.</td></tr>
      <tr><td class="left">    @param user_data Data to pass to the callback.</td><td> </td><td class="right">    @param user_data Data to pass to the callback.</td></tr>
      <tr><td class="left">    @return an evdns_server_port structure for this server port or NULL if</td><td> </td><td class="right">    @return an evdns_server_port structure for this server port or NULL if</td></tr>
      <tr><td class="left">      an error occurred.</td><td> </td><td class="right">      an error occurred.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">struct evdns_server_port *evdns_add_server_port_with_base(struct event_base
 *base, evutil_socket_t socket, int flags, evdns_request_callback_fn_type c
allback, void *user_data);</td><td> </td><td class="right">struct evdns_server_port *evdns_add_server_port_with_base(struct event_base
 *base, evutil_socket_t socket, int flags, evdns_request_callback_fn_type c
allback, void *user_data);</td></tr>
      <tr id="diff0022"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">struct evconnlistener;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** Create a new TCP DNS server port.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    @param base The event base to handle events for the server port.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    @param listener A TCP listener to accept DNS requests.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    @param flags Always 0 for now.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    @param callback A function to invoke whenever we get a DNS request</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">      on the socket.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    @param user_data Data to pass to the callback.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    @return an evdns_server_port structure for this server port or NULL if</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">      an error occurred.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">EVENT2_EXPORT_SYMBOL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">struct evdns_server_port *evdns_add_server_port_with_listener(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    struct event_base *base, struct evconnlistener *listener, int flags,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    evdns_request_callback_fn_type callback, void *user_data);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/** Close down a DNS server port, and free associated structures. */</td><td> </td><td class="right">/** Close down a DNS server port, and free associated structures. */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">void evdns_close_server_port(struct evdns_server_port *port);</td><td> </td><td class="right">void evdns_close_server_port(struct evdns_server_port *port);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0023"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * List of configurable evdns_server_port options.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @see evdns_server_port_set_option()</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">enum evdns_server_option {</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * Maximum number of simultaneous tcp connections (clients)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * that server can hold. Can be set only for TCP DNS servers.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       EVDNS_SOPT_TCP_MAX_CLIENTS,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * Idle timeout (in seconds) of incoming TCP connections.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * If client doesn't send any requests via the connection</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * during this period connection is closed by the server.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * Can be set only for TCP DNS servers.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       EVDNS_SOPT_TCP_IDLE_TIMEOUT,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">};</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   Configure DNS server.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   @param port the evdns_server_port to which to apply this operation</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   @param option @see evdns_server_option for the list of possible options</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   @param val value of the option</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   @return 0 if successful, or -1 if an error occurred</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">EVENT2_EXPORT_SYMBOL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int evdns_server_port_set_option(struct evdns_server_port *port, enum evdns</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">_server_option option, size_t value);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/** Sets some flags in a reply we're building.</td><td> </td><td class="right">/** Sets some flags in a reply we're building.</td></tr>
      <tr><td class="left">    Allows setting of the AA or RD flags</td><td> </td><td class="right">    Allows setting of the AA or RD flags</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">void evdns_server_request_set_flags(struct evdns_server_request *req, int f
lags);</td><td> </td><td class="right">void evdns_server_request_set_flags(struct evdns_server_request *req, int f
lags);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Functions to add an answer to an in-progress DNS reply.</td><td> </td><td class="right">/* Functions to add an answer to an in-progress DNS reply.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">int evdns_server_request_add_reply(struct evdns_server_request *req, int se
ction, const char *name, int type, int dns_class, int ttl, int datalen, int
 is_name, const char *data);</td><td> </td><td class="right">int evdns_server_request_add_reply(struct evdns_server_request *req, int se
ction, const char *name, int type, int dns_class, int ttl, int datalen, int
 is_name, const char *data);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-9" class="change" ><th><small>skipping to change at</small><a href="#part-9"><em> line 738<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-9"><em> line 813<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">   @param len The number of bytes available at sa.</td><td> </td><td class="right">   @param len The number of bytes available at sa.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   @return the number of bytes written into sa on success.  On failure, ret
urns</td><td> </td><td class="right">   @return the number of bytes written into sa on success.  On failure, ret
urns</td></tr>
      <tr><td class="left">     -1 if idx is greater than the number of configured nameservers, or a</td><td> </td><td class="right">     -1 if idx is greater than the number of configured nameservers, or a</td></tr>
      <tr><td class="left">     value greater than 'len' if len was not high enough.</td><td> </td><td class="right">     value greater than 'len' if len was not high enough.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">int evdns_base_get_nameserver_addr(struct evdns_base *base, int idx,</td><td> </td><td class="right">int evdns_base_get_nameserver_addr(struct evdns_base *base, int idx,</td></tr>
      <tr><td class="left">    struct sockaddr *sa, ev_socklen_t len);</td><td> </td><td class="right">    struct sockaddr *sa, ev_socklen_t len);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0024"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   Retrieve the fd of the 'idx'th configured nameserver.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   @param base The evdns_base to examine.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   @param idx The index of the nameserver to get the address of.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   @return the fd value.  On failure, returns</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     -1 if idx is greater than the number of configured nameservers</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">EVENT2_EXPORT_SYMBOL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int evdns_base_get_nameserver_fd(struct evdns_base *base, int idx);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">}</td><td> </td><td class="right">}</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#endif  /* !EVENT2_DNS_H_INCLUDED_ */</td><td> </td><td class="right">#endif  /* !EVENT2_DNS_H_INCLUDED_ */</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr id="end" bgcolor="gray"><th colspan="5" align="center">&nbsp;End of changes. 24 change blocks.&nbsp;</th></tr>
     <tr class="stats"><th><i>42 lines changed or deleted</i></th><th><i> </i></th><th><i>135 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr id="part-1" bgcolor="orange"><th>&nbsp;dns_compat.h (2.1.12)&nbsp;</th><th> </th><th>&nbsp;dns_compat.h (current)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-1" class="change" ><th><small>skipping to change at</small><a href="#part-1"><em> line 32<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-1"><em> line 32<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</td><td> </td><td class="right"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</td></tr>
      <tr><td class="left"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</td><td> </td><td class="right"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</td></tr>
      <tr><td class="left"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</td><td> </td><td class="right"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</td></tr>
      <tr><td class="left"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</td><td> </td><td class="right"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#ifndef EVENT2_DNS_COMPAT_H_INCLUDED_</td><td> </td><td class="right">#ifndef EVENT2_DNS_COMPAT_H_INCLUDED_</td></tr>
      <tr><td class="left">#define EVENT2_DNS_COMPAT_H_INCLUDED_</td><td> </td><td class="right">#define EVENT2_DNS_COMPAT_H_INCLUDED_</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @file event2/dns_compat.h</td><td> </td><td class="right">/** @file event2/dns_compat.h</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0001"></tr>
      <tr><td class="lblock">  <span class="delete">Potentially non-threadsafe versions of the functions in dns.h: pro</span>vided</td><td> </td><td class="rblock">  <span class="insert">@brief Potentially non-threadsafe versions of the functions in dns.h: pro
</span>vided</td></tr>
      <tr><td class="left">  only for backwards compatibility.</td><td> </td><td class="right">  only for backwards compatibility.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">extern "C" {</td><td> </td><td class="right">extern "C" {</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#include &lt;event2/event-config.h&gt;</td><td> </td><td class="right">#include &lt;event2/event-config.h&gt;</td></tr>
      <tr><td class="left">#ifdef EVENT__HAVE_SYS_TYPES_H</td><td> </td><td class="right">#ifdef EVENT__HAVE_SYS_TYPES_H</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr id="end" bgcolor="gray"><th colspan="5" align="center">&nbsp;End of changes. 1 change blocks.&nbsp;</th></tr>
     <tr class="stats"><th><i>1 lines changed or deleted</i></th><th><i> </i></th><th><i>1 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr id="part-1" bgcolor="orange"><th>&nbsp;event-config.h (2.1.12)&nbsp;</th><th> </th><th>&nbsp;event-config.h (current)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-1" class="change" ><th><small>skipping to change at</small><a href="#part-1"><em> line 17<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-1"><em> line 17<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Do not rely on macros in this file existing in later versions.</td><td> </td><td class="right"> * Do not rely on macros in this file existing in later versions.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifndef EVENT2_EVENT_CONFIG_H_INCLUDED_</td><td> </td><td class="right">#ifndef EVENT2_EVENT_CONFIG_H_INCLUDED_</td></tr>
      <tr><td class="left">#define EVENT2_EVENT_CONFIG_H_INCLUDED_</td><td> </td><td class="right">#define EVENT2_EVENT_CONFIG_H_INCLUDED_</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* config.h.  Generated from config.h.in by configure.  */</td><td> </td><td class="right">/* config.h.  Generated from config.h.in by configure.  */</td></tr>
      <tr><td class="left">/* config.h.in.  Generated from configure.ac by autoheader.  */</td><td> </td><td class="right">/* config.h.in.  Generated from configure.ac by autoheader.  */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0001"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* Define if building universal (internal helper macro) */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* #undef EVENT__AC_APPLE_UNIVERSAL_BUILD */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/* Define if libevent should build without support for a debug mode */</td><td> </td><td class="right">/* Define if libevent should build without support for a debug mode */</td></tr>
      <tr><td class="left">/* #undef EVENT__DISABLE_DEBUG_MODE */</td><td> </td><td class="right">/* #undef EVENT__DISABLE_DEBUG_MODE */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define if libevent should not allow replacing the mm functions */</td><td> </td><td class="right">/* Define if libevent should not allow replacing the mm functions */</td></tr>
      <tr><td class="left">/* #undef EVENT__DISABLE_MM_REPLACEMENT */</td><td> </td><td class="right">/* #undef EVENT__DISABLE_MM_REPLACEMENT */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define if libevent should not be compiled with thread support */</td><td> </td><td class="right">/* Define if libevent should not be compiled with thread support */</td></tr>
      <tr><td class="left">/* #undef EVENT__DISABLE_THREAD_SUPPORT */</td><td> </td><td class="right">/* #undef EVENT__DISABLE_THREAD_SUPPORT */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if you have the `accept4' function. */</td><td> </td><td class="right">/* Define to 1 if you have the `accept4' function. */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-2" class="change" ><th><small>skipping to change at</small><a href="#part-2"><em> line 70<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-2"><em> line 73<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define if your system supports the epoll system calls */</td><td> </td><td class="right">/* Define if your system supports the epoll system calls */</td></tr>
      <tr><td class="left">#define EVENT__HAVE_EPOLL 1</td><td> </td><td class="right">#define EVENT__HAVE_EPOLL 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if you have the `epoll_create1' function. */</td><td> </td><td class="right">/* Define to 1 if you have the `epoll_create1' function. */</td></tr>
      <tr><td class="left">#define EVENT__HAVE_EPOLL_CREATE1 1</td><td> </td><td class="right">#define EVENT__HAVE_EPOLL_CREATE1 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if you have the `epoll_ctl' function. */</td><td> </td><td class="right">/* Define to 1 if you have the `epoll_ctl' function. */</td></tr>
      <tr><td class="left">#define EVENT__HAVE_EPOLL_CTL 1</td><td> </td><td class="right">#define EVENT__HAVE_EPOLL_CTL 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0002"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* Define to 1 if you have the `epoll_pwait2' function. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* #undef EVENT__HAVE_EPOLL_PWAIT2 */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/* Define to 1 if you have the &lt;errno.h&gt; header file. */</td><td> </td><td class="right">/* Define to 1 if you have the &lt;errno.h&gt; header file. */</td></tr>
      <tr><td class="left">#define EVENT__HAVE_ERRNO_H 1</td><td> </td><td class="right">#define EVENT__HAVE_ERRNO_H 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if you have the `eventfd' function. */</td><td> </td><td class="right">/* Define to 1 if you have the `eventfd' function. */</td></tr>
      <tr><td class="left">#define EVENT__HAVE_EVENTFD 1</td><td> </td><td class="right">#define EVENT__HAVE_EVENTFD 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define if your system supports event ports */</td><td> </td><td class="right">/* Define if your system supports event ports */</td></tr>
      <tr><td class="left">/* #undef EVENT__HAVE_EVENT_PORTS */</td><td> </td><td class="right">/* #undef EVENT__HAVE_EVENT_PORTS */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if you have the `fcntl' function. */</td><td> </td><td class="right">/* Define to 1 if you have the `fcntl' function. */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-3" class="change" ><th><small>skipping to change at</small><a href="#part-3"><em> line 160<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-3"><em> line 166<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if you have the `mach_absolute_time' function. */</td><td> </td><td class="right">/* Define to 1 if you have the `mach_absolute_time' function. */</td></tr>
      <tr><td class="left">/* #undef EVENT__HAVE_MACH_ABSOLUTE_TIME */</td><td> </td><td class="right">/* #undef EVENT__HAVE_MACH_ABSOLUTE_TIME */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if you have the &lt;mach/mach.h&gt; header file. */</td><td> </td><td class="right">/* Define to 1 if you have the &lt;mach/mach.h&gt; header file. */</td></tr>
      <tr><td class="left">/* #undef EVENT__HAVE_MACH_MACH_H */</td><td> </td><td class="right">/* #undef EVENT__HAVE_MACH_MACH_H */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if you have the &lt;mach/mach_time.h&gt; header file. */</td><td> </td><td class="right">/* Define to 1 if you have the &lt;mach/mach_time.h&gt; header file. */</td></tr>
      <tr><td class="left">/* #undef EVENT__HAVE_MACH_MACH_TIME_H */</td><td> </td><td class="right">/* #undef EVENT__HAVE_MACH_MACH_TIME_H */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0003"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* Define if the system has mbedtls */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* #undef EVENT__HAVE_MBEDTLS */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* Define to 1 if you have the &lt;mbedtls/ssl.h&gt; header file. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* #undef EVENT__HAVE_MBEDTLS_SSL_H */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/* Define to 1 if you have the &lt;memory.h&gt; header file. */</td><td> </td><td class="right">/* Define to 1 if you have the &lt;memory.h&gt; header file. */</td></tr>
      <tr><td class="left">#define EVENT__HAVE_MEMORY_H 1</td><td> </td><td class="right">#define EVENT__HAVE_MEMORY_H 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if you have the `mmap' function. */</td><td> </td><td class="right">/* Define to 1 if you have the `mmap' function. */</td></tr>
      <tr><td class="left">#define EVENT__HAVE_MMAP 1</td><td> </td><td class="right">#define EVENT__HAVE_MMAP 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0004"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* Define to 1 if you have the `mmap64' function. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define EVENT__HAVE_MMAP64 1</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/* Define to 1 if you have the `nanosleep' function. */</td><td> </td><td class="right">/* Define to 1 if you have the `nanosleep' function. */</td></tr>
      <tr><td class="left">#define EVENT__HAVE_NANOSLEEP 1</td><td> </td><td class="right">#define EVENT__HAVE_NANOSLEEP 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if you have the &lt;netdb.h&gt; header file. */</td><td> </td><td class="right">/* Define to 1 if you have the &lt;netdb.h&gt; header file. */</td></tr>
      <tr><td class="left">#define EVENT__HAVE_NETDB_H 1</td><td> </td><td class="right">#define EVENT__HAVE_NETDB_H 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if you have the &lt;netinet/in6.h&gt; header file. */</td><td> </td><td class="right">/* Define to 1 if you have the &lt;netinet/in6.h&gt; header file. */</td></tr>
      <tr><td class="left">/* #undef EVENT__HAVE_NETINET_IN6_H */</td><td> </td><td class="right">/* #undef EVENT__HAVE_NETINET_IN6_H */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if you have the &lt;netinet/in.h&gt; header file. */</td><td> </td><td class="right">/* Define to 1 if you have the &lt;netinet/in.h&gt; header file. */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-4" class="change" ><th><small>skipping to change at</small><a href="#part-4"><em> line 205<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-4"><em> line 220<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if you have the &lt;poll.h&gt; header file. */</td><td> </td><td class="right">/* Define to 1 if you have the &lt;poll.h&gt; header file. */</td></tr>
      <tr><td class="left">#define EVENT__HAVE_POLL_H 1</td><td> </td><td class="right">#define EVENT__HAVE_POLL_H 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if you have the `port_create' function. */</td><td> </td><td class="right">/* Define to 1 if you have the `port_create' function. */</td></tr>
      <tr><td class="left">/* #undef EVENT__HAVE_PORT_CREATE */</td><td> </td><td class="right">/* #undef EVENT__HAVE_PORT_CREATE */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if you have the &lt;port.h&gt; header file. */</td><td> </td><td class="right">/* Define to 1 if you have the &lt;port.h&gt; header file. */</td></tr>
      <tr><td class="left">/* #undef EVENT__HAVE_PORT_H */</td><td> </td><td class="right">/* #undef EVENT__HAVE_PORT_H */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0005"></tr>
      <tr><td class="lblock">/* Define if you have <span class="delete">POSIX threads libraries and header files. */</span></td><td> </td><td class="rblock">/* Define <span class="insert">to 1</span> if you have <span class="insert">the `pread' function.</span> */</td></tr>
      <tr><td class="lblock"><span class="delete">/* #undef EVENT__HAVE_PTHREAD</span> */</td><td> </td><td class="rblock"><span class="insert">#define EVENT__HAVE_PREAD 1</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define if we have pthreads on this system */</td><td> </td><td class="right">/* Define if we have pthreads on this system */</td></tr>
      <tr><td class="left">#define EVENT__HAVE_PTHREADS 1</td><td> </td><td class="right">#define EVENT__HAVE_PTHREADS 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0006"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* Define to 1 if you have the `pthread_mutexattr_setprotocol' function. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define EVENT__HAVE_PTHREAD_MUTEXATTR_SETPROTOCOL 1</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* Have PTHREAD_PRIO_INHERIT. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define EVENT__HAVE_PTHREAD_PRIO_INHERIT 1</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/* Define to 1 if you have the `putenv' function. */</td><td> </td><td class="right">/* Define to 1 if you have the `putenv' function. */</td></tr>
      <tr><td class="left">#define EVENT__HAVE_PUTENV 1</td><td> </td><td class="right">#define EVENT__HAVE_PUTENV 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if the system has the type `sa_family_t'. */</td><td> </td><td class="right">/* Define to 1 if the system has the type `sa_family_t'. */</td></tr>
      <tr><td class="left">#define EVENT__HAVE_SA_FAMILY_T 1</td><td> </td><td class="right">#define EVENT__HAVE_SA_FAMILY_T 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if you have the `select' function. */</td><td> </td><td class="right">/* Define to 1 if you have the `select' function. */</td></tr>
      <tr><td class="left">#define EVENT__HAVE_SELECT 1</td><td> </td><td class="right">#define EVENT__HAVE_SELECT 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if you have the `sendfile' function. */</td><td> </td><td class="right">/* Define to 1 if you have the `sendfile' function. */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-5" class="change" ><th><small>skipping to change at</small><a href="#part-5"><em> line 238<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-5"><em> line 259<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if you have the `setrlimit' function. */</td><td> </td><td class="right">/* Define to 1 if you have the `setrlimit' function. */</td></tr>
      <tr><td class="left">#define EVENT__HAVE_SETRLIMIT 1</td><td> </td><td class="right">#define EVENT__HAVE_SETRLIMIT 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if you have the `sigaction' function. */</td><td> </td><td class="right">/* Define to 1 if you have the `sigaction' function. */</td></tr>
      <tr><td class="left">#define EVENT__HAVE_SIGACTION 1</td><td> </td><td class="right">#define EVENT__HAVE_SIGACTION 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if you have the `signal' function. */</td><td> </td><td class="right">/* Define to 1 if you have the `signal' function. */</td></tr>
      <tr><td class="left">#define EVENT__HAVE_SIGNAL 1</td><td> </td><td class="right">#define EVENT__HAVE_SIGNAL 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0007"></tr>
      <tr><td class="lblock"><span class="delete">/* Define to 1 if you have the `splice' function. */</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">#define EVENT__HAVE_SPLICE 1</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock">                                                                           </td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left">/* Define to 1 if you have the &lt;stdarg.h&gt; header file. */</td><td> </td><td class="right">/* Define to 1 if you have the &lt;stdarg.h&gt; header file. */</td></tr>
      <tr><td class="left">#define EVENT__HAVE_STDARG_H 1</td><td> </td><td class="right">#define EVENT__HAVE_STDARG_H 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if you have the &lt;stddef.h&gt; header file. */</td><td> </td><td class="right">/* Define to 1 if you have the &lt;stddef.h&gt; header file. */</td></tr>
      <tr><td class="left">#define EVENT__HAVE_STDDEF_H 1</td><td> </td><td class="right">#define EVENT__HAVE_STDDEF_H 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if you have the &lt;stdint.h&gt; header file. */</td><td> </td><td class="right">/* Define to 1 if you have the &lt;stdint.h&gt; header file. */</td></tr>
      <tr><td class="left">#define EVENT__HAVE_STDINT_H 1</td><td> </td><td class="right">#define EVENT__HAVE_STDINT_H 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if you have the &lt;stdlib.h&gt; header file. */</td><td> </td><td class="right">/* Define to 1 if you have the &lt;stdlib.h&gt; header file. */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-6" class="change" ><th><small>skipping to change at</small><a href="#part-6"><em> line 265<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-6"><em> line 283<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if you have the &lt;string.h&gt; header file. */</td><td> </td><td class="right">/* Define to 1 if you have the &lt;string.h&gt; header file. */</td></tr>
      <tr><td class="left">#define EVENT__HAVE_STRING_H 1</td><td> </td><td class="right">#define EVENT__HAVE_STRING_H 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if you have the `strlcpy' function. */</td><td> </td><td class="right">/* Define to 1 if you have the `strlcpy' function. */</td></tr>
      <tr><td class="left">/* #undef EVENT__HAVE_STRLCPY */</td><td> </td><td class="right">/* #undef EVENT__HAVE_STRLCPY */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if you have the `strsep' function. */</td><td> </td><td class="right">/* Define to 1 if you have the `strsep' function. */</td></tr>
      <tr><td class="left">#define EVENT__HAVE_STRSEP 1</td><td> </td><td class="right">#define EVENT__HAVE_STRSEP 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0008"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* Define to 1 if you have the `strsignal' function. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define EVENT__HAVE_STRSIGNAL 1</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/* Define to 1 if you have the `strtok_r' function. */</td><td> </td><td class="right">/* Define to 1 if you have the `strtok_r' function. */</td></tr>
      <tr><td class="left">#define EVENT__HAVE_STRTOK_R 1</td><td> </td><td class="right">#define EVENT__HAVE_STRTOK_R 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if you have the `strtoll' function. */</td><td> </td><td class="right">/* Define to 1 if you have the `strtoll' function. */</td></tr>
      <tr><td class="left">#define EVENT__HAVE_STRTOLL 1</td><td> </td><td class="right">#define EVENT__HAVE_STRTOLL 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if the system has the type `struct addrinfo'. */</td><td> </td><td class="right">/* Define to 1 if the system has the type `struct addrinfo'. */</td></tr>
      <tr><td class="left">#define EVENT__HAVE_STRUCT_ADDRINFO 1</td><td> </td><td class="right">#define EVENT__HAVE_STRUCT_ADDRINFO 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if the system has the type `struct in6_addr'. */</td><td> </td><td class="right">/* Define to 1 if the system has the type `struct in6_addr'. */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-7" class="change" ><th><small>skipping to change at</small><a href="#part-7"><em> line 346<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-7"><em> line 367<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if you have the &lt;sys/resource.h&gt; header file. */</td><td> </td><td class="right">/* Define to 1 if you have the &lt;sys/resource.h&gt; header file. */</td></tr>
      <tr><td class="left">#define EVENT__HAVE_SYS_RESOURCE_H 1</td><td> </td><td class="right">#define EVENT__HAVE_SYS_RESOURCE_H 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if you have the &lt;sys/select.h&gt; header file. */</td><td> </td><td class="right">/* Define to 1 if you have the &lt;sys/select.h&gt; header file. */</td></tr>
      <tr><td class="left">#define EVENT__HAVE_SYS_SELECT_H 1</td><td> </td><td class="right">#define EVENT__HAVE_SYS_SELECT_H 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if you have the &lt;sys/sendfile.h&gt; header file. */</td><td> </td><td class="right">/* Define to 1 if you have the &lt;sys/sendfile.h&gt; header file. */</td></tr>
      <tr><td class="left">#define EVENT__HAVE_SYS_SENDFILE_H 1</td><td> </td><td class="right">#define EVENT__HAVE_SYS_SENDFILE_H 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0009"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* Define to 1 if you have the &lt;sys/signalfd.h&gt; header file. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define EVENT__HAVE_SYS_SIGNALFD_H 1</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/* Define to 1 if you have the &lt;sys/socket.h&gt; header file. */</td><td> </td><td class="right">/* Define to 1 if you have the &lt;sys/socket.h&gt; header file. */</td></tr>
      <tr><td class="left">#define EVENT__HAVE_SYS_SOCKET_H 1</td><td> </td><td class="right">#define EVENT__HAVE_SYS_SOCKET_H 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if you have the &lt;sys/stat.h&gt; header file. */</td><td> </td><td class="right">/* Define to 1 if you have the &lt;sys/stat.h&gt; header file. */</td></tr>
      <tr><td class="left">#define EVENT__HAVE_SYS_STAT_H 1</td><td> </td><td class="right">#define EVENT__HAVE_SYS_STAT_H 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if you have the &lt;sys/sysctl.h&gt; header file. */</td><td> </td><td class="right">/* Define to 1 if you have the &lt;sys/sysctl.h&gt; header file. */</td></tr>
      <tr><td class="left">/* #undef EVENT__HAVE_SYS_SYSCTL_H */</td><td> </td><td class="right">/* #undef EVENT__HAVE_SYS_SYSCTL_H */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if you have the &lt;sys/timerfd.h&gt; header file. */</td><td> </td><td class="right">/* Define to 1 if you have the &lt;sys/timerfd.h&gt; header file. */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-8" class="change" ><th><small>skipping to change at</small><a href="#part-8"><em> line 418<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-8"><em> line 442<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if you have the &lt;unistd.h&gt; header file. */</td><td> </td><td class="right">/* Define to 1 if you have the &lt;unistd.h&gt; header file. */</td></tr>
      <tr><td class="left">#define EVENT__HAVE_UNISTD_H 1</td><td> </td><td class="right">#define EVENT__HAVE_UNISTD_H 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if you have the `unsetenv' function. */</td><td> </td><td class="right">/* Define to 1 if you have the `unsetenv' function. */</td></tr>
      <tr><td class="left">#define EVENT__HAVE_UNSETENV 1</td><td> </td><td class="right">#define EVENT__HAVE_UNSETENV 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if you have the `usleep' function. */</td><td> </td><td class="right">/* Define to 1 if you have the `usleep' function. */</td></tr>
      <tr><td class="left">#define EVENT__HAVE_USLEEP 1</td><td> </td><td class="right">#define EVENT__HAVE_USLEEP 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0010"></tr>
      <tr><td class="lblock">/* Define <span class="delete">to 1</span> if <span class="delete">you have</span> the <span class="delete">`vasprintf' function.</span> */</td><td> </td><td class="rblock">/* Define if <span class="insert">your system supports</span> the <span class="insert">wepoll module */</span></td></tr>
      <tr><td class="lblock"><span class="delete">#define EVENT__HAVE_VASPRINTF 1</span></td><td> </td><td class="rblock"><span class="insert">/* #undef EVENT__HAVE_WEPOLL</span> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define if kqueue works correctly with pipes */</td><td> </td><td class="right">/* Define if kqueue works correctly with pipes */</td></tr>
      <tr><td class="left">/* #undef EVENT__HAVE_WORKING_KQUEUE */</td><td> </td><td class="right">/* #undef EVENT__HAVE_WORKING_KQUEUE */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if you have the &lt;zlib.h&gt; header file. */</td><td> </td><td class="right">/* Define to 1 if you have the &lt;zlib.h&gt; header file. */</td></tr>
      <tr><td class="left">#define EVENT__HAVE_ZLIB_H 1</td><td> </td><td class="right">#define EVENT__HAVE_ZLIB_H 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if you have the `_gmtime64' function. */</td><td> </td><td class="right">/* Define to 1 if you have the `_gmtime64' function. */</td></tr>
      <tr><td class="left">/* #undef EVENT__HAVE__GMTIME64 */</td><td> </td><td class="right">/* #undef EVENT__HAVE__GMTIME64 */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-9" class="change" ><th><small>skipping to change at</small><a href="#part-9"><em> line 443<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-9"><em> line 467<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">/* Define to 1 if compiler have __FUNCTION__ */</td><td> </td><td class="right">/* Define to 1 if compiler have __FUNCTION__ */</td></tr>
      <tr><td class="left">#define EVENT__HAVE___FUNCTION__ 1</td><td> </td><td class="right">#define EVENT__HAVE___FUNCTION__ 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if compiler have __func__ */</td><td> </td><td class="right">/* Define to 1 if compiler have __func__ */</td></tr>
      <tr><td class="left">#define EVENT__HAVE___func__ 1</td><td> </td><td class="right">#define EVENT__HAVE___func__ 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to the sub-directory where libtool stores uninstalled libraries. 
*/</td><td> </td><td class="right">/* Define to the sub-directory where libtool stores uninstalled libraries. 
*/</td></tr>
      <tr><td class="left">#define EVENT__LT_OBJDIR ".libs/"</td><td> </td><td class="right">#define EVENT__LT_OBJDIR ".libs/"</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Numeric representation of the version */</td><td> </td><td class="right">/* Numeric representation of the version */</td></tr>
      <tr id="diff0011"></tr>
      <tr><td class="lblock">#define EVENT__NUMERIC_VERSION 0x020<span class="delete">10c00</span></td><td> </td><td class="rblock">#define EVENT__NUMERIC_VERSION 0x020<span class="insert">20001</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Name of package */</td><td> </td><td class="right">/* Name of package */</td></tr>
      <tr><td class="left">#define EVENT__PACKAGE "libevent"</td><td> </td><td class="right">#define EVENT__PACKAGE "libevent"</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to the address where bug reports for this package should be sent.
 */</td><td> </td><td class="right">/* Define to the address where bug reports for this package should be sent.
 */</td></tr>
      <tr><td class="left">#define EVENT__PACKAGE_BUGREPORT ""</td><td> </td><td class="right">#define EVENT__PACKAGE_BUGREPORT ""</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to the full name of this package. */</td><td> </td><td class="right">/* Define to the full name of this package. */</td></tr>
      <tr><td class="left">#define EVENT__PACKAGE_NAME "libevent"</td><td> </td><td class="right">#define EVENT__PACKAGE_NAME "libevent"</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to the full name and version of this package. */</td><td> </td><td class="right">/* Define to the full name and version of this package. */</td></tr>
      <tr id="diff0012"></tr>
      <tr><td class="lblock">#define EVENT__PACKAGE_STRING "libevent 2.<span class="delete">1.12-stable</span>"</td><td> </td><td class="rblock">#define EVENT__PACKAGE_STRING "libevent 2.<span class="insert">2.0-alpha-dev</span>"</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to the one symbol short name of this package. */</td><td> </td><td class="right">/* Define to the one symbol short name of this package. */</td></tr>
      <tr><td class="left">#define EVENT__PACKAGE_TARNAME "libevent"</td><td> </td><td class="right">#define EVENT__PACKAGE_TARNAME "libevent"</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to the home page for this package. */</td><td> </td><td class="right">/* Define to the home page for this package. */</td></tr>
      <tr><td class="left">#define EVENT__PACKAGE_URL ""</td><td> </td><td class="right">#define EVENT__PACKAGE_URL ""</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to the version of this package. */</td><td> </td><td class="right">/* Define to the version of this package. */</td></tr>
      <tr id="diff0013"></tr>
      <tr><td class="lblock">#define EVENT__PACKAGE_VERSION "2.<span class="delete">1.12-stable</span>"</td><td> </td><td class="rblock">#define EVENT__PACKAGE_VERSION "2.<span class="insert">2.0-alpha-dev</span>"</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to necessary symbol if this constant uses a non-standard name on</td><td> </td><td class="right">/* Define to necessary symbol if this constant uses a non-standard name on</td></tr>
      <tr><td class="left">   your system. */</td><td> </td><td class="right">   your system. */</td></tr>
      <tr><td class="left">/* #undef EVENT__PTHREAD_CREATE_JOINABLE */</td><td> </td><td class="right">/* #undef EVENT__PTHREAD_CREATE_JOINABLE */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* The size of `int', as computed by sizeof. */</td><td> </td><td class="right">/* The size of `int', as computed by sizeof. */</td></tr>
      <tr><td class="left">#define EVENT__SIZEOF_INT 4</td><td> </td><td class="right">#define EVENT__SIZEOF_INT 4</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* The size of `long', as computed by sizeof. */</td><td> </td><td class="right">/* The size of `long', as computed by sizeof. */</td></tr>
      <tr><td class="left">#define EVENT__SIZEOF_LONG 8</td><td> </td><td class="right">#define EVENT__SIZEOF_LONG 8</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-10" class="change" ><th><small>skipping to change at</small><a href="#part-10"><em> line 500<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-10"><em> line 524<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* The size of `time_t', as computed by sizeof. */</td><td> </td><td class="right">/* The size of `time_t', as computed by sizeof. */</td></tr>
      <tr><td class="left">#define EVENT__SIZEOF_TIME_T 8</td><td> </td><td class="right">#define EVENT__SIZEOF_TIME_T 8</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* The size of `void *', as computed by sizeof. */</td><td> </td><td class="right">/* The size of `void *', as computed by sizeof. */</td></tr>
      <tr><td class="left">#define EVENT__SIZEOF_VOID_P 8</td><td> </td><td class="right">#define EVENT__SIZEOF_VOID_P 8</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if you have the ANSI C header files. */</td><td> </td><td class="right">/* Define to 1 if you have the ANSI C header files. */</td></tr>
      <tr><td class="left">#define STDC_HEADERS 1</td><td> </td><td class="right">#define STDC_HEADERS 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0014"></tr>
      <tr><td class="lblock"><span class="delete">/* Define to 1 if you can safely include both &lt;sys/time.h&gt; and &lt;time.h&gt;. */</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">#define EVENT__TIME_WITH_SYS_TIME 1</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock">                                                                           </td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left">/* Enable extensions on AIX 3, Interix.  */</td><td> </td><td class="right">/* Enable extensions on AIX 3, Interix.  */</td></tr>
      <tr><td class="left">#ifndef _ALL_SOURCE</td><td> </td><td class="right">#ifndef _ALL_SOURCE</td></tr>
      <tr><td class="left"># define _ALL_SOURCE 1</td><td> </td><td class="right"># define _ALL_SOURCE 1</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left">/* Enable GNU extensions on systems that have them.  */</td><td> </td><td class="right">/* Enable GNU extensions on systems that have them.  */</td></tr>
      <tr><td class="left">#ifndef _GNU_SOURCE</td><td> </td><td class="right">#ifndef _GNU_SOURCE</td></tr>
      <tr><td class="left"># define _GNU_SOURCE 1</td><td> </td><td class="right"># define _GNU_SOURCE 1</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left">/* Enable threading extensions on Solaris.  */</td><td> </td><td class="right">/* Enable threading extensions on Solaris.  */</td></tr>
      <tr><td class="left">#ifndef _POSIX_PTHREAD_SEMANTICS</td><td> </td><td class="right">#ifndef _POSIX_PTHREAD_SEMANTICS</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-11" class="change" ><th><small>skipping to change at</small><a href="#part-11"><em> line 525<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-11"><em> line 546<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">/* Enable extensions on HP NonStop.  */</td><td> </td><td class="right">/* Enable extensions on HP NonStop.  */</td></tr>
      <tr><td class="left">#ifndef _TANDEM_SOURCE</td><td> </td><td class="right">#ifndef _TANDEM_SOURCE</td></tr>
      <tr><td class="left"># define _TANDEM_SOURCE 1</td><td> </td><td class="right"># define _TANDEM_SOURCE 1</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left">/* Enable general extensions on Solaris.  */</td><td> </td><td class="right">/* Enable general extensions on Solaris.  */</td></tr>
      <tr><td class="left">#ifndef __EXTENSIONS__</td><td> </td><td class="right">#ifndef __EXTENSIONS__</td></tr>
      <tr><td class="left"># define __EXTENSIONS__ 1</td><td> </td><td class="right"># define __EXTENSIONS__ 1</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Version number of package */</td><td> </td><td class="right">/* Version number of package */</td></tr>
      <tr id="diff0015"></tr>
      <tr><td class="lblock">#define EVENT__VERSION <span class="delete">"2.1.12-stable"</span></td><td> </td><td class="rblock">#define EVENT__VERSION <span class="insert">"2.2.0-alpha-dev"</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   significant byte first (like Motorola and SPARC, unlike Intel). */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#if defined AC_APPLE_UNIVERSAL_BUILD</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"># if defined __BIG_ENDIAN__</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#  define EVENT__WORDS_BIGENDIAN 1</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"># endif</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#else</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"># ifndef EVENT__nORDS_BIGENDIAN</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* #  undef EVENT__WORDS_BIGENDIAN */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"># endif</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#endif</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Enable large inode numbers on Mac OS X 10.5.  */</td><td> </td><td class="right">/* Enable large inode numbers on Mac OS X 10.5.  */</td></tr>
      <tr><td class="left">#ifndef _DARWIN_USE_64_BIT_INODE</td><td> </td><td class="right">#ifndef _DARWIN_USE_64_BIT_INODE</td></tr>
      <tr><td class="left"># define _DARWIN_USE_64_BIT_INODE 1</td><td> </td><td class="right"># define _DARWIN_USE_64_BIT_INODE 1</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Number of bits in a file offset, on hosts where this is settable. */</td><td> </td><td class="right">/* Number of bits in a file offset, on hosts where this is settable. */</td></tr>
      <tr><td class="left">/* #undef _FILE_OFFSET_BITS */</td><td> </td><td class="right">/* #undef _FILE_OFFSET_BITS */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define for large files, on AIX-style hosts. */</td><td> </td><td class="right">/* Define for large files, on AIX-style hosts. */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-12" class="change" ><th><small>skipping to change at</small><a href="#part-12"><em> line 548<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-12"><em> line 581<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">/* Define to 1 if on MINIX. */</td><td> </td><td class="right">/* Define to 1 if on MINIX. */</td></tr>
      <tr><td class="left">/* #undef _MINIX */</td><td> </td><td class="right">/* #undef _MINIX */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 2 if the system does not provide POSIX.1 features except with</td><td> </td><td class="right">/* Define to 2 if the system does not provide POSIX.1 features except with</td></tr>
      <tr><td class="left">   this defined. */</td><td> </td><td class="right">   this defined. */</td></tr>
      <tr><td class="left">/* #undef _POSIX_1_SOURCE */</td><td> </td><td class="right">/* #undef _POSIX_1_SOURCE */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to 1 if you need to in order for `stat' and other things to work.
 */</td><td> </td><td class="right">/* Define to 1 if you need to in order for `stat' and other things to work.
 */</td></tr>
      <tr><td class="left">/* #undef _POSIX_SOURCE */</td><td> </td><td class="right">/* #undef _POSIX_SOURCE */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0016"></tr>
      <tr><td class="lblock"><span class="delete">/* Define to empty if `const' does not conform to ANSI C. */</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">/* #undef const */</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock">                                                                           </td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left">/* Define to `__inline__' or `__inline' if that's what the C compiler</td><td> </td><td class="right">/* Define to `__inline__' or `__inline' if that's what the C compiler</td></tr>
      <tr><td class="left">   calls it, or to nothing if 'inline' is not supported under any name.  */</td><td> </td><td class="right">   calls it, or to nothing if 'inline' is not supported under any name.  */</td></tr>
      <tr><td class="left">#ifndef __cplusplus</td><td> </td><td class="right">#ifndef __cplusplus</td></tr>
      <tr><td class="left">/* #undef inline */</td><td> </td><td class="right">/* #undef inline */</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to `int' if &lt;sys/types.h&gt; does not define. */</td><td> </td><td class="right">/* Define to `int' if &lt;sys/types.h&gt; does not define. */</td></tr>
      <tr><td class="left">/* #undef pid_t */</td><td> </td><td class="right">/* #undef pid_t */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Define to `unsigned int' if &lt;sys/types.h&gt; does not define. */</td><td> </td><td class="right">/* Define to `unsigned int' if &lt;sys/types.h&gt; does not define. */</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr id="end" bgcolor="gray"><th colspan="5" align="center">&nbsp;End of changes. 16 change blocks.&nbsp;</th></tr>
     <tr class="stats"><th><i>17 lines changed or deleted</i></th><th><i> </i></th><th><i>47 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr id="part-1" bgcolor="orange"><th>&nbsp;event.h (2.1.12)&nbsp;</th><th> </th><th>&nbsp;event.h (current)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-1" class="change" ><th><small>skipping to change at</small><a href="#part-1"><em> line 177<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-1"><em> line 177<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  event2/dns.h</td><td> </td><td class="right">  event2/dns.h</td></tr>
      <tr><td class="left">  Asynchronous DNS resolution</td><td> </td><td class="right">  Asynchronous DNS resolution</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  event2/http.h</td><td> </td><td class="right">  event2/http.h</td></tr>
      <tr><td class="left">  An embedded libevent-based HTTP server</td><td> </td><td class="right">  An embedded libevent-based HTTP server</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  event2/rpc.h</td><td> </td><td class="right">  event2/rpc.h</td></tr>
      <tr><td class="left">  A framework for creating RPC servers and clients</td><td> </td><td class="right">  A framework for creating RPC servers and clients</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0001"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">  <span class="insert">event2/watch.h</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  "Prepare" and "check" watchers.</span></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @file event2/event.h</td><td> </td><td class="right">/** @file event2/event.h</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0002"></tr>
      <tr><td class="lblock">  <span class="delete">Core functions for waiting for and receiving events, and using event base
</span>s.</td><td> </td><td class="rblock">  <span class="insert">@brief Core functions for waiting for and receiving events, and using eve
nt base</span>s.</td></tr>
      <tr><td class="left">*/</td><td> </td><td class="right">*/</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#include &lt;event2/visibility.h&gt;</td><td> </td><td class="right">#include &lt;event2/visibility.h&gt;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">extern "C" {</td><td> </td><td class="right">extern "C" {</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#include &lt;event2/event-config.h&gt;</td><td> </td><td class="right">#include &lt;event2/event-config.h&gt;</td></tr>
      <tr><td class="left">#ifdef EVENT__HAVE_SYS_TYPES_H</td><td> </td><td class="right">#ifdef EVENT__HAVE_SYS_TYPES_H</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-2" class="change" ><th><small>skipping to change at</small><a href="#part-2"><em> line 223<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-2"><em> line 225<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> * @see event_base_new(), event_base_free(), event_base_loop(),</td><td> </td><td class="right"> * @see event_base_new(), event_base_free(), event_base_loop(),</td></tr>
      <tr><td class="left"> *    event_base_new_with_config()</td><td> </td><td class="right"> *    event_base_new_with_config()</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">struct event_base</td><td> </td><td class="right">struct event_base</td></tr>
      <tr><td class="left">#ifdef EVENT_IN_DOXYGEN_</td><td> </td><td class="right">#ifdef EVENT_IN_DOXYGEN_</td></tr>
      <tr><td class="left">{/*Empty body so that doxygen will generate documentation here.*/}</td><td> </td><td class="right">{/*Empty body so that doxygen will generate documentation here.*/}</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left">;</td><td> </td><td class="right">;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr id="diff0003"></tr>
      <tr><td class="lblock"> <span class="delete">* @struct event</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> * Structure to represent a single event.</td><td> </td><td class="right"> * Structure to represent a single event.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * An event can have some underlying condition it represents: a socket</td><td> </td><td class="right"> * An event can have some underlying condition it represents: a socket</td></tr>
      <tr><td class="left"> * becoming readable or writeable (or both), or a signal becoming raised.</td><td> </td><td class="right"> * becoming readable or writeable (or both), or a signal becoming raised.</td></tr>
      <tr><td class="left"> * (An event that represents no underlying condition is still useful: you</td><td> </td><td class="right"> * (An event that represents no underlying condition is still useful: you</td></tr>
      <tr><td class="left"> * can use one to implement a timer, or to communicate between threads.)</td><td> </td><td class="right"> * can use one to implement a timer, or to communicate between threads.)</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Generally, you can create events with event_new(), then make them</td><td> </td><td class="right"> * Generally, you can create events with event_new(), then make them</td></tr>
      <tr><td class="left"> * pending with event_add().  As your event_base runs, it will run the</td><td> </td><td class="right"> * pending with event_add().  As your event_base runs, it will run the</td></tr>
      <tr><td class="left"> * callbacks of an events whose conditions are triggered.  When you no</td><td> </td><td class="right"> * callbacks of an events whose conditions are triggered.  When you no</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-3" class="change" ><th><small>skipping to change at</small><a href="#part-3"><em> line 372<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-3"><em> line 372<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">  active, or until something calls event_base_loopbreak() or</td><td> </td><td class="right">  active, or until something calls event_base_loopbreak() or</td></tr>
      <tr><td class="left">  event_base_loopexit().</td><td> </td><td class="right">  event_base_loopexit().</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  @param base the event_base structure returned by event_base_new() or</td><td> </td><td class="right">  @param base the event_base structure returned by event_base_new() or</td></tr>
      <tr><td class="left">     event_base_new_with_config()</td><td> </td><td class="right">     event_base_new_with_config()</td></tr>
      <tr><td class="left">  @return 0 if successful, -1 if an error occurred, or 1 if we exited becau
se</td><td> </td><td class="right">  @return 0 if successful, -1 if an error occurred, or 1 if we exited becau
se</td></tr>
      <tr><td class="left">     no events were pending or active.</td><td> </td><td class="right">     no events were pending or active.</td></tr>
      <tr><td class="left">  @see event_base_loop()</td><td> </td><td class="right">  @see event_base_loop()</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr id="diff0004"></tr>
      <tr><td class="lblock">int event_base_dispatch(struct event_base *);</td><td> </td><td class="rblock">int event_base_dispatch(struct event_base *<span class="insert">base</span>);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> Get the kernel event notification mechanism used by Libevent.</td><td> </td><td class="right"> Get the kernel event notification mechanism used by Libevent.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left"> @param eb the event_base structure returned by event_base_new()</td><td> </td><td class="right"> @param eb the event_base structure returned by event_base_new()</td></tr>
      <tr><td class="left"> @return a string identifying the kernel event mechanism (kqueue, epoll, et
c.)</td><td> </td><td class="right"> @return a string identifying the kernel event mechanism (kqueue, epoll, et
c.)</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr id="diff0005"></tr>
      <tr><td class="lblock">const char *event_base_get_method(const struct event_base <span class="delete">*);</span></td><td> </td><td class="rblock">const char *event_base_get_method(const struct event_base <span class="insert">*eb);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> Get the kernel signal handling mechanism used by Libevent.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> @param eb the event_base structure returned by event_base_new()</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> @return a string identifying the kernel signal handling mechanism,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   which is "signal" for traditional UNIX signal handlers,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   "kqueue_signal" for kqueue(2)-based method on *BSD and macOS,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   and "signalfd_signal" for Linux-only signalfd(2)-based method.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">EVENT2_EXPORT_SYMBOL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">const char *event_base_get_signal_method(const struct event_base *eb);</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">   Gets all event notification mechanisms supported by Libevent.</td><td> </td><td class="right">   Gets all event notification mechanisms supported by Libevent.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   This functions returns the event mechanism in order preferred by</td><td> </td><td class="right">   This functions returns the event mechanism in order preferred by</td></tr>
      <tr><td class="left">   Libevent.  Note that this list will include all backends that</td><td> </td><td class="right">   Libevent.  Note that this list will include all backends that</td></tr>
      <tr><td class="left">   Libevent has compiled-in support for, and will not necessarily check</td><td> </td><td class="right">   Libevent has compiled-in support for, and will not necessarily check</td></tr>
      <tr><td class="left">   your OS to see whether it has the required resources.</td><td> </td><td class="right">   your OS to see whether it has the required resources.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   @return an array with pointers to the names of support methods.</td><td> </td><td class="right">   @return an array with pointers to the names of support methods.</td></tr>
      <tr><td class="left">     The end of the array is indicated by a NULL pointer.  If an</td><td> </td><td class="right">     The end of the array is indicated by a NULL pointer.  If an</td></tr>
      <tr><td class="left">     error is encountered NULL is returned.</td><td> </td><td class="right">     error is encountered NULL is returned.</td></tr>
      <tr><td class="left">*/</td><td> </td><td class="right">*/</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">const char **event_get_supported_methods(void);</td><td> </td><td class="right">const char **event_get_supported_methods(void);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0006"></tr>
      <tr><td class="lblock">/** Query the current monotonic time from <span class="delete">a </span>the timer for a struct</td><td> </td><td class="rblock">/** Query the current monotonic time from the timer for a struct</td></tr>
      <tr><td class="left"> * event_base.</td><td> </td><td class="right"> * event_base.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">int event_gettime_monotonic(struct event_base *base, struct timeval *tp);</td><td> </td><td class="right">int event_gettime_monotonic(struct event_base *base, struct timeval *tp);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">   @name event type flag</td><td> </td><td class="right">   @name event type flag</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   Flags to pass to event_base_get_num_events() to specify the kinds of eve
nts</td><td> </td><td class="right">   Flags to pass to event_base_get_num_events() to specify the kinds of eve
nts</td></tr>
      <tr><td class="left">   we want to aggregate counts for</td><td> </td><td class="right">   we want to aggregate counts for</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-4" class="change" ><th><small>skipping to change at</small><a href="#part-4"><em> line 440<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-4"><em> line 452<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">   future libevent versions.  The return value is an indication of the work</td><td> </td><td class="right">   future libevent versions.  The return value is an indication of the work</td></tr>
      <tr><td class="left">   load, but the user shouldn't rely on the exact value as this may change 
in</td><td> </td><td class="right">   load, but the user shouldn't rely on the exact value as this may change 
in</td></tr>
      <tr><td class="left">   the future.</td><td> </td><td class="right">   the future.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   @param eb the event_base structure returned by event_base_new()</td><td> </td><td class="right">   @param eb the event_base structure returned by event_base_new()</td></tr>
      <tr><td class="left">   @param flags a bitwise combination of the kinds of events to aggregate</td><td> </td><td class="right">   @param flags a bitwise combination of the kinds of events to aggregate</td></tr>
      <tr><td class="left">       counts for</td><td> </td><td class="right">       counts for</td></tr>
      <tr><td class="left">   @return the number of events specified in the flags</td><td> </td><td class="right">   @return the number of events specified in the flags</td></tr>
      <tr><td class="left">*/</td><td> </td><td class="right">*/</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr id="diff0007"></tr>
      <tr><td class="lblock">int event_base_get_num_events(struct event_base *<span class="delete">, unsigned int</span>);</td><td> </td><td class="rblock">int event_base_get_num_events(struct event_base *<span class="insert">eb, unsigned int flags</span>);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">  Get the maximum number of events in a given event_base as specified in th
e</td><td> </td><td class="right">  Get the maximum number of events in a given event_base as specified in th
e</td></tr>
      <tr><td class="left">  flags.</td><td> </td><td class="right">  flags.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  @param eb the event_base structure returned by event_base_new()</td><td> </td><td class="right">  @param eb the event_base structure returned by event_base_new()</td></tr>
      <tr><td class="left">  @param flags a bitwise combination of the kinds of events to aggregate</td><td> </td><td class="right">  @param flags a bitwise combination of the kinds of events to aggregate</td></tr>
      <tr><td class="left">         counts for</td><td> </td><td class="right">         counts for</td></tr>
      <tr><td class="left">  @param clear option used to reset the maximum count.</td><td> </td><td class="right">  @param clear option used to reset the maximum count.</td></tr>
      <tr><td class="left">  @return the number of events specified in the flags</td><td> </td><td class="right">  @return the number of events specified in the flags</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr id="diff0008"></tr>
      <tr><td class="lblock">int event_base_get_max_events(struct event_base *<span class="delete">, unsigned int, int</span>);</td><td> </td><td class="rblock">int event_base_get_max_events(struct event_base *<span class="insert">eb, unsigned int flags, in
t clear</span>);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">   Allocates a new event configuration object.</td><td> </td><td class="right">   Allocates a new event configuration object.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   The event configuration object can be used to change the behavior of</td><td> </td><td class="right">   The event configuration object can be used to change the behavior of</td></tr>
      <tr><td class="left">   an event base.</td><td> </td><td class="right">   an event base.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   @return an event_config object that can be used to store configuration, 
or</td><td> </td><td class="right">   @return an event_config object that can be used to store configuration, 
or</td></tr>
      <tr><td class="left">     NULL if an error is encountered.</td><td> </td><td class="right">     NULL if an error is encountered.</td></tr>
      <tr><td class="left">   @see event_base_new_with_config(), event_config_free(), event_config</td><td> </td><td class="right">   @see event_base_new_with_config(), event_config_free(), event_config</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-5" class="change" ><th><small>skipping to change at</small><a href="#part-5"><em> line 544<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-5"><em> line 556<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">       */</td><td> </td><td class="right">       */</td></tr>
      <tr><td class="left">       EVENT_BASE_FLAG_NOLOCK = 0x01,</td><td> </td><td class="right">       EVENT_BASE_FLAG_NOLOCK = 0x01,</td></tr>
      <tr><td class="left">       /** Do not check the EVENT_* environment variables when configuring</td><td> </td><td class="right">       /** Do not check the EVENT_* environment variables when configuring</td></tr>
      <tr><td class="left">           an event_base  */</td><td> </td><td class="right">           an event_base  */</td></tr>
      <tr><td class="left">       EVENT_BASE_FLAG_IGNORE_ENV = 0x02,</td><td> </td><td class="right">       EVENT_BASE_FLAG_IGNORE_ENV = 0x02,</td></tr>
      <tr><td class="left">       /** Windows only: enable the IOCP dispatcher at startup</td><td> </td><td class="right">       /** Windows only: enable the IOCP dispatcher at startup</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">           If this flag is set then bufferevent_socket_new() and</td><td> </td><td class="right">           If this flag is set then bufferevent_socket_new() and</td></tr>
      <tr><td class="left">           evconn_listener_new() will use IOCP-backed implementations</td><td> </td><td class="right">           evconn_listener_new() will use IOCP-backed implementations</td></tr>
      <tr><td class="left">           instead of the usual select-based one on Windows.</td><td> </td><td class="right">           instead of the usual select-based one on Windows.</td></tr>
      <tr id="diff0009"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">           <span class="insert">Note: it is experimental feature, and has some bugs.</span></td></tr>
      <tr><td class="left">        */</td><td> </td><td class="right">        */</td></tr>
      <tr><td class="left">       EVENT_BASE_FLAG_STARTUP_IOCP = 0x04,</td><td> </td><td class="right">       EVENT_BASE_FLAG_STARTUP_IOCP = 0x04,</td></tr>
      <tr><td class="left">       /** Instead of checking the current time every time the event loop i
s</td><td> </td><td class="right">       /** Instead of checking the current time every time the event loop i
s</td></tr>
      <tr><td class="left">           ready to run timeout callbacks, check after each timeout callbac
k.</td><td> </td><td class="right">           ready to run timeout callbacks, check after each timeout callbac
k.</td></tr>
      <tr><td class="left">        */</td><td> </td><td class="right">        */</td></tr>
      <tr><td class="left">       EVENT_BASE_FLAG_NO_CACHE_TIME = 0x08,</td><td> </td><td class="right">       EVENT_BASE_FLAG_NO_CACHE_TIME = 0x08,</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       /** If we are using the epoll backend, this flag says that it is</td><td> </td><td class="right">       /** If we are using the epoll backend, this flag says that it is</td></tr>
      <tr><td class="left">           safe to use Libevent's internal change-list code to batch up</td><td> </td><td class="right">           safe to use Libevent's internal change-list code to batch up</td></tr>
      <tr><td class="left">           adds and deletes in order to try to do as few syscalls as</td><td> </td><td class="right">           adds and deletes in order to try to do as few syscalls as</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-6" class="change" ><th><small>skipping to change at</small><a href="#part-6"><em> line 572<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-6"><em> line 586<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">           This flag has no effect if you wind up using a backend other tha
n</td><td> </td><td class="right">           This flag has no effect if you wind up using a backend other tha
n</td></tr>
      <tr><td class="left">           epoll.</td><td> </td><td class="right">           epoll.</td></tr>
      <tr><td class="left">        */</td><td> </td><td class="right">        */</td></tr>
      <tr><td class="left">       EVENT_BASE_FLAG_EPOLL_USE_CHANGELIST = 0x10,</td><td> </td><td class="right">       EVENT_BASE_FLAG_EPOLL_USE_CHANGELIST = 0x10,</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       /** Ordinarily, Libevent implements its time and timeout code using</td><td> </td><td class="right">       /** Ordinarily, Libevent implements its time and timeout code using</td></tr>
      <tr><td class="left">           the fastest monotonic timer that we have.  If this flag is set,</td><td> </td><td class="right">           the fastest monotonic timer that we have.  If this flag is set,</td></tr>
      <tr><td class="left">           however, we use less efficient more precise timer, assuming one 
is</td><td> </td><td class="right">           however, we use less efficient more precise timer, assuming one 
is</td></tr>
      <tr><td class="left">           present.</td><td> </td><td class="right">           present.</td></tr>
      <tr><td class="left">        */</td><td> </td><td class="right">        */</td></tr>
      <tr id="diff0010"></tr>
      <tr><td class="lblock">       EVENT_BASE_FLAG_PRECISE_TIMER = <span class="delete">0x20</span></td><td> </td><td class="rblock">       EVENT_BASE_FLAG_PRECISE_TIMER = <span class="insert">0x20,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** With EVENT_BASE_FLAG_PRECISE_TIMER,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">           epoll backend will use timerfd for more accurate timers, this wi</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ll</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">           allows to disable this.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">           That said that this is something in between lack of</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">           (CLOCK_MONOTONIC_COARSE) and enabled EVENT_BASE_FLAG_PRECISE_TIM</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ER</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">           (CLOCK_MONOTONIC + timerfd).</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">           This flag has no effect if you wind up using a backend other tha</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">n</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">           epoll and if you do not have EVENT_BASE_FLAG_PRECISE_TIMER enabl</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ed.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       EVENT_BASE_FLAG_EPOLL_DISALLOW_TIMERFD = 0x40,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Do not use signalfd(2) to handle signals even if supported.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       EVENT_BASE_FLAG_DISALLOW_SIGNALFD = 0x80,</span></td></tr>
      <tr><td class="left">};</td><td> </td><td class="right">};</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">   Return a bitmask of the features implemented by an event base.  This</td><td> </td><td class="right">   Return a bitmask of the features implemented by an event base.  This</td></tr>
      <tr><td class="left">   will be a bitwise OR of one or more of the values of</td><td> </td><td class="right">   will be a bitwise OR of one or more of the values of</td></tr>
      <tr><td class="left">   event_method_feature</td><td> </td><td class="right">   event_method_feature</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   @see event_method_feature</td><td> </td><td class="right">   @see event_method_feature</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-7" class="change" ><th><small>skipping to change at</small><a href="#part-7"><em> line 677<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-7"><em> line 708<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">  Use event_base_new_with_config() to initialize a new event base, taking</td><td> </td><td class="right">  Use event_base_new_with_config() to initialize a new event base, taking</td></tr>
      <tr><td class="left">  the specified configuration under consideration.  The configuration objec
t</td><td> </td><td class="right">  the specified configuration under consideration.  The configuration objec
t</td></tr>
      <tr><td class="left">  can currently be used to avoid certain event notification mechanisms.</td><td> </td><td class="right">  can currently be used to avoid certain event notification mechanisms.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  @param cfg the event configuration object</td><td> </td><td class="right">  @param cfg the event configuration object</td></tr>
      <tr><td class="left">  @return an initialized event_base that can be used to registering events,</td><td> </td><td class="right">  @return an initialized event_base that can be used to registering events,</td></tr>
      <tr><td class="left">     or NULL if no event base can be created with the requested event_confi
g.</td><td> </td><td class="right">     or NULL if no event base can be created with the requested event_confi
g.</td></tr>
      <tr><td class="left">  @see event_base_new(), event_base_free(), event_init(), event_assign()</td><td> </td><td class="right">  @see event_base_new(), event_base_free(), event_init(), event_assign()</td></tr>
      <tr><td class="left">*/</td><td> </td><td class="right">*/</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr id="diff0011"></tr>
      <tr><td class="lblock">struct event_base *event_base_new_with_config(const struct event_config *);</td><td> </td><td class="rblock">struct event_base *event_base_new_with_config(const struct event_config *<span class="insert">cf
g</span>);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">  Deallocate all memory associated with an event_base, and free the base.</td><td> </td><td class="right">  Deallocate all memory associated with an event_base, and free the base.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  Note that this function will not close any fds or free any memory passed</td><td> </td><td class="right">  Note that this function will not close any fds or free any memory passed</td></tr>
      <tr><td class="left">  to event_new as the argument to callback.</td><td> </td><td class="right">  to event_new as the argument to callback.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  If there are any pending finalizer callbacks, this function will invoke</td><td> </td><td class="right">  If there are any pending finalizer callbacks, this function will invoke</td></tr>
      <tr><td class="left">  them.</td><td> </td><td class="right">  them.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  @param eb an event_base to be freed</td><td> </td><td class="right">  @param eb an event_base to be freed</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr id="diff0012"></tr>
      <tr><td class="lblock">void event_base_free(struct event_base *);</td><td> </td><td class="rblock">void event_base_free(struct event_base *<span class="insert">eb</span>);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">   As event_base_free, but do not run finalizers.</td><td> </td><td class="right">   As event_base_free, but do not run finalizers.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">void event_base_free_nofinalize(struct event_base *);</td><td> </td><td class="right">void event_base_free_nofinalize(struct event_base *);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @name Log severities</td><td> </td><td class="right">/** @name Log severities</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">/**@{*/</td><td> </td><td class="right">/**@{*/</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-8" class="change" ><th><small>skipping to change at</small><a href="#part-8"><em> line 786<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-8"><em> line 817<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">  Associate a different event base with an event.</td><td> </td><td class="right">  Associate a different event base with an event.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  The event to be associated must not be currently active or pending.</td><td> </td><td class="right">  The event to be associated must not be currently active or pending.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  @param eb the event base</td><td> </td><td class="right">  @param eb the event base</td></tr>
      <tr><td class="left">  @param ev the event</td><td> </td><td class="right">  @param ev the event</td></tr>
      <tr><td class="left">  @return 0 on success, -1 on failure.</td><td> </td><td class="right">  @return 0 on success, -1 on failure.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr id="diff0013"></tr>
      <tr><td class="lblock">int event_base_set(struct event_base *<span class="delete">, struct event *</span>);</td><td> </td><td class="rblock">int event_base_set(struct event_base *<span class="insert">eb, struct event *ev</span>);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @name Loop flags</td><td> </td><td class="right">/** @name Loop flags</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">    These flags control the behavior of event_base_loop().</td><td> </td><td class="right">    These flags control the behavior of event_base_loop().</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">/**@{*/</td><td> </td><td class="right">/**@{*/</td></tr>
      <tr><td class="left">/** Block until we have an active event, then exit once all active events</td><td> </td><td class="right">/** Block until we have an active event, then exit once all active events</td></tr>
      <tr><td class="left"> * have had their callbacks run. */</td><td> </td><td class="right"> * have had their callbacks run. */</td></tr>
      <tr><td class="left">#define EVLOOP_ONCE    0x01</td><td> </td><td class="right">#define EVLOOP_ONCE    0x01</td></tr>
      <tr><td class="left">/** Do not block: see which events are ready now, run the callbacks</td><td> </td><td class="right">/** Do not block: see which events are ready now, run the callbacks</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-9" class="change" ><th><small>skipping to change at</small><a href="#part-9"><em> line 818<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-9"><em> line 849<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  This is a more flexible version of event_base_dispatch().</td><td> </td><td class="right">  This is a more flexible version of event_base_dispatch().</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  By default, this loop will run the event base until either there are no m
ore</td><td> </td><td class="right">  By default, this loop will run the event base until either there are no m
ore</td></tr>
      <tr><td class="left">  pending or active events, or until something calls event_base_loopbreak()
 or</td><td> </td><td class="right">  pending or active events, or until something calls event_base_loopbreak()
 or</td></tr>
      <tr><td class="left">  event_base_loopexit().  You can override this behavior with the 'flags'</td><td> </td><td class="right">  event_base_loopexit().  You can override this behavior with the 'flags'</td></tr>
      <tr><td class="left">  argument.</td><td> </td><td class="right">  argument.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  @param eb the event_base structure returned by event_base_new() or</td><td> </td><td class="right">  @param eb the event_base structure returned by event_base_new() or</td></tr>
      <tr><td class="left">     event_base_new_with_config()</td><td> </td><td class="right">     event_base_new_with_config()</td></tr>
      <tr id="diff0014"></tr>
      <tr><td class="lblock">  @param flags any combination of EVLOOP_ONCE | EVLOOP_NONBLOCK</td><td> </td><td class="rblock">  @param flags any combination of EVLOOP_ONCE | EVLOOP_NONBLOCK <span class="insert">|</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">     EVLOOP_NO_EXIT_ON_EMPTY</span></td></tr>
      <tr><td class="left">  @return 0 if successful, -1 if an error occurred, or 1 if we exited becau
se</td><td> </td><td class="right">  @return 0 if successful, -1 if an error occurred, or 1 if we exited becau
se</td></tr>
      <tr><td class="left">     no events were pending or active.</td><td> </td><td class="right">     no events were pending or active.</td></tr>
      <tr><td class="left">  @see event_base_loopexit(), event_base_dispatch(), EVLOOP_ONCE,</td><td> </td><td class="right">  @see event_base_loopexit(), event_base_dispatch(), EVLOOP_ONCE,</td></tr>
      <tr><td class="left">     EVLOOP_NONBLOCK</td><td> </td><td class="right">     EVLOOP_NONBLOCK</td></tr>
      <tr><td class="left">  */</td><td> </td><td class="right">  */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr id="diff0015"></tr>
      <tr><td class="lblock">int event_base_loop(struct event_base *<span class="delete">, int</span>);</td><td> </td><td class="rblock">int event_base_loop(struct event_base *<span class="insert">eb, int flags</span>);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">  Exit the event loop after the specified time</td><td> </td><td class="right">  Exit the event loop after the specified time</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  The next event_base_loop() iteration after the given timer expires will</td><td> </td><td class="right">  The next event_base_loop() iteration after the given timer expires will</td></tr>
      <tr><td class="left">  complete normally (handling all queued events) then exit without</td><td> </td><td class="right">  complete normally (handling all queued events) then exit without</td></tr>
      <tr><td class="left">  blocking for events again.</td><td> </td><td class="right">  blocking for events again.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  Subsequent invocations of event_base_loop() will proceed normally.</td><td> </td><td class="right">  Subsequent invocations of event_base_loop() will proceed normally.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  @param eb the event_base structure returned by event_init()</td><td> </td><td class="right">  @param eb the event_base structure returned by event_init()</td></tr>
      <tr><td class="left">  @param tv the amount of time after which the loop should terminate,</td><td> </td><td class="right">  @param tv the amount of time after which the loop should terminate,</td></tr>
      <tr><td class="left">    or NULL to exit after running all currently active events.</td><td> </td><td class="right">    or NULL to exit after running all currently active events.</td></tr>
      <tr><td class="left">  @return 0 if successful, or -1 if an error occurred</td><td> </td><td class="right">  @return 0 if successful, or -1 if an error occurred</td></tr>
      <tr><td class="left">  @see event_base_loopbreak()</td><td> </td><td class="right">  @see event_base_loopbreak()</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr id="diff0016"></tr>
      <tr><td class="lblock">int event_base_loopexit(struct event_base *<span class="delete">, const struct timeval *</span>);</td><td> </td><td class="rblock">int event_base_loopexit(struct event_base *<span class="insert">eb, const struct timeval *tv</span>);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">  Abort the active event_base_loop() immediately.</td><td> </td><td class="right">  Abort the active event_base_loop() immediately.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  event_base_loop() will abort the loop after the next event is completed;</td><td> </td><td class="right">  event_base_loop() will abort the loop after the next event is completed;</td></tr>
      <tr><td class="left">  event_base_loopbreak() is typically invoked from this event's callback.</td><td> </td><td class="right">  event_base_loopbreak() is typically invoked from this event's callback.</td></tr>
      <tr><td class="left">  This behavior is analogous to the "break;" statement.</td><td> </td><td class="right">  This behavior is analogous to the "break;" statement.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  Subsequent invocations of event_base_loop() will proceed normally.</td><td> </td><td class="right">  Subsequent invocations of event_base_loop() will proceed normally.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  @param eb the event_base structure returned by event_init()</td><td> </td><td class="right">  @param eb the event_base structure returned by event_init()</td></tr>
      <tr><td class="left">  @return 0 if successful, or -1 if an error occurred</td><td> </td><td class="right">  @return 0 if successful, or -1 if an error occurred</td></tr>
      <tr><td class="left">  @see event_base_loopexit()</td><td> </td><td class="right">  @see event_base_loopexit()</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr id="diff0017"></tr>
      <tr><td class="lblock">int event_base_loopbreak(struct event_base *);</td><td> </td><td class="rblock">int event_base_loopbreak(struct event_base *<span class="insert">eb</span>);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">  Tell the active event_base_loop() to scan for new events immediately.</td><td> </td><td class="right">  Tell the active event_base_loop() to scan for new events immediately.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  Calling this function makes the currently active event_base_loop()</td><td> </td><td class="right">  Calling this function makes the currently active event_base_loop()</td></tr>
      <tr><td class="left">  start the loop over again (scanning for new events) after the current</td><td> </td><td class="right">  start the loop over again (scanning for new events) after the current</td></tr>
      <tr><td class="left">  event callback finishes.  If the event loop is not running, this</td><td> </td><td class="right">  event callback finishes.  If the event loop is not running, this</td></tr>
      <tr><td class="left">  function has no effect.</td><td> </td><td class="right">  function has no effect.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  event_base_loopbreak() is typically invoked from this event's callback.</td><td> </td><td class="right">  event_base_loopbreak() is typically invoked from this event's callback.</td></tr>
      <tr><td class="left">  This behavior is analogous to the "continue;" statement.</td><td> </td><td class="right">  This behavior is analogous to the "continue;" statement.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  Subsequent invocations of event loop will proceed normally.</td><td> </td><td class="right">  Subsequent invocations of event loop will proceed normally.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  @param eb the event_base structure returned by event_init()</td><td> </td><td class="right">  @param eb the event_base structure returned by event_init()</td></tr>
      <tr><td class="left">  @return 0 if successful, or -1 if an error occurred</td><td> </td><td class="right">  @return 0 if successful, or -1 if an error occurred</td></tr>
      <tr><td class="left">  @see event_base_loopbreak()</td><td> </td><td class="right">  @see event_base_loopbreak()</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr id="diff0018"></tr>
      <tr><td class="lblock">int event_base_loopcontinue(struct event_base *);</td><td> </td><td class="rblock">int event_base_loopcontinue(struct event_base *<span class="insert">eb</span>);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">  Checks if the event loop was told to exit by event_base_loopexit().</td><td> </td><td class="right">  Checks if the event loop was told to exit by event_base_loopexit().</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  This function will return true for an event_base at every point after</td><td> </td><td class="right">  This function will return true for an event_base at every point after</td></tr>
      <tr><td class="left">  event_loopexit() is called, until the event loop is next entered.</td><td> </td><td class="right">  event_loopexit() is called, until the event loop is next entered.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  @param eb the event_base structure returned by event_init()</td><td> </td><td class="right">  @param eb the event_base structure returned by event_init()</td></tr>
      <tr><td class="left">  @return true if event_base_loopexit() was called on this event base,</td><td> </td><td class="right">  @return true if event_base_loopexit() was called on this event base,</td></tr>
      <tr><td class="left">    or 0 otherwise</td><td> </td><td class="right">    or 0 otherwise</td></tr>
      <tr><td class="left">  @see event_base_loopexit()</td><td> </td><td class="right">  @see event_base_loopexit()</td></tr>
      <tr><td class="left">  @see event_base_got_break()</td><td> </td><td class="right">  @see event_base_got_break()</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr id="diff0019"></tr>
      <tr><td class="lblock">int event_base_got_exit(struct event_base *);</td><td> </td><td class="rblock">int event_base_got_exit(struct event_base *<span class="insert">eb</span>);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">  Checks if the event loop was told to abort immediately by event_base_loop
break().</td><td> </td><td class="right">  Checks if the event loop was told to abort immediately by event_base_loop
break().</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  This function will return true for an event_base at every point after</td><td> </td><td class="right">  This function will return true for an event_base at every point after</td></tr>
      <tr><td class="left">  event_base_loopbreak() is called, until the event loop is next entered.</td><td> </td><td class="right">  event_base_loopbreak() is called, until the event loop is next entered.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  @param eb the event_base structure returned by event_init()</td><td> </td><td class="right">  @param eb the event_base structure returned by event_init()</td></tr>
      <tr><td class="left">  @return true if event_base_loopbreak() was called on this event base,</td><td> </td><td class="right">  @return true if event_base_loopbreak() was called on this event base,</td></tr>
      <tr><td class="left">    or 0 otherwise</td><td> </td><td class="right">    or 0 otherwise</td></tr>
      <tr><td class="left">  @see event_base_loopbreak()</td><td> </td><td class="right">  @see event_base_loopbreak()</td></tr>
      <tr><td class="left">  @see event_base_got_exit()</td><td> </td><td class="right">  @see event_base_got_exit()</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr id="diff0020"></tr>
      <tr><td class="lblock">int event_base_got_break(struct event_base *);</td><td> </td><td class="rblock">int event_base_got_break(struct event_base *<span class="insert">eb</span>);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * @name event flags</td><td> </td><td class="right"> * @name event flags</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Flags to pass to event_new(), event_assign(), event_pending(), and</td><td> </td><td class="right"> * Flags to pass to event_new(), event_assign(), event_pending(), and</td></tr>
      <tr><td class="left"> * anything else with an argument of the form "short events"</td><td> </td><td class="right"> * anything else with an argument of the form "short events"</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">/**@{*/</td><td> </td><td class="right">/**@{*/</td></tr>
      <tr><td class="left">/** Indicates that a timeout has occurred.  It's not necessary to pass</td><td> </td><td class="right">/** Indicates that a timeout has occurred.  It's not necessary to pass</td></tr>
      <tr><td class="left"> * this flag to event_for new()/event_assign() to get a timeout. */</td><td> </td><td class="right"> * this flag to event_for new()/event_assign() to get a timeout. */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-10" class="change" ><th><small>skipping to change at</small><a href="#part-10"><em> line 1067<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-10"><em> line 1099<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">  The EV_PERSIST flag can also be passed in the events argument: it makes</td><td> </td><td class="right">  The EV_PERSIST flag can also be passed in the events argument: it makes</td></tr>
      <tr><td class="left">  event_add() persistent until event_del() is called.</td><td> </td><td class="right">  event_add() persistent until event_del() is called.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  The EV_ET flag is compatible with EV_READ and EV_WRITE, and supported</td><td> </td><td class="right">  The EV_ET flag is compatible with EV_READ and EV_WRITE, and supported</td></tr>
      <tr><td class="left">  only by certain backends.  It tells Libevent to use edge-triggered</td><td> </td><td class="right">  only by certain backends.  It tells Libevent to use edge-triggered</td></tr>
      <tr><td class="left">  events.</td><td> </td><td class="right">  events.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  The EV_TIMEOUT flag has no effect here.</td><td> </td><td class="right">  The EV_TIMEOUT flag has no effect here.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  It is okay to have multiple events all listening on the same fds; but</td><td> </td><td class="right">  It is okay to have multiple events all listening on the same fds; but</td></tr>
      <tr id="diff0021"></tr>
      <tr><td class="lblock">  they must either all be edge-triggered, or <span class="delete">all not be edge triggered</span>.</td><td> </td><td class="rblock">  they must either all be edge-triggered, or <span class="insert">not be edge-triggered at all</span>.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  When the event becomes active, the event loop will run the provided</td><td> </td><td class="right">  When the event becomes active, the event loop will run the provided</td></tr>
      <tr><td class="left">  callback function, with three arguments.  The first will be the provided</td><td> </td><td class="right">  callback function, with three arguments.  The first will be the provided</td></tr>
      <tr><td class="left">  fd value.  The second will be a bitfield of the events that triggered:</td><td> </td><td class="right">  fd value.  The second will be a bitfield of the events that triggered:</td></tr>
      <tr><td class="left">  EV_READ, EV_WRITE, or EV_SIGNAL.  Here the EV_TIMEOUT flag indicates</td><td> </td><td class="right">  EV_READ, EV_WRITE, or EV_SIGNAL.  Here the EV_TIMEOUT flag indicates</td></tr>
      <tr><td class="left">  that a timeout occurred, and EV_ET indicates that an edge-triggered</td><td> </td><td class="right">  that a timeout occurred, and EV_ET indicates that an edge-triggered</td></tr>
      <tr><td class="left">  event occurred.  The third event will be the callback_arg pointer that</td><td> </td><td class="right">  event occurred.  The third event will be the callback_arg pointer that</td></tr>
      <tr><td class="left">  you provide.</td><td> </td><td class="right">  you provide.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  @param base the event base to which the event should be attached.</td><td> </td><td class="right">  @param base the event base to which the event should be attached.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-11" class="change" ><th><small>skipping to change at</small><a href="#part-11"><em> line 1089<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-11"><em> line 1121<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">  @param events desired events to monitor: bitfield of EV_READ, EV_WRITE,</td><td> </td><td class="right">  @param events desired events to monitor: bitfield of EV_READ, EV_WRITE,</td></tr>
      <tr><td class="left">      EV_SIGNAL, EV_PERSIST, EV_ET.</td><td> </td><td class="right">      EV_SIGNAL, EV_PERSIST, EV_ET.</td></tr>
      <tr><td class="left">  @param callback callback function to be invoked when the event occurs</td><td> </td><td class="right">  @param callback callback function to be invoked when the event occurs</td></tr>
      <tr><td class="left">  @param callback_arg an argument to be passed to the callback function</td><td> </td><td class="right">  @param callback_arg an argument to be passed to the callback function</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  @return a newly allocated struct event that must later be freed with</td><td> </td><td class="right">  @return a newly allocated struct event that must later be freed with</td></tr>
      <tr><td class="left">    event_free() or NULL if an error occurred.</td><td> </td><td class="right">    event_free() or NULL if an error occurred.</td></tr>
      <tr><td class="left">  @see event_free(), event_add(), event_del(), event_assign()</td><td> </td><td class="right">  @see event_free(), event_add(), event_del(), event_assign()</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr id="diff0022"></tr>
      <tr><td class="lblock">struct event *event_new(struct event_base *<span class="delete">, evutil_socket_t, short, event_
callback_fn, void *</span>);</td><td> </td><td class="rblock">struct event *event_new(struct event_base *<span class="insert">base, evutil_socket_t fd, short 
events, event_callback_fn callback, void *callback_arg</span>);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">  Prepare a new, already-allocated event structure to be added.</td><td> </td><td class="right">  Prepare a new, already-allocated event structure to be added.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  The function event_assign() prepares the event structure ev to be used</td><td> </td><td class="right">  The function event_assign() prepares the event structure ev to be used</td></tr>
      <tr><td class="left">  in future calls to event_add() and event_del().  Unlike event_new(), it</td><td> </td><td class="right">  in future calls to event_add() and event_del().  Unlike event_new(), it</td></tr>
      <tr><td class="left">  doesn't allocate memory itself: it requires that you have already</td><td> </td><td class="right">  doesn't allocate memory itself: it requires that you have already</td></tr>
      <tr><td class="left">  allocated a struct event, probably on the heap.  Doing this will</td><td> </td><td class="right">  allocated a struct event, probably on the heap.  Doing this will</td></tr>
      <tr><td class="left">  typically make your code depend on the size of the event structure, and</td><td> </td><td class="right">  typically make your code depend on the size of the event structure, and</td></tr>
      <tr><td class="left">  thereby create incompatibility with future versions of Libevent.</td><td> </td><td class="right">  thereby create incompatibility with future versions of Libevent.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-12" class="change" ><th><small>skipping to change at</small><a href="#part-12"><em> line 1130<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-12"><em> line 1162<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">  @param events desired events to monitor; can be EV_READ and/or EV_WRITE</td><td> </td><td class="right">  @param events desired events to monitor; can be EV_READ and/or EV_WRITE</td></tr>
      <tr><td class="left">  @param callback callback function to be invoked when the event occurs</td><td> </td><td class="right">  @param callback callback function to be invoked when the event occurs</td></tr>
      <tr><td class="left">  @param callback_arg an argument to be passed to the callback function</td><td> </td><td class="right">  @param callback_arg an argument to be passed to the callback function</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  @return 0 if success, or -1 on invalid arguments.</td><td> </td><td class="right">  @return 0 if success, or -1 on invalid arguments.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  @see event_new(), event_add(), event_del(), event_base_once(),</td><td> </td><td class="right">  @see event_new(), event_add(), event_del(), event_base_once(),</td></tr>
      <tr><td class="left">    event_get_struct_event_size()</td><td> </td><td class="right">    event_get_struct_event_size()</td></tr>
      <tr><td class="left">  */</td><td> </td><td class="right">  */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr id="diff0023"></tr>
      <tr><td class="lblock">int event_assign(struct event *<span class="delete">, struct event_base *, evutil_socket_t, shor
t, event_callback_fn, void *</span>);</td><td> </td><td class="rblock">int event_assign(struct event *<span class="insert">ev, struct event_base *base, evutil_socket_t
 fd, short events, event_callback_fn callback, void *callback_arg</span>);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">   Deallocate a struct event * returned by event_new().</td><td> </td><td class="right">   Deallocate a struct event * returned by event_new().</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   If the event is pending or active, this function makes it non-pending</td><td> </td><td class="right">   If the event is pending or active, this function makes it non-pending</td></tr>
      <tr><td class="left">   and non-active first.</td><td> </td><td class="right">   and non-active first.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">void event_free(struct event *);</td><td> </td><td class="right">void event_free(struct event *);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-13" class="change" ><th><small>skipping to change at</small><a href="#part-13"><em> line 1207<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-13"><em> line 1239<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">  @param events event(s) to monitor; can be any of EV_READ |</td><td> </td><td class="right">  @param events event(s) to monitor; can be any of EV_READ |</td></tr>
      <tr><td class="left">         EV_WRITE, or EV_TIMEOUT</td><td> </td><td class="right">         EV_WRITE, or EV_TIMEOUT</td></tr>
      <tr><td class="left">  @param callback callback function to be invoked when the event occurs</td><td> </td><td class="right">  @param callback callback function to be invoked when the event occurs</td></tr>
      <tr><td class="left">  @param arg an argument to be passed to the callback function</td><td> </td><td class="right">  @param arg an argument to be passed to the callback function</td></tr>
      <tr><td class="left">  @param timeout the maximum amount of time to wait for the event. NULL</td><td> </td><td class="right">  @param timeout the maximum amount of time to wait for the event. NULL</td></tr>
      <tr><td class="left">         makes an EV_READ/EV_WRITE event make forever; NULL makes an</td><td> </td><td class="right">         makes an EV_READ/EV_WRITE event make forever; NULL makes an</td></tr>
      <tr><td class="left">        EV_TIMEOUT event success immediately.</td><td> </td><td class="right">        EV_TIMEOUT event success immediately.</td></tr>
      <tr><td class="left">  @return 0 if successful, or -1 if an error occurred</td><td> </td><td class="right">  @return 0 if successful, or -1 if an error occurred</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr id="diff0024"></tr>
      <tr><td class="lblock">int event_base_once(struct event_base *<span class="delete">, evutil_socket_t, short, event_call
back_fn, void *, const struct timeval *</span>);</td><td> </td><td class="rblock">int event_base_once(struct event_base *<span class="insert">base, evutil_socket_t fd, short even
ts, event_callback_fn callback, void *arg, const struct timeval *timeout</span>);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">  Add an event to the set of pending events.</td><td> </td><td class="right">  Add an event to the set of pending events.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  The function event_add() schedules the execution of the event 'ev' when t
he</td><td> </td><td class="right">  The function event_add() schedules the execution of the event 'ev' when t
he</td></tr>
      <tr><td class="left">  condition specified by event_assign() or event_new() occurs, or when the 
time</td><td> </td><td class="right">  condition specified by event_assign() or event_new() occurs, or when the 
time</td></tr>
      <tr><td class="left">  specified in timeout has elapsed.  If a timeout is NULL, no timeout</td><td> </td><td class="right">  specified in timeout has elapsed.  If a timeout is NULL, no timeout</td></tr>
      <tr><td class="left">  occurs and the function will only be</td><td> </td><td class="right">  occurs and the function will only be</td></tr>
      <tr><td class="left">  called if a matching event occurs.  The event in the</td><td> </td><td class="right">  called if a matching event occurs.  The event in the</td></tr>
      <tr><td class="left">  ev argument must be already initialized by event_assign() or event_new()</td><td> </td><td class="right">  ev argument must be already initialized by event_assign() or event_new()</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-14" class="change" ><th><small>skipping to change at</small><a href="#part-14"><em> line 1257<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-14"><em> line 1289<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  The function event_del() will cancel the event in the argument ev.  If th
e</td><td> </td><td class="right">  The function event_del() will cancel the event in the argument ev.  If th
e</td></tr>
      <tr><td class="left">  event has already executed or has never been added the call will have no</td><td> </td><td class="right">  event has already executed or has never been added the call will have no</td></tr>
      <tr><td class="left">  effect.</td><td> </td><td class="right">  effect.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  @param ev an event struct to be removed from the working set</td><td> </td><td class="right">  @param ev an event struct to be removed from the working set</td></tr>
      <tr><td class="left">  @return 0 if successful, or -1 if an error occurred</td><td> </td><td class="right">  @return 0 if successful, or -1 if an error occurred</td></tr>
      <tr><td class="left">  @see event_add()</td><td> </td><td class="right">  @see event_add()</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr id="diff0025"></tr>
      <tr><td class="lblock">int event_del(struct event *);</td><td> </td><td class="rblock">int event_del(struct event *<span class="insert">ev</span>);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">   As event_del(), but never blocks while the event's callback is running</td><td> </td><td class="right">   As event_del(), but never blocks while the event's callback is running</td></tr>
      <tr><td class="left">   in another thread, even if the event was constructed without the</td><td> </td><td class="right">   in another thread, even if the event was constructed without the</td></tr>
      <tr><td class="left">   EV_FINALIZE flag.</td><td> </td><td class="right">   EV_FINALIZE flag.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">int event_del_noblock(struct event *ev);</td><td> </td><td class="right">int event_del_noblock(struct event *ev);</td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">   As event_del(), but always blocks while the event's callback is running</td><td> </td><td class="right">   As event_del(), but always blocks while the event's callback is running</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-15" class="change" ><th><small>skipping to change at</small><a href="#part-15"><em> line 1467<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-15"><em> line 1499<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">  events again, before running less-urgent events.  Less-urgent events</td><td> </td><td class="right">  events again, before running less-urgent events.  Less-urgent events</td></tr>
      <tr><td class="left">  will not have their callbacks run until there are no events more urgent</td><td> </td><td class="right">  will not have their callbacks run until there are no events more urgent</td></tr>
      <tr><td class="left">  than them that want to be active.</td><td> </td><td class="right">  than them that want to be active.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  @param eb the event_base structure returned by event_base_new()</td><td> </td><td class="right">  @param eb the event_base structure returned by event_base_new()</td></tr>
      <tr><td class="left">  @param npriorities the maximum number of priorities</td><td> </td><td class="right">  @param npriorities the maximum number of priorities</td></tr>
      <tr><td class="left">  @return 0 if successful, or -1 if an error occurred</td><td> </td><td class="right">  @return 0 if successful, or -1 if an error occurred</td></tr>
      <tr><td class="left">  @see event_priority_set()</td><td> </td><td class="right">  @see event_priority_set()</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr id="diff0026"></tr>
      <tr><td class="lblock">int    event_base_priority_init(struct event_base *<span class="delete">, int</span>);</td><td> </td><td class="rblock">int    event_base_priority_init(struct event_base *<span class="insert">eb, int npriorities</span>);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">  Get the number of different event priorities.</td><td> </td><td class="right">  Get the number of different event priorities.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  @param eb the event_base structure returned by event_base_new()</td><td> </td><td class="right">  @param eb the event_base structure returned by event_base_new()</td></tr>
      <tr><td class="left">  @return Number of different event priorities</td><td> </td><td class="right">  @return Number of different event priorities</td></tr>
      <tr><td class="left">  @see event_base_priority_init()</td><td> </td><td class="right">  @see event_base_priority_init()</td></tr>
      <tr><td class="left">*/</td><td> </td><td class="right">*/</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">int    event_base_get_npriorities(struct event_base *eb);</td><td> </td><td class="right">int    event_base_get_npriorities(struct event_base *eb);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">  Assign a priority to an event.</td><td> </td><td class="right">  Assign a priority to an event.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  @param ev an event struct</td><td> </td><td class="right">  @param ev an event struct</td></tr>
      <tr><td class="left">  @param priority the new priority to be assigned</td><td> </td><td class="right">  @param priority the new priority to be assigned</td></tr>
      <tr><td class="left">  @return 0 if successful, or -1 if an error occurred</td><td> </td><td class="right">  @return 0 if successful, or -1 if an error occurred</td></tr>
      <tr><td class="left">  @see event_priority_init(), event_get_priority()</td><td> </td><td class="right">  @see event_priority_init(), event_get_priority()</td></tr>
      <tr><td class="left">  */</td><td> </td><td class="right">  */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr id="diff0027"></tr>
      <tr><td class="lblock">int    event_priority_set(struct event *<span class="delete">, int</span>);</td><td> </td><td class="rblock">int    event_priority_set(struct event *<span class="insert">ev, int priority</span>);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">   Prepare an event_base to use a large number of timeouts with the same</td><td> </td><td class="right">   Prepare an event_base to use a large number of timeouts with the same</td></tr>
      <tr><td class="left">   duration.</td><td> </td><td class="right">   duration.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   Libevent's default scheduling algorithm is optimized for having a large</td><td> </td><td class="right">   Libevent's default scheduling algorithm is optimized for having a large</td></tr>
      <tr><td class="left">   number of timeouts with their durations more or less randomly</td><td> </td><td class="right">   number of timeouts with their durations more or less randomly</td></tr>
      <tr><td class="left">   distributed.  But if you have a large number of timeouts that all have</td><td> </td><td class="right">   distributed.  But if you have a large number of timeouts that all have</td></tr>
      <tr><td class="left">   the same duration (for example, if you have a large number of</td><td> </td><td class="right">   the same duration (for example, if you have a large number of</td></tr>
      <tr><td class="left">   connections that all have a 10-second timeout), then you can improve</td><td> </td><td class="right">   connections that all have a 10-second timeout), then you can improve</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-16" class="change" ><th><small>skipping to change at</small><a href="#part-16"><em> line 1557<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-16"><em> line 1589<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">   Writes a human-readable description of all inserted and/or active</td><td> </td><td class="right">   Writes a human-readable description of all inserted and/or active</td></tr>
      <tr><td class="left">   events to a provided stdio stream.</td><td> </td><td class="right">   events to a provided stdio stream.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   This is intended for debugging; its format is not guaranteed to be the s
ame</td><td> </td><td class="right">   This is intended for debugging; its format is not guaranteed to be the s
ame</td></tr>
      <tr><td class="left">   between libevent versions.</td><td> </td><td class="right">   between libevent versions.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   @param base An event_base on which to scan the events.</td><td> </td><td class="right">   @param base An event_base on which to scan the events.</td></tr>
      <tr><td class="left">   @param output A stdio file to write on.</td><td> </td><td class="right">   @param output A stdio file to write on.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr id="diff0028"></tr>
      <tr><td class="lblock">void event_base_dump_events(struct event_base *<span class="delete">, FILE *</span>);</td><td> </td><td class="rblock">void event_base_dump_events(struct event_base *<span class="insert">base, FILE *output</span>);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">   Activates all pending events for the given fd and event mask.</td><td> </td><td class="right">   Activates all pending events for the given fd and event mask.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   This function activates pending events only.  Events which have not been</td><td> </td><td class="right">   This function activates pending events only.  Events which have not been</td></tr>
      <tr><td class="left">   added will not become active.</td><td> </td><td class="right">   added will not become active.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   @param base the event_base on which to activate the events.</td><td> </td><td class="right">   @param base the event_base on which to activate the events.</td></tr>
      <tr><td class="left">   @param fd An fd to active events on.</td><td> </td><td class="right">   @param fd An fd to active events on.</td></tr>
      <tr><td class="left">   @param events One or more of EV_{READ,WRITE,TIMEOUT}.</td><td> </td><td class="right">   @param events One or more of EV_{READ,WRITE,TIMEOUT}.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-17" class="change" ><th><small>skipping to change at</small><a href="#part-17"><em> line 1579<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-17"><em> line 1611<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">void event_base_active_by_fd(struct event_base *base, evutil_socket_t fd, s
hort events);</td><td> </td><td class="right">void event_base_active_by_fd(struct event_base *base, evutil_socket_t fd, s
hort events);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">   Activates all pending signals with a given signal number</td><td> </td><td class="right">   Activates all pending signals with a given signal number</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   This function activates pending events only.  Events which have not been</td><td> </td><td class="right">   This function activates pending events only.  Events which have not been</td></tr>
      <tr><td class="left">   added will not become active.</td><td> </td><td class="right">   added will not become active.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   @param base the event_base on which to activate the events.</td><td> </td><td class="right">   @param base the event_base on which to activate the events.</td></tr>
      <tr id="diff0029"></tr>
      <tr><td class="lblock">   @param <span class="delete">fd</span> The signal to active events on.</td><td> </td><td class="rblock">   @param <span class="insert">sig</span> The signal to active events on.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">void event_base_active_by_signal(struct event_base *base, int sig);</td><td> </td><td class="right">void event_base_active_by_signal(struct event_base *base, int sig);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Callback for iterating events in an event base via event_base_foreach_ev
ent</td><td> </td><td class="right"> * Callback for iterating events in an event base via event_base_foreach_ev
ent</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef int (*event_base_foreach_event_cb)(const struct event_base *, const
 struct event *, void *);</td><td> </td><td class="right">typedef int (*event_base_foreach_event_cb)(const struct event_base *, const
 struct event *, void *);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr id="end" bgcolor="gray"><th colspan="5" align="center">&nbsp;End of changes. 29 change blocks.&nbsp;</th></tr>
     <tr class="stats"><th><i>28 lines changed or deleted</i></th><th><i> </i></th><th><i>64 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr id="part-1" bgcolor="orange"><th>&nbsp;event_compat.h (2.1.12)&nbsp;</th><th> </th><th>&nbsp;event_compat.h (current)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-1" class="change" ><th><small>skipping to change at</small><a href="#part-1"><em> line 32<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-1"><em> line 32<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</td><td> </td><td class="right"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</td></tr>
      <tr><td class="left"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</td><td> </td><td class="right"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</td></tr>
      <tr><td class="left"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</td><td> </td><td class="right"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</td></tr>
      <tr><td class="left"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</td><td> </td><td class="right"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#ifndef EVENT2_EVENT_COMPAT_H_INCLUDED_</td><td> </td><td class="right">#ifndef EVENT2_EVENT_COMPAT_H_INCLUDED_</td></tr>
      <tr><td class="left">#define EVENT2_EVENT_COMPAT_H_INCLUDED_</td><td> </td><td class="right">#define EVENT2_EVENT_COMPAT_H_INCLUDED_</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @file event2/event_compat.h</td><td> </td><td class="right">/** @file event2/event_compat.h</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0001"></tr>
      <tr><td class="lblock">  <span class="delete">Potentially non-threadsafe versions of the functions in event.h: p</span>rovided</td><td> </td><td class="rblock">  <span class="insert">@brief Potentially non-threadsafe versions of the functions in event.h: p
</span>rovided</td></tr>
      <tr><td class="left">  only for backwards compatibility.</td><td> </td><td class="right">  only for backwards compatibility.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  In the oldest versions of Libevent, event_base was not a first-class</td><td> </td><td class="right">  In the oldest versions of Libevent, event_base was not a first-class</td></tr>
      <tr><td class="left">  structure.  Instead, there was a single event base that every function</td><td> </td><td class="right">  structure.  Instead, there was a single event base that every function</td></tr>
      <tr><td class="left">  manipulated.  Later, when separate event bases were added, the old functi
ons</td><td> </td><td class="right">  manipulated.  Later, when separate event bases were added, the old functi
ons</td></tr>
      <tr><td class="left">  that didn't take an event_base argument needed to work by manipulating th
e</td><td> </td><td class="right">  that didn't take an event_base argument needed to work by manipulating th
e</td></tr>
      <tr><td class="left">  "current" event base.  This could lead to thread-safety issues, and obscu
re,</td><td> </td><td class="right">  "current" event base.  This could lead to thread-safety issues, and obscu
re,</td></tr>
      <tr><td class="left">  hard-to-diagnose bugs.</td><td> </td><td class="right">  hard-to-diagnose bugs.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  @deprecated All functions in this file are by definition deprecated.</td><td> </td><td class="right">  @deprecated All functions in this file are by definition deprecated.</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr id="end" bgcolor="gray"><th colspan="5" align="center">&nbsp;End of changes. 1 change blocks.&nbsp;</th></tr>
     <tr class="stats"><th><i>1 lines changed or deleted</i></th><th><i> </i></th><th><i>1 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr id="part-1" bgcolor="orange"><th>&nbsp;event_struct.h (2.1.12)&nbsp;</th><th> </th><th>&nbsp;event_struct.h (current)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-1" class="change" ><th><small>skipping to change at</small><a href="#part-1"><em> line 129<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-1"><em> line 129<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">       void *evcb_arg;</td><td> </td><td class="right">       void *evcb_arg;</td></tr>
      <tr><td class="left">};</td><td> </td><td class="right">};</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">struct event_base;</td><td> </td><td class="right">struct event_base;</td></tr>
      <tr><td class="left">struct event {</td><td> </td><td class="right">struct event {</td></tr>
      <tr><td class="left">       struct event_callback ev_evcallback;</td><td> </td><td class="right">       struct event_callback ev_evcallback;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       /* for managing timeouts */</td><td> </td><td class="right">       /* for managing timeouts */</td></tr>
      <tr><td class="left">       union {</td><td> </td><td class="right">       union {</td></tr>
      <tr><td class="left">               TAILQ_ENTRY(event) ev_next_with_common_timeout;</td><td> </td><td class="right">               TAILQ_ENTRY(event) ev_next_with_common_timeout;</td></tr>
      <tr id="diff0001"></tr>
      <tr><td class="lblock">               <span class="delete">in</span>t min_heap_idx;</td><td> </td><td class="rblock">               <span class="insert">size_</span>t min_heap_idx;</td></tr>
      <tr><td class="left">       } ev_timeout_pos;</td><td> </td><td class="right">       } ev_timeout_pos;</td></tr>
      <tr><td class="left">       evutil_socket_t ev_fd;</td><td> </td><td class="right">       evutil_socket_t ev_fd;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0002"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">short ev_events;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       short ev_res;           /* result passed to event callback */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">       struct event_base *ev_base;</td><td> </td><td class="right">       struct event_base *ev_base;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       union {</td><td> </td><td class="right">       union {</td></tr>
      <tr><td class="left">               /* used for io events */</td><td> </td><td class="right">               /* used for io events */</td></tr>
      <tr><td class="left">               struct {</td><td> </td><td class="right">               struct {</td></tr>
      <tr><td class="left">                       LIST_ENTRY (event) ev_io_next;</td><td> </td><td class="right">                       LIST_ENTRY (event) ev_io_next;</td></tr>
      <tr><td class="left">                       struct timeval ev_timeout;</td><td> </td><td class="right">                       struct timeval ev_timeout;</td></tr>
      <tr><td class="left">               } ev_io;</td><td> </td><td class="right">               } ev_io;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">               /* used by signal events */</td><td> </td><td class="right">               /* used by signal events */</td></tr>
      <tr><td class="left">               struct {</td><td> </td><td class="right">               struct {</td></tr>
      <tr><td class="left">                       LIST_ENTRY (event) ev_signal_next;</td><td> </td><td class="right">                       LIST_ENTRY (event) ev_signal_next;</td></tr>
      <tr><td class="left">                       short ev_ncalls;</td><td> </td><td class="right">                       short ev_ncalls;</td></tr>
      <tr><td class="left">                       /* Allows deletes in callback */</td><td> </td><td class="right">                       /* Allows deletes in callback */</td></tr>
      <tr><td class="left">                       short *ev_pncalls;</td><td> </td><td class="right">                       short *ev_pncalls;</td></tr>
      <tr><td class="left">               } ev_signal;</td><td> </td><td class="right">               } ev_signal;</td></tr>
      <tr><td class="left">       } ev_;</td><td> </td><td class="right">       } ev_;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0003"></tr>
      <tr><td class="lblock">       <span class="delete">short ev_events;</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">       short ev_res;           /* result passed to event callback */</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left">       struct timeval ev_timeout;</td><td> </td><td class="right">       struct timeval ev_timeout;</td></tr>
      <tr><td class="left">};</td><td> </td><td class="right">};</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">TAILQ_HEAD (event_list, event);</td><td> </td><td class="right">TAILQ_HEAD (event_list, event);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef EVENT_DEFINED_TQENTRY_</td><td> </td><td class="right">#ifdef EVENT_DEFINED_TQENTRY_</td></tr>
      <tr><td class="left">#undef TAILQ_ENTRY</td><td> </td><td class="right">#undef TAILQ_ENTRY</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef EVENT_DEFINED_TQHEAD_</td><td> </td><td class="right">#ifdef EVENT_DEFINED_TQHEAD_</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr id="end" bgcolor="gray"><th colspan="5" align="center">&nbsp;End of changes. 3 change blocks.&nbsp;</th></tr>
     <tr class="stats"><th><i>3 lines changed or deleted</i></th><th><i> </i></th><th><i>4 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr id="part-1" bgcolor="orange"><th>&nbsp;http.h (2.1.12)&nbsp;</th><th> </th><th>&nbsp;http.h (current)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-1" class="change" ><th><small>skipping to change at</small><a href="#part-1"><em> line 46<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-1"><em> line 46<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* In case we haven't included the right headers yet. */</td><td> </td><td class="right">/* In case we haven't included the right headers yet. */</td></tr>
      <tr><td class="left">struct evbuffer;</td><td> </td><td class="right">struct evbuffer;</td></tr>
      <tr><td class="left">struct event_base;</td><td> </td><td class="right">struct event_base;</td></tr>
      <tr><td class="left">struct bufferevent;</td><td> </td><td class="right">struct bufferevent;</td></tr>
      <tr><td class="left">struct evhttp_connection;</td><td> </td><td class="right">struct evhttp_connection;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @file event2/http.h</td><td> </td><td class="right">/** @file event2/http.h</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr id="diff0001"></tr>
      <tr><td class="lblock"> * Basic support for HTTP serving.</td><td> </td><td class="rblock"> * <span class="insert">@brief </span>Basic support for HTTP serving.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * As Libevent is a library for dealing with event notification and most</td><td> </td><td class="right"> * As Libevent is a library for dealing with event notification and most</td></tr>
      <tr><td class="left"> * interesting applications are networked today, I have often found the</td><td> </td><td class="right"> * interesting applications are networked today, I have often found the</td></tr>
      <tr><td class="left"> * need to write HTTP code.  The following prototypes and definitions provi
de</td><td> </td><td class="right"> * need to write HTTP code.  The following prototypes and definitions provi
de</td></tr>
      <tr><td class="left"> * an application with a minimal interface for making HTTP requests and for</td><td> </td><td class="right"> * an application with a minimal interface for making HTTP requests and for</td></tr>
      <tr><td class="left"> * creating a very simple HTTP server.</td><td> </td><td class="right"> * creating a very simple HTTP server.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Response codes */</td><td> </td><td class="right">/* Response codes */</td></tr>
      <tr id="diff0002"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define HTTP_CONTINUE          100     /**&lt; client should proceed to send *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define HTTP_SWITCH_PROTOCOLS  101     /**&lt; switching to another protocol *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define HTTP_PROCESSING                102     /**&lt; processing the request,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> but no response is available yet */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define HTTP_EARLYHINTS                103     /**&lt; return some response he</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">aders */</span></td></tr>
      <tr><td class="left">#define HTTP_OK                        200     /**&lt; request completed ok */</td><td> </td><td class="right">#define HTTP_OK                        200     /**&lt; request completed ok */</td></tr>
      <tr id="diff0003"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define HTTP_CREATED           201     /**&lt; new resource is created */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define HTTP_ACCEPTED          202     /**&lt; accepted for processing */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define HTTP_NONAUTHORITATIVE  203     /**&lt; returning a modified version of</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> the origin's response */</span></td></tr>
      <tr><td class="left">#define HTTP_NOCONTENT         204     /**&lt; request does not have content *
/</td><td> </td><td class="right">#define HTTP_NOCONTENT         204     /**&lt; request does not have content *
/</td></tr>
      <tr><td class="left">#define HTTP_MOVEPERM          301     /**&lt; the uri moved permanently */</td><td> </td><td class="right">#define HTTP_MOVEPERM          301     /**&lt; the uri moved permanently */</td></tr>
      <tr><td class="left">#define HTTP_MOVETEMP          302     /**&lt; the uri moved temporarily */</td><td> </td><td class="right">#define HTTP_MOVETEMP          302     /**&lt; the uri moved temporarily */</td></tr>
      <tr><td class="left">#define HTTP_NOTMODIFIED       304     /**&lt; page was not modified from last
 */</td><td> </td><td class="right">#define HTTP_NOTMODIFIED       304     /**&lt; page was not modified from last
 */</td></tr>
      <tr><td class="left">#define HTTP_BADREQUEST                400     /**&lt; invalid http request wa
s made */</td><td> </td><td class="right">#define HTTP_BADREQUEST                400     /**&lt; invalid http request wa
s made */</td></tr>
      <tr id="diff0004"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define HTTP_UNAUTHORIZED      401     /**&lt; authentication is required */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define HTTP_PAYMENTREQUIRED   402     /**&lt; user exceeded limit on requests</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define HTTP_FORBIDDEN         403     /**&lt; user not having the necessary p</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ermissions */</span></td></tr>
      <tr><td class="left">#define HTTP_NOTFOUND          404     /**&lt; could not find content for uri 
*/</td><td> </td><td class="right">#define HTTP_NOTFOUND          404     /**&lt; could not find content for uri 
*/</td></tr>
      <tr><td class="left">#define HTTP_BADMETHOD         405     /**&lt; method not allowed for this uri
 */</td><td> </td><td class="right">#define HTTP_BADMETHOD         405     /**&lt; method not allowed for this uri
 */</td></tr>
      <tr id="diff0005"></tr>
      <tr><td class="lblock">#define HTTP_ENTITYTOOLARGE    413     /**&lt;  */</td><td> </td><td class="rblock">#define HTTP_ENTITYTOOLARGE    413     /**&lt; <span class="insert">request is larger than the serv
er is able to process</span> */</td></tr>
      <tr><td class="left">#define HTTP_EXPECTATIONFAILED 417     /**&lt; we can't handle this expectatio
n */</td><td> </td><td class="right">#define HTTP_EXPECTATIONFAILED 417     /**&lt; we can't handle this expectatio
n */</td></tr>
      <tr><td class="left">#define HTTP_INTERNAL           500     /**&lt; internal error */</td><td> </td><td class="right">#define HTTP_INTERNAL           500     /**&lt; internal error */</td></tr>
      <tr><td class="left">#define HTTP_NOTIMPLEMENTED     501     /**&lt; not implemented */</td><td> </td><td class="right">#define HTTP_NOTIMPLEMENTED     501     /**&lt; not implemented */</td></tr>
      <tr id="diff0006"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define HTTP_BADGATEWAY                502     /**&lt; received an invalid res
ponse from the upstream */</span></td></tr>
      <tr><td class="left">#define HTTP_SERVUNAVAIL       503     /**&lt; the server is not available */</td><td> </td><td class="right">#define HTTP_SERVUNAVAIL       503     /**&lt; the server is not available */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">struct evhttp;</td><td> </td><td class="right">struct evhttp;</td></tr>
      <tr><td class="left">struct evhttp_request;</td><td> </td><td class="right">struct evhttp_request;</td></tr>
      <tr><td class="left">struct evkeyvalq;</td><td> </td><td class="right">struct evkeyvalq;</td></tr>
      <tr><td class="left">struct evhttp_bound_socket;</td><td> </td><td class="right">struct evhttp_bound_socket;</td></tr>
      <tr><td class="left">struct evconnlistener;</td><td> </td><td class="right">struct evconnlistener;</td></tr>
      <tr><td class="left">struct evdns_base;</td><td> </td><td class="right">struct evdns_base;</td></tr>
      <tr id="diff0007"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">struct evhttp_ext_method;</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Create a new HTTP server.</td><td> </td><td class="right"> * Create a new HTTP server.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param base (optional) the event base to receive the HTTP events</td><td> </td><td class="right"> * @param base (optional) the event base to receive the HTTP events</td></tr>
      <tr><td class="left"> * @return a pointer to a newly initialized evhttp server structure or NULL</td><td> </td><td class="right"> * @return a pointer to a newly initialized evhttp server structure or NULL</td></tr>
      <tr><td class="left"> *   on error</td><td> </td><td class="right"> *   on error</td></tr>
      <tr><td class="left"> * @see evhttp_free()</td><td> </td><td class="right"> * @see evhttp_free()</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-2" class="change" ><th><small>skipping to change at</small><a href="#part-2"><em> line 163<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-2"><em> line 175<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">struct evhttp_bound_socket *evhttp_bind_listener(struct evhttp *http, struc
t evconnlistener *listener);</td><td> </td><td class="right">struct evhttp_bound_socket *evhttp_bind_listener(struct evhttp *http, struc
t evconnlistener *listener);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Return the listener used to implement a bound socket.</td><td> </td><td class="right"> * Return the listener used to implement a bound socket.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">struct evconnlistener *evhttp_bound_socket_get_listener(struct evhttp_bound
_socket *bound);</td><td> </td><td class="right">struct evconnlistener *evhttp_bound_socket_get_listener(struct evhttp_bound
_socket *bound);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0008"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/*</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Like evhttp_set_bevcb.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * If cb returns a non-NULL bufferevent, * the callback supplied through</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * evhttp_set_bevcb isn't used.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">EVENT2_EXPORT_SYMBOL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">void evhttp_bound_set_bevcb(struct evhttp_bound_socket *bound, struct buffe</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">revent* (*cb)(struct event_base *, void *), void *cbarg);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">typedef void evhttp_bound_socket_foreach_fn(struct evhttp_bound_socket *, v
oid *);</td><td> </td><td class="right">typedef void evhttp_bound_socket_foreach_fn(struct evhttp_bound_socket *, v
oid *);</td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Applies the function specified in the first argument to all</td><td> </td><td class="right"> * Applies the function specified in the first argument to all</td></tr>
      <tr><td class="left"> * evhttp_bound_sockets associated with "http". The user must not</td><td> </td><td class="right"> * evhttp_bound_sockets associated with "http". The user must not</td></tr>
      <tr><td class="left"> * attempt to free or remove any connections, sockets or listeners</td><td> </td><td class="right"> * attempt to free or remove any connections, sockets or listeners</td></tr>
      <tr><td class="left"> * in the callback "function".</td><td> </td><td class="right"> * in the callback "function".</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param http pointer to an evhttp object</td><td> </td><td class="right"> * @param http pointer to an evhttp object</td></tr>
      <tr><td class="left"> * @param function function to apply to every bound socket</td><td> </td><td class="right"> * @param function function to apply to every bound socket</td></tr>
      <tr><td class="left"> * @param argument pointer value passed to function for every socket iterat
ed</td><td> </td><td class="right"> * @param argument pointer value passed to function for every socket iterat
ed</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-3" class="change" ><th><small>skipping to change at</small><a href="#part-3"><em> line 226<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-3"><em> line 246<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">void evhttp_free(struct evhttp* http);</td><td> </td><td class="right">void evhttp_free(struct evhttp* http);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** XXX Document. */</td><td> </td><td class="right">/** XXX Document. */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">void evhttp_set_max_headers_size(struct evhttp* http, ev_ssize_t max_header
s_size);</td><td> </td><td class="right">void evhttp_set_max_headers_size(struct evhttp* http, ev_ssize_t max_header
s_size);</td></tr>
      <tr><td class="left">/** XXX Document. */</td><td> </td><td class="right">/** XXX Document. */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">void evhttp_set_max_body_size(struct evhttp* http, ev_ssize_t max_body_size
);</td><td> </td><td class="right">void evhttp_set_max_body_size(struct evhttp* http, ev_ssize_t max_body_size
);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr id="diff0009"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* Set the maximum number of simultaneous connections for this server.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * A value of zero or less disables the limit.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param http the http server on which to set the max connection limit</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param max_connections the maximum number of simultaneous connections or</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> 0</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">EVENT2_EXPORT_SYMBOL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">void evhttp_set_max_connections(struct evhttp* http, int max_connections);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Get the current number of connections.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return The current number of connections for this server.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">EVENT2_EXPORT_SYMBOL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int evhttp_get_connection_count(struct evhttp* http);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="left">  Set the value to use for the Content-Type header when none was provided. 
If</td><td> </td><td class="right">  Set the value to use for the Content-Type header when none was provided. 
If</td></tr>
      <tr><td class="left">  the content type string is NULL, the Content-Type header will not be</td><td> </td><td class="right">  the content type string is NULL, the Content-Type header will not be</td></tr>
      <tr><td class="left">  automatically added.</td><td> </td><td class="right">  automatically added.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  @param http the http server on which to set the default content type</td><td> </td><td class="right">  @param http the http server on which to set the default content type</td></tr>
      <tr><td class="left">  @param content_type the value for the Content-Type header</td><td> </td><td class="right">  @param content_type the value for the Content-Type header</td></tr>
      <tr><td class="left">*/</td><td> </td><td class="right">*/</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">void evhttp_set_default_content_type(struct evhttp *http,</td><td> </td><td class="right">void evhttp_set_default_content_type(struct evhttp *http,</td></tr>
      <tr><td class="left">       const char *content_type);</td><td> </td><td class="right">       const char *content_type);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-4" class="change" ><th><small>skipping to change at</small><a href="#part-4"><em> line 249<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-4"><em> line 287<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">  server, and passed to user callbacks.</td><td> </td><td class="right">  server, and passed to user callbacks.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  If not supported they will generate a "405 Method not allowed" response.</td><td> </td><td class="right">  If not supported they will generate a "405 Method not allowed" response.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  By default this includes the following methods: GET, POST, HEAD, PUT, DEL
ETE</td><td> </td><td class="right">  By default this includes the following methods: GET, POST, HEAD, PUT, DEL
ETE</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  @param http the http server on which to set the methods</td><td> </td><td class="right">  @param http the http server on which to set the methods</td></tr>
      <tr><td class="left">  @param methods bit mask constructed from evhttp_cmd_type values</td><td> </td><td class="right">  @param methods bit mask constructed from evhttp_cmd_type values</td></tr>
      <tr><td class="left">*/</td><td> </td><td class="right">*/</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr id="diff0010"></tr>
      <tr><td class="lblock">void evhttp_set_allowed_methods(struct evhttp* http, <span class="delete">ev_uint16_t</span> methods);</td><td> </td><td class="rblock">void evhttp_set_allowed_methods(struct evhttp* http, <span class="insert">ev_uint32_t</span> methods);</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef int (*evhttp_ext_method_cb)(struct evhttp_ext_method *);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  Sets the callback function which allows HTTP extended methods</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  to be supported by this server.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  The callback should :</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   - if method field is NULL : set method field according to type field</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   - else : set type and flags fields according to method string</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   - return 0 for success (known method / type)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   - return -1 for error (unknown method / type)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  evhttp_set_allowed_methods still needs to be called.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  @param http the http server on which to add support to the methods</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  @param cmp the extended method callback</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  @see evhttp_ext_method</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">*/</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">EVENT2_EXPORT_SYMBOL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">void evhttp_set_ext_method_cmp(struct evhttp *http, evhttp_ext_method_cb cm</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">p);</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">   Set a callback for a specified URI</td><td> </td><td class="right">   Set a callback for a specified URI</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   @param http the http sever on which to set the callback</td><td> </td><td class="right">   @param http the http sever on which to set the callback</td></tr>
      <tr><td class="left">   @param path the path for which to invoke the callback</td><td> </td><td class="right">   @param path the path for which to invoke the callback</td></tr>
      <tr><td class="left">   @param cb the callback function that gets invoked on requesting path</td><td> </td><td class="right">   @param cb the callback function that gets invoked on requesting path</td></tr>
      <tr><td class="left">   @param cb_arg an additional context argument for the callback</td><td> </td><td class="right">   @param cb_arg an additional context argument for the callback</td></tr>
      <tr><td class="left">   @return 0 on success, -1 if the callback existed already, -2 on failure</td><td> </td><td class="right">   @return 0 on success, -1 if the callback existed already, -2 on failure</td></tr>
      <tr><td class="left">*/</td><td> </td><td class="right">*/</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-5" class="change" ><th><small>skipping to change at</small><a href="#part-5"><em> line 286<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-5"><em> line 344<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">    @param cb the callback to invoke for any unmatched requests</td><td> </td><td class="right">    @param cb the callback to invoke for any unmatched requests</td></tr>
      <tr><td class="left">    @param arg an context argument for the callback</td><td> </td><td class="right">    @param arg an context argument for the callback</td></tr>
      <tr><td class="left">*/</td><td> </td><td class="right">*/</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">void evhttp_set_gencb(struct evhttp *http,</td><td> </td><td class="right">void evhttp_set_gencb(struct evhttp *http,</td></tr>
      <tr><td class="left">    void (*cb)(struct evhttp_request *, void *), void *arg);</td><td> </td><td class="right">    void (*cb)(struct evhttp_request *, void *), void *arg);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">   Set a callback used to create new bufferevents for connections</td><td> </td><td class="right">   Set a callback used to create new bufferevents for connections</td></tr>
      <tr><td class="left">   to a given evhttp object.</td><td> </td><td class="right">   to a given evhttp object.</td></tr>
      <tr id="diff0011"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">   <span class="insert">cb is not called if a non-NULL bufferevent was supplied by</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   evhttp_bound_set_bevcb.</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   You can use this to override the default bufferevent type -- for example
,</td><td> </td><td class="right">   You can use this to override the default bufferevent type -- for example
,</td></tr>
      <tr><td class="left">   to make this evhttp object use SSL bufferevents rather than unencrypted</td><td> </td><td class="right">   to make this evhttp object use SSL bufferevents rather than unencrypted</td></tr>
      <tr><td class="left">   ones.</td><td> </td><td class="right">   ones.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   New bufferevents must be allocated with no fd set on them.</td><td> </td><td class="right">   New bufferevents must be allocated with no fd set on them.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   @param http the evhttp server object for which to set the callback</td><td> </td><td class="right">   @param http the evhttp server object for which to set the callback</td></tr>
      <tr><td class="left">   @param cb the callback to invoke for incoming connections</td><td> </td><td class="right">   @param cb the callback to invoke for incoming connections</td></tr>
      <tr><td class="left">   @param arg an context argument for the callback</td><td> </td><td class="right">   @param arg an context argument for the callback</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">void evhttp_set_bevcb(struct evhttp *http,</td><td> </td><td class="right">void evhttp_set_bevcb(struct evhttp *http,</td></tr>
      <tr><td class="left">    struct bufferevent *(*cb)(struct event_base *, void *), void *arg);</td><td> </td><td class="right">    struct bufferevent *(*cb)(struct event_base *, void *), void *arg);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr id="diff0012"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">   <span class="insert">Set a callback which allows the user to note or throttle incoming reques</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ts.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   The requests are not populated with HTTP level information. They</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   are just associated to a connection.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   If the callback returns -1, the associated connection is terminated</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   and the request is closed.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   @param http the evhttp server object for which to set the callback</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   @param cb the callback to invoke for incoming connections</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   @param arg an context argument for the callback</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">EVENT2_EXPORT_SYMBOL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">void evhttp_set_newreqcb(struct evhttp *http,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    int (*cb)(struct evhttp_request*, void *), void *arg);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   Set a callback to output for any error pages sent for requests of a give</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">n</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   evhttp object.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   You can use this to override the default error pages sent, allowing such</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   things as multi-lingual support or customization to match other pages.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   The callback should use the supplied buffer to output the text for an</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   error page. If the callback returns a negative value or doesn't output</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   anything to the buffer, the default error page will be sent instead. The</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   buffer will be automatically be sent when the callback returns, so the</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   callback shouldn't do so itself.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   Microsoft Internet Explorer may display its own error pages if ones sent</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> by</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   an HTTP server are smaller than certain sizes, depending on the status c</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ode.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   To reliably suppress this feature an error page should be at least 512</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   bytes in size.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   @param http the evhttp server object for which to set the callback</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   @param cb the callback to invoke to format error pages</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   @param arg an context argument for the callback</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">EVENT2_EXPORT_SYMBOL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">void evhttp_set_errorcb(struct evhttp *http,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    int (*cb)(struct evhttp_request *req, struct evbuffer *buffer, int erro</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">r, const char *reason, void *cbarg),</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    void *cbarg);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="left">   Adds a virtual host to the http server.</td><td> </td><td class="right">   Adds a virtual host to the http server.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   A virtual host is a newly initialized evhttp object that has request</td><td> </td><td class="right">   A virtual host is a newly initialized evhttp object that has request</td></tr>
      <tr><td class="left">   callbacks set on it via evhttp_set_cb() or evhttp_set_gencb().  It</td><td> </td><td class="right">   callbacks set on it via evhttp_set_cb() or evhttp_set_gencb().  It</td></tr>
      <tr><td class="left">   most not have any listing sockets associated with it.</td><td> </td><td class="right">   most not have any listing sockets associated with it.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   If the virtual host has not been removed by the time that evhttp_free()</td><td> </td><td class="right">   If the virtual host has not been removed by the time that evhttp_free()</td></tr>
      <tr><td class="left">   is called on the main http server, it will be automatically freed, too.</td><td> </td><td class="right">   is called on the main http server, it will be automatically freed, too.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   It is possible to have hierarchical vhosts.  For example: A vhost</td><td> </td><td class="right">   It is possible to have hierarchical vhosts.  For example: A vhost</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-6" class="change" ><th><small>skipping to change at</small><a href="#part-6"><em> line 363<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-6"><em> line 467<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">   @param alias the alias to remove</td><td> </td><td class="right">   @param alias the alias to remove</td></tr>
      <tr><td class="left">   @see evhttp_add_server_alias()</td><td> </td><td class="right">   @see evhttp_add_server_alias()</td></tr>
      <tr><td class="left">*/</td><td> </td><td class="right">*/</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">int evhttp_remove_server_alias(struct evhttp *http, const char *alias);</td><td> </td><td class="right">int evhttp_remove_server_alias(struct evhttp *http, const char *alias);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Set the timeout for an HTTP request.</td><td> </td><td class="right"> * Set the timeout for an HTTP request.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param http an evhttp object</td><td> </td><td class="right"> * @param http an evhttp object</td></tr>
      <tr id="diff0013"></tr>
      <tr><td class="lblock"> * @param <span class="delete">timeout_in_secs</span> the timeout, in seconds</td><td> </td><td class="rblock"> * @param <span class="insert">timeout</span> the timeout, in seconds</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* @see evhttp_set_timeout_tv()</span></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr id="diff0014"></tr>
      <tr><td class="lblock">void evhttp_set_timeout(struct evhttp *http, int timeout<span class="delete">_in_secs</span>);</td><td> </td><td class="rblock">void evhttp_set_timeout(struct evhttp *http, int timeout);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr id="diff0015"></tr>
      <tr><td class="lblock"> * Set <span class="delete">th</span>e timeout for an HTTP request.</td><td> </td><td class="rblock"> * Set <span class="insert">read and writ</span>e timeout for an HTTP request.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param http an evhttp object</td><td> </td><td class="right"> * @param http an evhttp object</td></tr>
      <tr><td class="left"> * @param tv the timeout, or NULL</td><td> </td><td class="right"> * @param tv the timeout, or NULL</td></tr>
      <tr id="diff0016"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">*</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * For more precise control:</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @see evhttp_set_read_timeout_tv()</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @see evhttp_set_write_timeout_tv()</span></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">void evhttp_set_timeout_tv(struct evhttp *http, const struct timeval* tv);</td><td> </td><td class="right">void evhttp_set_timeout_tv(struct evhttp *http, const struct timeval* tv);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0017"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Set read timeout for an HTTP request.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param http an evhttp object</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param tv the timeout, or NULL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">EVENT2_EXPORT_SYMBOL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">void evhttp_set_read_timeout_tv(struct evhttp *http, const struct timeval* </span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">tv);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Set write timeout for an HTTP request.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param http an evhttp object</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param tv the timeout, or NULL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">EVENT2_EXPORT_SYMBOL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">void evhttp_set_write_timeout_tv(struct evhttp *http, const struct timeval*</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> tv);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/* Read all the clients body, and only after this respond with an error if 
the</td><td> </td><td class="right">/* Read all the clients body, and only after this respond with an error if 
the</td></tr>
      <tr><td class="left"> * clients body exceed max_body_size */</td><td> </td><td class="right"> * clients body exceed max_body_size */</td></tr>
      <tr><td class="left">#define EVHTTP_SERVER_LINGERING_CLOSE  0x0001</td><td> </td><td class="right">#define EVHTTP_SERVER_LINGERING_CLOSE  0x0001</td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Set connection flags for HTTP server.</td><td> </td><td class="right"> * Set connection flags for HTTP server.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @see EVHTTP_SERVER_*</td><td> </td><td class="right"> * @see EVHTTP_SERVER_*</td></tr>
      <tr><td class="left"> * @return 0 on success, otherwise non zero (for example if flag doesn't</td><td> </td><td class="right"> * @return 0 on success, otherwise non zero (for example if flag doesn't</td></tr>
      <tr><td class="left"> * supported).</td><td> </td><td class="right"> * supported).</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-7" class="change" ><th><small>skipping to change at</small><a href="#part-7"><em> line 467<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-7"><em> line 594<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">   Send another data chunk as part of an ongoing chunked reply.</td><td> </td><td class="right">   Send another data chunk as part of an ongoing chunked reply.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   The reply chunk consists of the data in databuf.  After calling</td><td> </td><td class="right">   The reply chunk consists of the data in databuf.  After calling</td></tr>
      <tr><td class="left">   evhttp_send_reply_chunk() databuf will be empty, but the buffer is</td><td> </td><td class="right">   evhttp_send_reply_chunk() databuf will be empty, but the buffer is</td></tr>
      <tr><td class="left">   still owned by the caller and needs to be deallocated by the caller</td><td> </td><td class="right">   still owned by the caller and needs to be deallocated by the caller</td></tr>
      <tr><td class="left">   if necessary.</td><td> </td><td class="right">   if necessary.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   @param req a request object</td><td> </td><td class="right">   @param req a request object</td></tr>
      <tr><td class="left">   @param databuf the data chunk to send as part of the reply.</td><td> </td><td class="right">   @param databuf the data chunk to send as part of the reply.</td></tr>
      <tr><td class="left">   @param cb callback funcion</td><td> </td><td class="right">   @param cb callback funcion</td></tr>
      <tr id="diff0018"></tr>
      <tr><td class="lblock">   @param call back's argument.</td><td> </td><td class="rblock">   @param <span class="insert">arg </span>call back's argument.</td></tr>
      <tr><td class="left">*/</td><td> </td><td class="right">*/</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr id="diff0019"></tr>
      <tr><td class="lblock">void evhttp_send_reply_chunk_with_cb(struct evhttp_request *<span class="delete">, struct evbuff
er *</span>,</td><td> </td><td class="rblock">void evhttp_send_reply_chunk_with_cb(struct evhttp_request *<span class="insert">req, struct evb
uffer *databuf</span>,</td></tr>
      <tr><td class="left">    void (*cb)(struct evhttp_connection *, void *), void *arg);</td><td> </td><td class="right">    void (*cb)(struct evhttp_connection *, void *), void *arg);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">   Complete a chunked reply, freeing the request as appropriate.</td><td> </td><td class="right">   Complete a chunked reply, freeing the request as appropriate.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   @param req a request object</td><td> </td><td class="right">   @param req a request object</td></tr>
      <tr><td class="left">*/</td><td> </td><td class="right">*/</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">void evhttp_send_reply_end(struct evhttp_request *req);</td><td> </td><td class="right">void evhttp_send_reply_end(struct evhttp_request *req);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/*</td><td> </td><td class="right">/*</td></tr>
      <tr><td class="left"> * Interfaces for making requests</td><td> </td><td class="right"> * Interfaces for making requests</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** The different request types supported by evhttp.  These are as specifie
d</td><td> </td><td class="right">/** The different request types supported by evhttp.  These are as specifie
d</td></tr>
      <tr id="diff0020"></tr>
      <tr><td class="lblock"> * in RFC2616, except <span class="delete">for</span> PATCH which is specified by <span class="delete">RFC5789.</span></td><td> </td><td class="rblock"> * in RFC2616, except <span class="insert">for:</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * -</span> PATCH which is specified by <span class="insert">RFC5789</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * - PROPFIND, PROPPATCH, MKCOL, LOCK, UNLOCK, COPY, MOVE</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *   which are specified by RFC4918</span></td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * By default, only some of these methods are accepted and passed to user</td><td> </td><td class="right"> * By default, only some of these methods are accepted and passed to user</td></tr>
      <tr><td class="left"> * callbacks; use evhttp_set_allowed_methods() to change which methods</td><td> </td><td class="right"> * callbacks; use evhttp_set_allowed_methods() to change which methods</td></tr>
      <tr><td class="left"> * are allowed.</td><td> </td><td class="right"> * are allowed.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">enum evhttp_cmd_type {</td><td> </td><td class="right">enum evhttp_cmd_type {</td></tr>
      <tr><td class="left">       EVHTTP_REQ_GET     = 1 &lt;&lt; 0,</td><td> </td><td class="right">       EVHTTP_REQ_GET     = 1 &lt;&lt; 0,</td></tr>
      <tr><td class="left">       EVHTTP_REQ_POST    = 1 &lt;&lt; 1,</td><td> </td><td class="right">       EVHTTP_REQ_POST    = 1 &lt;&lt; 1,</td></tr>
      <tr><td class="left">       EVHTTP_REQ_HEAD    = 1 &lt;&lt; 2,</td><td> </td><td class="right">       EVHTTP_REQ_HEAD    = 1 &lt;&lt; 2,</td></tr>
      <tr><td class="left">       EVHTTP_REQ_PUT     = 1 &lt;&lt; 3,</td><td> </td><td class="right">       EVHTTP_REQ_PUT     = 1 &lt;&lt; 3,</td></tr>
      <tr><td class="left">       EVHTTP_REQ_DELETE  = 1 &lt;&lt; 4,</td><td> </td><td class="right">       EVHTTP_REQ_DELETE  = 1 &lt;&lt; 4,</td></tr>
      <tr><td class="left">       EVHTTP_REQ_OPTIONS = 1 &lt;&lt; 5,</td><td> </td><td class="right">       EVHTTP_REQ_OPTIONS = 1 &lt;&lt; 5,</td></tr>
      <tr><td class="left">       EVHTTP_REQ_TRACE   = 1 &lt;&lt; 6,</td><td> </td><td class="right">       EVHTTP_REQ_TRACE   = 1 &lt;&lt; 6,</td></tr>
      <tr><td class="left">       EVHTTP_REQ_CONNECT = 1 &lt;&lt; 7,</td><td> </td><td class="right">       EVHTTP_REQ_CONNECT = 1 &lt;&lt; 7,</td></tr>
      <tr id="diff0021"></tr>
      <tr><td class="lblock">       EVHTTP_REQ_PATCH   = 1 &lt;&lt; <span class="delete">8</span></td><td> </td><td class="rblock">       EVHTTP_REQ_PATCH   = 1 &lt;&lt; <span class="insert">8,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       EVHTTP_REQ_PROPFIND= 1 &lt;&lt; 9,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       EVHTTP_REQ_PROPPATCH=1 &lt;&lt; 10,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       EVHTTP_REQ_MKCOL   = 1 &lt;&lt; 11,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       EVHTTP_REQ_LOCK    = 1 &lt;&lt; 12,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       EVHTTP_REQ_UNLOCK  = 1 &lt;&lt; 13,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       EVHTTP_REQ_COPY    = 1 &lt;&lt; 14,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       EVHTTP_REQ_MOVE    = 1 &lt;&lt; 15,</span></td></tr>
      <tr><td class="left">};</td><td> </td><td class="right">};</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0022"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define EVHTTP_REQ_MAX EVHTTP_REQ_MOVE</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @brief stucture that is passed to (and modified by) the</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * extended method callback function</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @see evhttp_set_ext_method_cmp</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @see evhttp_connection_set_ext_method_cmp</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">struct evhttp_ext_method {</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       const char *method;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       ev_uint32_t type;       /* @see enum evhttp_cmd_type */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       ev_uint16_t flags;      /* Available flag : EVHTTP_METHOD_HAS_BODY *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">};</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define EVHTTP_METHOD_HAS_BODY 0x0001</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/** a request object can represent either a request or a reply */</td><td> </td><td class="right">/** a request object can represent either a request or a reply */</td></tr>
      <tr><td class="left">enum evhttp_request_kind { EVHTTP_REQUEST, EVHTTP_RESPONSE };</td><td> </td><td class="right">enum evhttp_request_kind { EVHTTP_REQUEST, EVHTTP_RESPONSE };</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Create and return a connection object that can be used to for making HTT
P</td><td> </td><td class="right"> * Create and return a connection object that can be used to for making HTT
P</td></tr>
      <tr><td class="left"> * requests.  The connection object tries to resolve address and establish 
the</td><td> </td><td class="right"> * requests.  The connection object tries to resolve address and establish 
the</td></tr>
      <tr><td class="left"> * connection when it is given an http request object.</td><td> </td><td class="right"> * connection when it is given an http request object.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr id="diff0023"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* Connection also has default timeouts for the following events:</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * - connect HTTP_CONNECT_TIMEOUT, which is 45 seconds</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * - read    HTTP_READ_TIMEOUT which is 50 seconds</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * - write   HTTP_WRITE_TIMEOUT, which is 50 seconds</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="left"> * @param base the event_base to use for handling the connection</td><td> </td><td class="right"> * @param base the event_base to use for handling the connection</td></tr>
      <tr><td class="left"> * @param dnsbase the dns_base to use for resolving host names; if not</td><td> </td><td class="right"> * @param dnsbase the dns_base to use for resolving host names; if not</td></tr>
      <tr><td class="left"> *     specified host name resolution will block.</td><td> </td><td class="right"> *     specified host name resolution will block.</td></tr>
      <tr><td class="left"> * @param bev a bufferevent to use for connecting to the server; if NULL, a</td><td> </td><td class="right"> * @param bev a bufferevent to use for connecting to the server; if NULL, a</td></tr>
      <tr id="diff0024"></tr>
      <tr><td class="lblock"> *     socket-based bufferevent will be created.  This buff<span class="delete">revent will be f
</span>reed</td><td> </td><td class="rblock"> *     socket-based bufferevent will be created.  This buff<span class="insert">erevent will be 
f</span>reed</td></tr>
      <tr><td class="left"> *     when the connection closes.  It must have no fd set on it.</td><td> </td><td class="right"> *     when the connection closes.  It must have no fd set on it.</td></tr>
      <tr><td class="left"> * @param address the address to which to connect</td><td> </td><td class="right"> * @param address the address to which to connect</td></tr>
      <tr><td class="left"> * @param port the port to connect to</td><td> </td><td class="right"> * @param port the port to connect to</td></tr>
      <tr><td class="left"> * @return an evhttp_connection object that can be used for making requests
 or</td><td> </td><td class="right"> * @return an evhttp_connection object that can be used for making requests
 or</td></tr>
      <tr><td class="left"> *   NULL on error</td><td> </td><td class="right"> *   NULL on error</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">struct evhttp_connection *evhttp_connection_base_bufferevent_new(</td><td> </td><td class="right">struct evhttp_connection *evhttp_connection_base_bufferevent_new(</td></tr>
      <tr><td class="left">       struct event_base *base, struct evdns_base *dnsbase, struct bufferev
ent* bev, const char *address, ev_uint16_t port);</td><td> </td><td class="right">       struct event_base *base, struct evdns_base *dnsbase, struct bufferev
ent* bev, const char *address, ev_uint16_t port);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr id="diff0025"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* Create and return a connection object that can be used to for making HTT</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">P</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * requests over an unix domain socket.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param base the event_base to use for handling the connection</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param bev a bufferevent to use for connecting to the server; if NULL, a</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *     socket-based bufferevent will be created.  This bufferevent will be </span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">freed</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *     when the connection closes.  It must have no fd set on it.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param path path of unix domain socket</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return an evhttp_connection object that can be used for making requests</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">EVENT2_EXPORT_SYMBOL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">struct evhttp_connection *evhttp_connection_base_bufferevent_unix_new(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       struct event_base *base, struct bufferevent* bev, const char *path);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="left"> * Return the bufferevent that an evhttp_connection is using.</td><td> </td><td class="right"> * Return the bufferevent that an evhttp_connection is using.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">struct bufferevent* evhttp_connection_get_bufferevent(struct evhttp_connect
ion *evcon);</td><td> </td><td class="right">struct bufferevent* evhttp_connection_get_bufferevent(struct evhttp_connect
ion *evcon);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Return the HTTP server associated with this connection, or NULL.</td><td> </td><td class="right"> * Return the HTTP server associated with this connection, or NULL.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">struct evhttp *evhttp_connection_get_server(struct evhttp_connection *evcon
);</td><td> </td><td class="right">struct evhttp *evhttp_connection_get_server(struct evhttp_connection *evcon
);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-8" class="change" ><th><small>skipping to change at</small><a href="#part-8"><em> line 690<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-8"><em> line 864<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> * evhttp_request_free() is explicitly called by the user.</td><td> </td><td class="right"> * evhttp_request_free() is explicitly called by the user.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">void evhttp_request_own(struct evhttp_request *req);</td><td> </td><td class="right">void evhttp_request_own(struct evhttp_request *req);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Returns 1 if the request is owned by the user */</td><td> </td><td class="right">/** Returns 1 if the request is owned by the user */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">int evhttp_request_is_owned(struct evhttp_request *req);</td><td> </td><td class="right">int evhttp_request_is_owned(struct evhttp_request *req);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr id="diff0026"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* Sets extended method cmp callback for this http connection.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @see evhttp_set_ext_method_cmp</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">EVENT2_EXPORT_SYMBOL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">void evhttp_connection_set_ext_method_cmp(struct evhttp_connection *evcon,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       evhttp_ext_method_cb cmp);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="left"> * Returns the connection object associated with the request or NULL</td><td> </td><td class="right"> * Returns the connection object associated with the request or NULL</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * The user needs to either free the request explicitly or call</td><td> </td><td class="right"> * The user needs to either free the request explicitly or call</td></tr>
      <tr><td class="left"> * evhttp_send_reply_end().</td><td> </td><td class="right"> * evhttp_send_reply_end().</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">struct evhttp_connection *evhttp_request_get_connection(struct evhttp_reque
st *req);</td><td> </td><td class="right">struct evhttp_connection *evhttp_request_get_connection(struct evhttp_reque
st *req);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Returns the underlying event_base for this connection</td><td> </td><td class="right"> * Returns the underlying event_base for this connection</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-9" class="change" ><th><small>skipping to change at</small><a href="#part-9"><em> line 724<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-9"><em> line 907<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">void evhttp_connection_free(struct evhttp_connection *evcon);</td><td> </td><td class="right">void evhttp_connection_free(struct evhttp_connection *evcon);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Disowns a given connection object</td><td> </td><td class="right">/** Disowns a given connection object</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Can be used to tell libevent to free the connection object after</td><td> </td><td class="right"> * Can be used to tell libevent to free the connection object after</td></tr>
      <tr><td class="left"> * the last request has completed or failed.</td><td> </td><td class="right"> * the last request has completed or failed.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">void evhttp_connection_free_on_completion(struct evhttp_connection *evcon);</td><td> </td><td class="right">void evhttp_connection_free_on_completion(struct evhttp_connection *evcon);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0027"></tr>
      <tr><td class="lblock">/** <span class="delete">sets</span> the <span class="delete">ip</span> address from which http connections are made */</td><td> </td><td class="rblock">/** <span class="insert">Sets</span> the <span class="insert">IP</span> address from which http connections are made</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">*</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Note this resets internal bufferevent fd, so any options that had been</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * installed will be flushed.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">void evhttp_connection_set_local_address(struct evhttp_connection *evcon,</td><td> </td><td class="right">void evhttp_connection_set_local_address(struct evhttp_connection *evcon,</td></tr>
      <tr><td class="left">    const char *address);</td><td> </td><td class="right">    const char *address);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** sets the local port from which http connections are made */</td><td> </td><td class="right">/** sets the local port from which http connections are made */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">void evhttp_connection_set_local_port(struct evhttp_connection *evcon,</td><td> </td><td class="right">void evhttp_connection_set_local_port(struct evhttp_connection *evcon,</td></tr>
      <tr><td class="left">    ev_uint16_t port);</td><td> </td><td class="right">    ev_uint16_t port);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0028"></tr>
      <tr><td class="lblock">/** Sets the timeout <span class="delete">in seconds</span> for <span class="delete">events related to</span> this <span class="delete">connection</span> */</td><td> </td><td class="rblock">/**</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">*</span> Sets the timeout for this <span class="insert">connection.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @see evhttp_connection_set_timeout_tv()</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">void evhttp_connection_set_timeout(struct evhttp_connection *evcon,</td><td> </td><td class="right">void evhttp_connection_set_timeout(struct evhttp_connection *evcon,</td></tr>
      <tr id="diff0029"></tr>
      <tr><td class="lblock">    int timeout<span class="delete">_in_secs</span>);</td><td> </td><td class="rblock">    int timeout);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0030"></tr>
      <tr><td class="lblock">/** Sets the timeout for <span class="delete">events related to</span> this <span class="delete">connection.  Takes a struct</span></td><td> </td><td class="rblock">/**</td></tr>
      <tr><td class="lblock"> * <span class="delete">timeval.</span> */</td><td> </td><td class="rblock"> <span class="insert">*</span> Sets the timeout for this <span class="insert">connection for the following events:</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * - read,  if tv==NULL then it uses default timeout (HTTP_READ_TIMEOUT)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * - write, if tv==NULL then it uses default timeout (HTTP_WRITE_TIMEOUT)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * But it does not adjust timeout for the "connect" (for historical reasons</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">).</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param tv the timeout, or NULL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * For more precise control:</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @see evhttp_connection_set_connect_timeout_tv()</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @see evhttp_connection_set_read_timeout_tv()</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> * <span class="insert">@see evhttp_connection_set_write_timeout_tv()</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">void evhttp_connection_set_timeout_tv(struct evhttp_connection *evcon,</td><td> </td><td class="right">void evhttp_connection_set_timeout_tv(struct evhttp_connection *evcon,</td></tr>
      <tr><td class="left">    const struct timeval *tv);</td><td> </td><td class="right">    const struct timeval *tv);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0031"></tr>
      <tr><td class="lblock">/** Sets the delay before retrying requests on this connection. This is <span class="delete">onl</span></td><td> </td><td class="rblock">/**</td></tr>
      <tr><td class="lblock"><span class="delete">y</span></td><td> </td><td class="rblock"> <span class="insert">* Sets the connect timeout for this connection</span></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span> used if evhttp_connection_set_retries is used to make the number of <span class="delete">retr</span></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"><span class="delete">ies</span></td><td> </td><td class="rblock"><span class="insert"> * @param tv the timeout, or NULL</span></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span> at least one. Each retry after the first is twice as <span class="delete">long</span> as the one <span class="delete">bef</span></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"><span class="delete">ore</span></td><td> </td><td class="rblock"><span class="insert">EVENT2_EXPORT_SYMBOL</span></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span> it. */</td><td> </td><td class="rblock"><span class="insert">void evhttp_connection_set_connect_timeout_tv(struct evhttp_connection *evc</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">on,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    const struct timeval *tv);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Sets the read timeout for this connection</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param tv the timeout, or NULL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">EVENT2_EXPORT_SYMBOL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">void evhttp_connection_set_read_timeout_tv(struct evhttp_connection *evcon,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    const struct timeval *tv);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Sets the write timeout for this connection</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param tv the timeout, or NULL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">EVENT2_EXPORT_SYMBOL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">void evhttp_connection_set_write_timeout_tv(struct evhttp_connection *evcon</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    const struct timeval *tv);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span> Sets the delay before retrying requests on this connection.</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">*</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span> This is <span class="insert">only</span> used if evhttp_connection_set_retries is used to make the</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">*</span> number of <span class="insert">retries</span> at least one. Each retry after the first is twice as <span class="insert">l</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ong</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span> as the one <span class="insert">before</span> it.</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">*</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Default delay is HTTP_INITIAL_RETRY_TIMEOUT, which is 2 seconds.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">void evhttp_connection_set_initial_retry_tv(struct evhttp_connection *evcon
,</td><td> </td><td class="right">void evhttp_connection_set_initial_retry_tv(struct evhttp_connection *evcon
,</td></tr>
      <tr><td class="left">    const struct timeval *tv);</td><td> </td><td class="right">    const struct timeval *tv);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Sets the retry limit for this connection - -1 repeats indefinitely */</td><td> </td><td class="right">/** Sets the retry limit for this connection - -1 repeats indefinitely */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">void evhttp_connection_set_retries(struct evhttp_connection *evcon,</td><td> </td><td class="right">void evhttp_connection_set_retries(struct evhttp_connection *evcon,</td></tr>
      <tr><td class="left">    int retry_max);</td><td> </td><td class="right">    int retry_max);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Set a callback for connection close. */</td><td> </td><td class="right">/** Set a callback for connection close. */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">void evhttp_connection_set_closecb(struct evhttp_connection *evcon,</td><td> </td><td class="right">void evhttp_connection_set_closecb(struct evhttp_connection *evcon,</td></tr>
      <tr><td class="left">    void (*)(struct evhttp_connection *, void *), void *);</td><td> </td><td class="right">    void (*)(struct evhttp_connection *, void *), void *);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Get the remote address and port associated with this connection. */</td><td> </td><td class="right">/** Get the remote address and port associated with this connection. */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">void evhttp_connection_get_peer(struct evhttp_connection *evcon,</td><td> </td><td class="right">void evhttp_connection_get_peer(struct evhttp_connection *evcon,</td></tr>
      <tr id="diff0032"></tr>
      <tr><td class="lblock">    char **address, ev_uint16_t *port);</td><td> </td><td class="rblock">    c<span class="insert">onst c</span>har **address, ev_uint16_t *port);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Get the remote address associated with this connection.</td><td> </td><td class="right">/** Get the remote address associated with this connection.</td></tr>
      <tr><td class="left"> * extracted from getpeername() OR from nameserver.</td><td> </td><td class="right"> * extracted from getpeername() OR from nameserver.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @return NULL if getpeername() return non success,</td><td> </td><td class="right"> * @return NULL if getpeername() return non success,</td></tr>
      <tr><td class="left"> * or connection is not connected,</td><td> </td><td class="right"> * or connection is not connected,</td></tr>
      <tr><td class="left"> * otherwise it return pointer to struct sockaddr_storage */</td><td> </td><td class="right"> * otherwise it return pointer to struct sockaddr_storage */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">const struct sockaddr*</td><td> </td><td class="right">const struct sockaddr*</td></tr>
      <tr><td class="left">evhttp_connection_get_addr(struct evhttp_connection *evcon);</td><td> </td><td class="right">evhttp_connection_get_addr(struct evhttp_connection *evcon);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-10" class="change" ><th><small>skipping to change at</small><a href="#part-10"><em> line 988<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-10"><em> line 1223<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">   @deprecated This function is deprecated as of Libevent 2.0.9.  Use</td><td> </td><td class="right">   @deprecated This function is deprecated as of Libevent 2.0.9.  Use</td></tr>
      <tr><td class="left">     evhttp_uri_parse and evhttp_parse_query_str instead.</td><td> </td><td class="right">     evhttp_uri_parse and evhttp_parse_query_str instead.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   @param uri the request URI</td><td> </td><td class="right">   @param uri the request URI</td></tr>
      <tr><td class="left">   @param headers the head of the evkeyval queue</td><td> </td><td class="right">   @param headers the head of the evkeyval queue</td></tr>
      <tr><td class="left">   @return 0 on success, -1 on failure</td><td> </td><td class="right">   @return 0 on success, -1 on failure</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">int evhttp_parse_query(const char *uri, struct evkeyvalq *headers);</td><td> </td><td class="right">int evhttp_parse_query(const char *uri, struct evkeyvalq *headers);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0033"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** @see evhttp_parse_query_str_flags() */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">EVENT2_EXPORT_SYMBOL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int evhttp_parse_query_str(const char *uri, struct evkeyvalq *headers);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** Tolerate queries that are not standard conformant.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Here are some examples:</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * - test=123&amp;test2</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *   with with this flag test2 will be present in the output headers</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * - test=123&amp;&amp;test2=1</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *   will parse the query with this flag</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * - test=123&amp;=456&amp;test2=1</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *   will parse the queyr with this flag, however there won't be empty key</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *   present</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define EVHTTP_URI_QUERY_NONCONFORMANT 0x01</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** Prefer last value over the first from query args</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Example: test=123&amp;test=456</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Without: test=123</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * With   : test=456</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define EVHTTP_URI_QUERY_LAST_VAL 0x02</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">   Helper function to parse out arguments from the query portion of an</td><td> </td><td class="right">   Helper function to parse out arguments from the query portion of an</td></tr>
      <tr><td class="left">   HTTP URI.</td><td> </td><td class="right">   HTTP URI.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   Parsing a query string like</td><td> </td><td class="right">   Parsing a query string like</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">     q=test&amp;s=some+thing</td><td> </td><td class="right">     q=test&amp;s=some+thing</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   will result in two entries in the key value queue.</td><td> </td><td class="right">   will result in two entries in the key value queue.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   The first entry is: key="q", value="test"</td><td> </td><td class="right">   The first entry is: key="q", value="test"</td></tr>
      <tr><td class="left">   The second entry is: key="s", value="some thing"</td><td> </td><td class="right">   The second entry is: key="s", value="some thing"</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0034"></tr>
      <tr><td class="lblock">   @param <span class="delete">query_parse</span> the query portion of the URI</td><td> </td><td class="rblock">   @param <span class="insert">uri</span> the query portion of the URI</td></tr>
      <tr><td class="left">   @param headers the head of the evkeyval queue</td><td> </td><td class="right">   @param headers the head of the evkeyval queue</td></tr>
      <tr id="diff0035"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   @param flags one or more of EVHTTP_URI_QUERY_*</span></td></tr>
      <tr><td class="left">   @return 0 on success, -1 on failure</td><td> </td><td class="right">   @return 0 on success, -1 on failure</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr id="diff0036"></tr>
      <tr><td class="lblock">int evhttp_parse_query_str<span class="delete">(const char *uri, struct evkeyvalq *header</span>s);</td><td> </td><td class="rblock">int evhttp_parse_query_str<span class="insert">_flags(const char *uri, struct evkeyvalq *headers
, unsigned flag</span>s);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Escape HTML character entities in a string.</td><td> </td><td class="right"> * Escape HTML character entities in a string.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Replaces &lt;, &gt;, ", ' and &amp; with &amp;lt;, &amp;gt;, &amp;quot;,</td><td> </td><td class="right"> * Replaces &lt;, &gt;, ", ' and &amp; with &amp;lt;, &amp;gt;, &amp;quot;,</td></tr>
      <tr><td class="left"> * &amp;#039; and &amp;amp; correspondingly.</td><td> </td><td class="right"> * &amp;#039; and &amp;amp; correspondingly.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * The returned string needs to be freed by the caller.</td><td> </td><td class="right"> * The returned string needs to be freed by the caller.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param html an unescaped HTML string</td><td> </td><td class="right"> * @param html an unescaped HTML string</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-11" class="change" ><th><small>skipping to change at</small><a href="#part-11"><em> line 1059<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-11"><em> line 1322<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> * bracketed IPv6 address, or a bracketed 'IP-Future' address.</td><td> </td><td class="right"> * bracketed IPv6 address, or a bracketed 'IP-Future' address.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Note that having a NULL host means that the URI has no authority</td><td> </td><td class="right"> * Note that having a NULL host means that the URI has no authority</td></tr>
      <tr><td class="left"> * section, but having an empty-string host means that the URI has an</td><td> </td><td class="right"> * section, but having an empty-string host means that the URI has an</td></tr>
      <tr><td class="left"> * authority section with no host part.  For example,</td><td> </td><td class="right"> * authority section with no host part.  For example,</td></tr>
      <tr><td class="left"> * "mailto:user@example.com" has a host of NULL, but "file:///etc/motd"</td><td> </td><td class="right"> * "mailto:user@example.com" has a host of NULL, but "file:///etc/motd"</td></tr>
      <tr><td class="left"> * has a host of "".</td><td> </td><td class="right"> * has a host of "".</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">const char *evhttp_uri_get_host(const struct evhttp_uri *uri);</td><td> </td><td class="right">const char *evhttp_uri_get_host(const struct evhttp_uri *uri);</td></tr>
      <tr id="diff0037"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** Return the unix socket part of an evhttp_uri, or NULL if there is no un</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ix</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * socket set */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">EVENT2_EXPORT_SYMBOL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">const char *evhttp_uri_get_unixsocket(const struct evhttp_uri *uri);</span></td></tr>
      <tr><td class="left">/** Return the port part of an evhttp_uri, or -1 if there is no port set. *
/</td><td> </td><td class="right">/** Return the port part of an evhttp_uri, or -1 if there is no port set. *
/</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">int evhttp_uri_get_port(const struct evhttp_uri *uri);</td><td> </td><td class="right">int evhttp_uri_get_port(const struct evhttp_uri *uri);</td></tr>
      <tr><td class="left">/** Return the path part of an evhttp_uri, or NULL if it has no path set */</td><td> </td><td class="right">/** Return the path part of an evhttp_uri, or NULL if it has no path set */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">const char *evhttp_uri_get_path(const struct evhttp_uri *uri);</td><td> </td><td class="right">const char *evhttp_uri_get_path(const struct evhttp_uri *uri);</td></tr>
      <tr><td class="left">/** Return the query part of an evhttp_uri (excluding the leading "?"), or</td><td> </td><td class="right">/** Return the query part of an evhttp_uri (excluding the leading "?"), or</td></tr>
      <tr><td class="left"> * NULL if it has no query set */</td><td> </td><td class="right"> * NULL if it has no query set */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">const char *evhttp_uri_get_query(const struct evhttp_uri *uri);</td><td> </td><td class="right">const char *evhttp_uri_get_query(const struct evhttp_uri *uri);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-12" class="change" ><th><small>skipping to change at</small><a href="#part-12"><em> line 1086<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-12"><em> line 1353<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">int evhttp_uri_set_scheme(struct evhttp_uri *uri, const char *scheme);</td><td> </td><td class="right">int evhttp_uri_set_scheme(struct evhttp_uri *uri, const char *scheme);</td></tr>
      <tr><td class="left">/** Set the userinfo of an evhttp_uri, or clear the userinfo if userinfo==N
ULL.</td><td> </td><td class="right">/** Set the userinfo of an evhttp_uri, or clear the userinfo if userinfo==N
ULL.</td></tr>
      <tr><td class="left"> * Returns 0 on success, -1 if userinfo is not well-formed. */</td><td> </td><td class="right"> * Returns 0 on success, -1 if userinfo is not well-formed. */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">int evhttp_uri_set_userinfo(struct evhttp_uri *uri, const char *userinfo);</td><td> </td><td class="right">int evhttp_uri_set_userinfo(struct evhttp_uri *uri, const char *userinfo);</td></tr>
      <tr><td class="left">/** Set the host of an evhttp_uri, or clear the host if host==NULL.</td><td> </td><td class="right">/** Set the host of an evhttp_uri, or clear the host if host==NULL.</td></tr>
      <tr><td class="left"> * Returns 0 on success, -1 if host is not well-formed. */</td><td> </td><td class="right"> * Returns 0 on success, -1 if host is not well-formed. */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">int evhttp_uri_set_host(struct evhttp_uri *uri, const char *host);</td><td> </td><td class="right">int evhttp_uri_set_host(struct evhttp_uri *uri, const char *host);</td></tr>
      <tr id="diff0038"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** Set the unix socket of an evhttp_uri, or clear the unix socket if unixs</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ocket==NULL.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Returns 0 on success, -1 if unixsocket is not well-formed */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">EVENT2_EXPORT_SYMBOL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int evhttp_uri_set_unixsocket(struct evhttp_uri *uri, const char *unixsocke</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">t);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/** Set the port of an evhttp_uri, or clear the port if port==-1.</td><td> </td><td class="right">/** Set the port of an evhttp_uri, or clear the port if port==-1.</td></tr>
      <tr><td class="left"> * Returns 0 on success, -1 if port is not well-formed. */</td><td> </td><td class="right"> * Returns 0 on success, -1 if port is not well-formed. */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">int evhttp_uri_set_port(struct evhttp_uri *uri, int port);</td><td> </td><td class="right">int evhttp_uri_set_port(struct evhttp_uri *uri, int port);</td></tr>
      <tr><td class="left">/** Set the path of an evhttp_uri, or clear the path if path==NULL.</td><td> </td><td class="right">/** Set the path of an evhttp_uri, or clear the path if path==NULL.</td></tr>
      <tr><td class="left"> * Returns 0 on success, -1 if path is not well-formed. */</td><td> </td><td class="right"> * Returns 0 on success, -1 if path is not well-formed. */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">int evhttp_uri_set_path(struct evhttp_uri *uri, const char *path);</td><td> </td><td class="right">int evhttp_uri_set_path(struct evhttp_uri *uri, const char *path);</td></tr>
      <tr><td class="left">/** Set the query of an evhttp_uri, or clear the query if query==NULL.</td><td> </td><td class="right">/** Set the query of an evhttp_uri, or clear the query if query==NULL.</td></tr>
      <tr><td class="left"> * The query should not include a leading "?".</td><td> </td><td class="right"> * The query should not include a leading "?".</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-13" class="change" ><th><small>skipping to change at</small><a href="#part-13"><em> line 1157<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-13"><em> line 1429<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> * do so by passing this flag to evhttp_uri_parse_with_flags.</td><td> </td><td class="right"> * do so by passing this flag to evhttp_uri_parse_with_flags.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Currently, these changes are:</td><td> </td><td class="right"> * Currently, these changes are:</td></tr>
      <tr><td class="left"> * &lt;ul&gt;</td><td> </td><td class="right"> * &lt;ul&gt;</td></tr>
      <tr><td class="left"> *   &lt;li&gt; Nonconformant URIs are allowed to contain otherwise unreasonable</td><td> </td><td class="right"> *   &lt;li&gt; Nonconformant URIs are allowed to contain otherwise unreasonable</td></tr>
      <tr><td class="left"> *        characters in their path, query, and fragment components.</td><td> </td><td class="right"> *        characters in their path, query, and fragment components.</td></tr>
      <tr><td class="left"> * &lt;/ul&gt;</td><td> </td><td class="right"> * &lt;/ul&gt;</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#define EVHTTP_URI_NONCONFORMANT 0x01</td><td> </td><td class="right">#define EVHTTP_URI_NONCONFORMANT 0x01</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0039"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Strip brackets from the IPv6 address and only for evhttp_uri_get_host(),</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * evhttp_uri_join() returns the host with brackets.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Thus you can use host part of the evhttp_uri for getaddrinfo().</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @see also _EVHTTP_URI_HOST_HAS_BRACKETS</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define EVHTTP_URI_HOST_STRIP_BRACKETS 0x04</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Parse unix domain socket URIs, for example:</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * http://unix:/run/control.sock:/controller</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define EVHTTP_URI_UNIX_SOCKET 0x08</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/** Alias for evhttp_uri_parse_with_flags(source_uri, 0) */</td><td> </td><td class="right">/** Alias for evhttp_uri_parse_with_flags(source_uri, 0) */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">struct evhttp_uri *evhttp_uri_parse(const char *source_uri);</td><td> </td><td class="right">struct evhttp_uri *evhttp_uri_parse(const char *source_uri);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Free all memory allocated for a parsed uri.  Only use this for URIs</td><td> </td><td class="right"> * Free all memory allocated for a parsed uri.  Only use this for URIs</td></tr>
      <tr><td class="left"> * generated by evhttp_uri_parse.</td><td> </td><td class="right"> * generated by evhttp_uri_parse.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param uri container with parsed data</td><td> </td><td class="right"> * @param uri container with parsed data</td></tr>
      <tr><td class="left"> * @see evhttp_uri_parse()</td><td> </td><td class="right"> * @see evhttp_uri_parse()</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr id="end" bgcolor="gray"><th colspan="5" align="center">&nbsp;End of changes. 39 change blocks.&nbsp;</th></tr>
     <tr class="stats"><th><i>26 lines changed or deleted</i></th><th><i> </i></th><th><i>339 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr id="part-1" bgcolor="orange"><th>&nbsp;http_compat.h (2.1.12)&nbsp;</th><th> </th><th>&nbsp;http_compat.h (current)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-1" class="change" ><th><small>skipping to change at</small><a href="#part-1"><em> line 32<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-1"><em> line 32<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</td><td> </td><td class="right"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</td></tr>
      <tr><td class="left"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</td><td> </td><td class="right"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</td></tr>
      <tr><td class="left"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</td><td> </td><td class="right"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</td></tr>
      <tr><td class="left"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</td><td> </td><td class="right"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#ifndef EVENT2_HTTP_COMPAT_H_INCLUDED_</td><td> </td><td class="right">#ifndef EVENT2_HTTP_COMPAT_H_INCLUDED_</td></tr>
      <tr><td class="left">#define EVENT2_HTTP_COMPAT_H_INCLUDED_</td><td> </td><td class="right">#define EVENT2_HTTP_COMPAT_H_INCLUDED_</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @file event2/http_compat.h</td><td> </td><td class="right">/** @file event2/http_compat.h</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0001"></tr>
      <tr><td class="lblock">  <span class="delete">Potentially non-threadsafe versions of the functions in http.h: pr</span>ovided</td><td> </td><td class="rblock">  <span class="insert">@brief Potentially non-threadsafe versions of the functions in http.h: pr
</span>ovided</td></tr>
      <tr><td class="left">  only for backwards compatibility.</td><td> </td><td class="right">  only for backwards compatibility.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">extern "C" {</td><td> </td><td class="right">extern "C" {</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#include &lt;event2/event-config.h&gt;</td><td> </td><td class="right">#include &lt;event2/event-config.h&gt;</td></tr>
      <tr><td class="left">#ifdef EVENT__HAVE_SYS_TYPES_H</td><td> </td><td class="right">#ifdef EVENT__HAVE_SYS_TYPES_H</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr id="end" bgcolor="gray"><th colspan="5" align="center">&nbsp;End of changes. 1 change blocks.&nbsp;</th></tr>
     <tr class="stats"><th><i>1 lines changed or deleted</i></th><th><i> </i></th><th><i>1 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr id="part-1" bgcolor="orange"><th>&nbsp;http_struct.h (2.1.12)&nbsp;</th><th> </th><th>&nbsp;http_struct.h (current)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-1" class="change" ><th><small>skipping to change at</small><a href="#part-1"><em> line 132<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-1"><em> line 132<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">       void (*chunk_cb)(struct evhttp_request *, void *);</td><td> </td><td class="right">       void (*chunk_cb)(struct evhttp_request *, void *);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       /*</td><td> </td><td class="right">       /*</td></tr>
      <tr><td class="left">        * Callback added for forked-daapd so they can collect ICY</td><td> </td><td class="right">        * Callback added for forked-daapd so they can collect ICY</td></tr>
      <tr><td class="left">        * (shoutcast) metadata from the http header. If return</td><td> </td><td class="right">        * (shoutcast) metadata from the http header. If return</td></tr>
      <tr><td class="left">        * int is negative the connection will be closed.</td><td> </td><td class="right">        * int is negative the connection will be closed.</td></tr>
      <tr><td class="left">        */</td><td> </td><td class="right">        */</td></tr>
      <tr><td class="left">       int (*header_cb)(struct evhttp_request *, void *);</td><td> </td><td class="right">       int (*header_cb)(struct evhttp_request *, void *);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       /*</td><td> </td><td class="right">       /*</td></tr>
      <tr id="diff0001"></tr>
      <tr><td class="lblock">        * Error callback - called when error is occured.</td><td> </td><td class="rblock">        * Error callback - called when error is occur<span class="insert">r</span>ed.</td></tr>
      <tr><td class="left">        * @see evhttp_request_error for error types.</td><td> </td><td class="right">        * @see evhttp_request_error for error types.</td></tr>
      <tr><td class="left">        *</td><td> </td><td class="right">        *</td></tr>
      <tr><td class="left">        * @see evhttp_request_set_error_cb()</td><td> </td><td class="right">        * @see evhttp_request_set_error_cb()</td></tr>
      <tr><td class="left">        */</td><td> </td><td class="right">        */</td></tr>
      <tr><td class="left">       void (*error_cb)(enum evhttp_request_error, void *);</td><td> </td><td class="right">       void (*error_cb)(enum evhttp_request_error, void *);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       /*</td><td> </td><td class="right">       /*</td></tr>
      <tr><td class="left">        * Send complete callback - called when the request is actually</td><td> </td><td class="right">        * Send complete callback - called when the request is actually</td></tr>
      <tr><td class="left">        * sent and completed.</td><td> </td><td class="right">        * sent and completed.</td></tr>
      <tr><td class="left">        */</td><td> </td><td class="right">        */</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr id="end" bgcolor="gray"><th colspan="5" align="center">&nbsp;End of changes. 1 change blocks.&nbsp;</th></tr>
     <tr class="stats"><th><i>1 lines changed or deleted</i></th><th><i> </i></th><th><i>1 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr id="part-1" bgcolor="orange"><th>&nbsp;listener.h (2.1.12)&nbsp;</th><th> </th><th>&nbsp;listener.h (current)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-1" class="change" ><th><small>skipping to change at</small><a href="#part-1"><em> line 41<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-1"><em> line 41<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">extern "C" {</td><td> </td><td class="right">extern "C" {</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#include &lt;event2/event.h&gt;</td><td> </td><td class="right">#include &lt;event2/event.h&gt;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">struct sockaddr;</td><td> </td><td class="right">struct sockaddr;</td></tr>
      <tr><td class="left">struct evconnlistener;</td><td> </td><td class="right">struct evconnlistener;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0001"></tr>
      <tr><td class="lblock"><span class="delete">/**</span></td><td> </td><td class="rblock"><span class="insert">/**@file event2/listener.h</span></td></tr>
      <tr><td class="lblock">   A callback that we invoke when a listener has a new connection.</td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">   @brief</span> A callback that we invoke when a listener has a new connection.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   @param listener The evconnlistener</td><td> </td><td class="right">   @param listener The evconnlistener</td></tr>
      <tr><td class="left">   @param fd The new file descriptor</td><td> </td><td class="right">   @param fd The new file descriptor</td></tr>
      <tr><td class="left">   @param addr The source address of the connection</td><td> </td><td class="right">   @param addr The source address of the connection</td></tr>
      <tr><td class="left">   @param socklen The length of addr</td><td> </td><td class="right">   @param socklen The length of addr</td></tr>
      <tr><td class="left">   @param user_arg the pointer passed to evconnlistener_new()</td><td> </td><td class="right">   @param user_arg the pointer passed to evconnlistener_new()</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef void (*evconnlistener_cb)(struct evconnlistener *, evutil_socket_t,
 struct sockaddr *, int socklen, void *);</td><td> </td><td class="right">typedef void (*evconnlistener_cb)(struct evconnlistener *, evutil_socket_t,
 struct sockaddr *, int socklen, void *);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-2" class="change" ><th><small>skipping to change at</small><a href="#part-2"><em> line 109<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-2"><em> line 110<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">#define LEV_OPT_REUSEABLE_PORT         (1u&lt;&lt;7)</td><td> </td><td class="right">#define LEV_OPT_REUSEABLE_PORT         (1u&lt;&lt;7)</td></tr>
      <tr><td class="left">/** Flag: Indicates that the listener wants to work only in IPv6 socket.</td><td> </td><td class="right">/** Flag: Indicates that the listener wants to work only in IPv6 socket.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * According to RFC3493 and most Linux distributions, default value is to</td><td> </td><td class="right"> * According to RFC3493 and most Linux distributions, default value is to</td></tr>
      <tr><td class="left"> * work in IPv4-mapped mode. If there is a requirement to bind same port</td><td> </td><td class="right"> * work in IPv4-mapped mode. If there is a requirement to bind same port</td></tr>
      <tr><td class="left"> * on same ip addresses but different handlers for both IPv4 and IPv6,</td><td> </td><td class="right"> * on same ip addresses but different handlers for both IPv4 and IPv6,</td></tr>
      <tr><td class="left"> * it is required to set IPV6_V6ONLY socket option to be sure that the</td><td> </td><td class="right"> * it is required to set IPV6_V6ONLY socket option to be sure that the</td></tr>
      <tr><td class="left"> * code works as expected without affected by bindv6only sysctl setting in</td><td> </td><td class="right"> * code works as expected without affected by bindv6only sysctl setting in</td></tr>
      <tr><td class="left"> * system.</td><td> </td><td class="right"> * system.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr id="diff0002"></tr>
      <tr><td class="lblock"> * This socket option <span class="delete">also supported by Windows</span>.</td><td> </td><td class="rblock"> * This socket option <span class="insert">on Windows is instead enabled by default</span>.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#define LEV_OPT_BIND_IPV6ONLY          (1u&lt;&lt;8)</td><td> </td><td class="right">#define LEV_OPT_BIND_IPV6ONLY          (1u&lt;&lt;8)</td></tr>
      <tr id="diff0003"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** Flag: Indicates that the listener wants to work only in both IPv4 and</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * IPv6 socket.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * This flag exists as copmlement to LEV_OPT_BIND_IPV6ONLY to account for</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * the different default behaviour on Windows so that the code can</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * explicitly request the socket to support both modes without having</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * to rely on the default option.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define LEV_OPT_BIND_IPV4_AND_IPV6             (1u&lt;&lt;9)</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">   Allocate a new evconnlistener object to listen for incoming TCP connecti
ons</td><td> </td><td class="right">   Allocate a new evconnlistener object to listen for incoming TCP connecti
ons</td></tr>
      <tr><td class="left">   on a given file descriptor.</td><td> </td><td class="right">   on a given file descriptor.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   @param base The event base to associate the listener with.</td><td> </td><td class="right">   @param base The event base to associate the listener with.</td></tr>
      <tr><td class="left">   @param cb A callback to be invoked when a new connection arrives.  If th
e</td><td> </td><td class="right">   @param cb A callback to be invoked when a new connection arrives.  If th
e</td></tr>
      <tr><td class="left">      callback is NULL, the listener will be treated as disabled until the</td><td> </td><td class="right">      callback is NULL, the listener will be treated as disabled until the</td></tr>
      <tr><td class="left">      callback is set.</td><td> </td><td class="right">      callback is set.</td></tr>
      <tr><td class="left">   @param ptr A user-supplied pointer to give to the callback.</td><td> </td><td class="right">   @param ptr A user-supplied pointer to give to the callback.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-3" class="change" ><th><small>skipping to change at</small><a href="#part-3"><em> line 146<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-3"><em> line 156<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">   on a given address.</td><td> </td><td class="right">   on a given address.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   @param base The event base to associate the listener with.</td><td> </td><td class="right">   @param base The event base to associate the listener with.</td></tr>
      <tr><td class="left">   @param cb A callback to be invoked when a new connection arrives. If the</td><td> </td><td class="right">   @param cb A callback to be invoked when a new connection arrives. If the</td></tr>
      <tr><td class="left">      callback is NULL, the listener will be treated as disabled until the</td><td> </td><td class="right">      callback is NULL, the listener will be treated as disabled until the</td></tr>
      <tr><td class="left">      callback is set.</td><td> </td><td class="right">      callback is set.</td></tr>
      <tr><td class="left">   @param ptr A user-supplied pointer to give to the callback.</td><td> </td><td class="right">   @param ptr A user-supplied pointer to give to the callback.</td></tr>
      <tr><td class="left">   @param flags Any number of LEV_OPT_* flags</td><td> </td><td class="right">   @param flags Any number of LEV_OPT_* flags</td></tr>
      <tr><td class="left">   @param backlog Passed to the listen() call to determine the length of th
e</td><td> </td><td class="right">   @param backlog Passed to the listen() call to determine the length of th
e</td></tr>
      <tr><td class="left">      acceptable connection backlog.  Set to -1 for a reasonable default.</td><td> </td><td class="right">      acceptable connection backlog.  Set to -1 for a reasonable default.</td></tr>
      <tr id="diff0004"></tr>
      <tr><td class="lblock">   @param <span class="delete">addr</span> The address to listen for connections on.</td><td> </td><td class="rblock">   @param <span class="insert">sa</span> The address to listen for connections on.</td></tr>
      <tr><td class="left">   @param socklen The length of the address.</td><td> </td><td class="right">   @param socklen The length of the address.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">struct evconnlistener *evconnlistener_new_bind(struct event_base *base,</td><td> </td><td class="right">struct evconnlistener *evconnlistener_new_bind(struct event_base *base,</td></tr>
      <tr><td class="left">    evconnlistener_cb cb, void *ptr, unsigned flags, int backlog,</td><td> </td><td class="right">    evconnlistener_cb cb, void *ptr, unsigned flags, int backlog,</td></tr>
      <tr><td class="left">    const struct sockaddr *sa, int socklen);</td><td> </td><td class="right">    const struct sockaddr *sa, int socklen);</td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">   Disable and deallocate an evconnlistener.</td><td> </td><td class="right">   Disable and deallocate an evconnlistener.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr id="end" bgcolor="gray"><th colspan="5" align="center">&nbsp;End of changes. 4 change blocks.&nbsp;</th></tr>
     <tr class="stats"><th><i>4 lines changed or deleted</i></th><th><i> </i></th><th><i>14 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr id="part-1" bgcolor="orange"><th>&nbsp;rpc.h (2.1.12)&nbsp;</th><th> </th><th>&nbsp;rpc.h (current)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-1" class="change" ><th><small>skipping to change at</small><a href="#part-1"><em> line 38<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-1"><em> line 38<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">#define EVENT2_RPC_H_INCLUDED_</td><td> </td><td class="right">#define EVENT2_RPC_H_INCLUDED_</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* For int types. */</td><td> </td><td class="right">/* For int types. */</td></tr>
      <tr><td class="left">#include &lt;event2/util.h&gt;</td><td> </td><td class="right">#include &lt;event2/util.h&gt;</td></tr>
      <tr><td class="left">#include &lt;event2/visibility.h&gt;</td><td> </td><td class="right">#include &lt;event2/visibility.h&gt;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">extern "C" {</td><td> </td><td class="right">extern "C" {</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0001"></tr>
      <tr><td class="lblock">/** @file rpc.h</td><td> </td><td class="rblock">/** @file <span class="insert">event2/</span>rpc.h</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr id="diff0002"></tr>
      <tr><td class="lblock"> * <span class="delete">This header files provides basic support for an RPC server and cl</span>ient.</td><td> </td><td class="rblock"> * <span class="insert">@brief This header files provides basic support for an RPC server and cl
</span>ient.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * To support RPCs in a server, every supported RPC command needs to be</td><td> </td><td class="right"> * To support RPCs in a server, every supported RPC command needs to be</td></tr>
      <tr><td class="left"> * defined and registered.</td><td> </td><td class="right"> * defined and registered.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * EVRPC_HEADER(SendCommand, Request, Reply);</td><td> </td><td class="right"> * EVRPC_HEADER(SendCommand, Request, Reply);</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> *  SendCommand is the name of the RPC command.</td><td> </td><td class="right"> *  SendCommand is the name of the RPC command.</td></tr>
      <tr><td class="left"> *  Request is the name of a structure generated by event_rpcgen.py.</td><td> </td><td class="right"> *  Request is the name of a structure generated by event_rpcgen.py.</td></tr>
      <tr><td class="left"> *    It contains all parameters relating to the SendCommand RPC.  The</td><td> </td><td class="right"> *    It contains all parameters relating to the SendCommand RPC.  The</td></tr>
      <tr><td class="left"> *    server needs to fill in the Reply structure.</td><td> </td><td class="right"> *    server needs to fill in the Reply structure.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-2" class="change" ><th><small>skipping to change at</small><a href="#part-2"><em> line 172<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-2"><em> line 172<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">struct evrpc_hook_meta;</td><td> </td><td class="right">struct evrpc_hook_meta;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Creates the definitions and prototypes for an RPC</td><td> </td><td class="right">/** Creates the definitions and prototypes for an RPC</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * You need to use EVRPC_HEADER to create structures and function prototype
s</td><td> </td><td class="right"> * You need to use EVRPC_HEADER to create structures and function prototype
s</td></tr>
      <tr><td class="left"> * needed by the server and client implementation.  The structures have to 
be</td><td> </td><td class="right"> * needed by the server and client implementation.  The structures have to 
be</td></tr>
      <tr><td class="left"> * defined in an .rpc file and converted to source code via event_rpcgen.py</td><td> </td><td class="right"> * defined in an .rpc file and converted to source code via event_rpcgen.py</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param rpcname the name of the RPC</td><td> </td><td class="right"> * @param rpcname the name of the RPC</td></tr>
      <tr><td class="left"> * @param reqstruct the name of the RPC request structure</td><td> </td><td class="right"> * @param reqstruct the name of the RPC request structure</td></tr>
      <tr id="diff0003"></tr>
      <tr><td class="lblock"> * @param r<span class="delete">e</span>plystruct the name of the RPC reply structure</td><td> </td><td class="rblock"> * @param rplystruct the name of the RPC reply structure</td></tr>
      <tr><td class="left"> * @see EVRPC_GENERATE()</td><td> </td><td class="right"> * @see EVRPC_GENERATE()</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#define EVRPC_HEADER(rpcname, reqstruct, rplystruct) \</td><td> </td><td class="right">#define EVRPC_HEADER(rpcname, reqstruct, rplystruct) \</td></tr>
      <tr><td class="left">EVRPC_STRUCT(rpcname) {        \</td><td> </td><td class="right">EVRPC_STRUCT(rpcname) {        \</td></tr>
      <tr><td class="left">       struct evrpc_hook_meta *hook_meta; \</td><td> </td><td class="right">       struct evrpc_hook_meta *hook_meta; \</td></tr>
      <tr><td class="left">       struct reqstruct* request; \</td><td> </td><td class="right">       struct reqstruct* request; \</td></tr>
      <tr><td class="left">       struct rplystruct* reply; \</td><td> </td><td class="right">       struct rplystruct* reply; \</td></tr>
      <tr><td class="left">       struct evrpc* rpc; \</td><td> </td><td class="right">       struct evrpc* rpc; \</td></tr>
      <tr><td class="left">       struct evhttp_request* http_req; \</td><td> </td><td class="right">       struct evhttp_request* http_req; \</td></tr>
      <tr><td class="left">       struct evbuffer* rpc_data; \</td><td> </td><td class="right">       struct evbuffer* rpc_data; \</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-3" class="change" ><th><small>skipping to change at</small><a href="#part-3"><em> line 211<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-3"><em> line 211<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">       void (*cb)(struct evrpc_status *, void *, void *, void *),</td><td> </td><td class="right">       void (*cb)(struct evrpc_status *, void *, void *, void *),</td></tr>
      <tr><td class="left">       void *cbarg);</td><td> </td><td class="right">       void *cbarg);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Creates a context structure that contains rpc specific information.</td><td> </td><td class="right">/** Creates a context structure that contains rpc specific information.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * EVRPC_MAKE_CTX is used to populate a RPC specific context that</td><td> </td><td class="right"> * EVRPC_MAKE_CTX is used to populate a RPC specific context that</td></tr>
      <tr><td class="left"> * contains information about marshaling the RPC data types.</td><td> </td><td class="right"> * contains information about marshaling the RPC data types.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param rpcname the name of the RPC</td><td> </td><td class="right"> * @param rpcname the name of the RPC</td></tr>
      <tr><td class="left"> * @param reqstruct the name of the RPC request structure</td><td> </td><td class="right"> * @param reqstruct the name of the RPC request structure</td></tr>
      <tr id="diff0004"></tr>
      <tr><td class="lblock"> * @param r<span class="delete">e</span>plystruct the name of the RPC reply structure</td><td> </td><td class="rblock"> * @param rplystruct the name of the RPC reply structure</td></tr>
      <tr><td class="left"> * @param pool the evrpc_pool over which to make the request</td><td> </td><td class="right"> * @param pool the evrpc_pool over which to make the request</td></tr>
      <tr><td class="left"> * @param request a pointer to the RPC request structure object</td><td> </td><td class="right"> * @param request a pointer to the RPC request structure object</td></tr>
      <tr><td class="left"> * @param reply a pointer to the RPC reply structure object</td><td> </td><td class="right"> * @param reply a pointer to the RPC reply structure object</td></tr>
      <tr><td class="left"> * @param cb the callback function to call when the RPC has completed</td><td> </td><td class="right"> * @param cb the callback function to call when the RPC has completed</td></tr>
      <tr><td class="left"> * @param cbarg the argument to supply to the callback</td><td> </td><td class="right"> * @param cbarg the argument to supply to the callback</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#define EVRPC_MAKE_CTX(rpcname, reqstruct, rplystruct, \</td><td> </td><td class="right">#define EVRPC_MAKE_CTX(rpcname, reqstruct, rplystruct, \</td></tr>
      <tr><td class="left">    pool, request, reply, cb, cbarg)                                   \</td><td> </td><td class="right">    pool, request, reply, cb, cbarg)                                   \</td></tr>
      <tr><td class="left">       evrpc_make_request_ctx(pool, request, reply,                    \</td><td> </td><td class="right">       evrpc_make_request_ctx(pool, request, reply,                    \</td></tr>
      <tr><td class="left">           #rpcname,                                                   \</td><td> </td><td class="right">           #rpcname,                                                   \</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-4" class="change" ><th><small>skipping to change at</small><a href="#part-4"><em> line 235<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-4"><em> line 235<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">           (void (*)(struct evrpc_status *, void *, void *, void *))cb, \</td><td> </td><td class="right">           (void (*)(struct evrpc_status *, void *, void *, void *))cb, \</td></tr>
      <tr><td class="left">           cbarg)</td><td> </td><td class="right">           cbarg)</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Generates the code for receiving and sending an RPC message</td><td> </td><td class="right">/** Generates the code for receiving and sending an RPC message</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * EVRPC_GENERATE is used to create the code corresponding to sending</td><td> </td><td class="right"> * EVRPC_GENERATE is used to create the code corresponding to sending</td></tr>
      <tr><td class="left"> * and receiving a particular RPC message</td><td> </td><td class="right"> * and receiving a particular RPC message</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param rpcname the name of the RPC</td><td> </td><td class="right"> * @param rpcname the name of the RPC</td></tr>
      <tr><td class="left"> * @param reqstruct the name of the RPC request structure</td><td> </td><td class="right"> * @param reqstruct the name of the RPC request structure</td></tr>
      <tr id="diff0005"></tr>
      <tr><td class="lblock"> * @param r<span class="delete">e</span>plystruct the name of the RPC reply structure</td><td> </td><td class="rblock"> * @param rplystruct the name of the RPC reply structure</td></tr>
      <tr><td class="left"> * @see EVRPC_HEADER()</td><td> </td><td class="right"> * @see EVRPC_HEADER()</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#define EVRPC_GENERATE(rpcname, reqstruct, rplystruct)                 \</td><td> </td><td class="right">#define EVRPC_GENERATE(rpcname, reqstruct, rplystruct)                 \</td></tr>
      <tr><td class="left">       int evrpc_send_request_##rpcname(struct evrpc_pool *pool,       \</td><td> </td><td class="right">       int evrpc_send_request_##rpcname(struct evrpc_pool *pool,       \</td></tr>
      <tr><td class="left">           struct reqstruct *request, struct rplystruct *reply,        \</td><td> </td><td class="right">           struct reqstruct *request, struct rplystruct *reply,        \</td></tr>
      <tr><td class="left">           void (*cb)(struct evrpc_status *,                           \</td><td> </td><td class="right">           void (*cb)(struct evrpc_status *,                           \</td></tr>
      <tr><td class="left">               struct reqstruct *, struct rplystruct *, void *cbarg),  \</td><td> </td><td class="right">               struct reqstruct *, struct rplystruct *, void *cbarg),  \</td></tr>
      <tr><td class="left">           void *cbarg) {                                              \</td><td> </td><td class="right">           void *cbarg) {                                              \</td></tr>
      <tr><td class="left">       return evrpc_send_request_generic(pool, request, reply, \</td><td> </td><td class="right">       return evrpc_send_request_generic(pool, request, reply, \</td></tr>
      <tr><td class="left">           (void (*)(struct evrpc_status *, void *, void *, void *))cb, \</td><td> </td><td class="right">           (void (*)(struct evrpc_status *, void *, void *, void *))cb, \</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr id="end" bgcolor="gray"><th colspan="5" align="center">&nbsp;End of changes. 5 change blocks.&nbsp;</th></tr>
     <tr class="stats"><th><i>5 lines changed or deleted</i></th><th><i> </i></th><th><i>5 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr id="part-1" bgcolor="orange"><th>&nbsp;rpc_compat.h (2.1.12)&nbsp;</th><th> </th><th>&nbsp;rpc_compat.h (current)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-1" class="change" ><th><small>skipping to change at</small><a href="#part-1"><em> line 32<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-1"><em> line 32<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</td><td> </td><td class="right"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</td></tr>
      <tr><td class="left"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</td><td> </td><td class="right"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</td></tr>
      <tr><td class="left"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</td><td> </td><td class="right"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</td></tr>
      <tr><td class="left"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</td><td> </td><td class="right"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#ifndef EVENT2_RPC_COMPAT_H_INCLUDED_</td><td> </td><td class="right">#ifndef EVENT2_RPC_COMPAT_H_INCLUDED_</td></tr>
      <tr><td class="left">#define EVENT2_RPC_COMPAT_H_INCLUDED_</td><td> </td><td class="right">#define EVENT2_RPC_COMPAT_H_INCLUDED_</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @file event2/rpc_compat.h</td><td> </td><td class="right">/** @file event2/rpc_compat.h</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0001"></tr>
      <tr><td class="lblock">  Deprecated versions of the functions in rpc.h: provided only for</td><td> </td><td class="rblock">  <span class="insert">@brief </span>Deprecated versions of the functions in rpc.h: provided only for</td></tr>
      <tr><td class="left">  backwards compatibility.</td><td> </td><td class="right">  backwards compatibility.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">extern "C" {</td><td> </td><td class="right">extern "C" {</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** backwards compatible accessors that work only with gcc */</td><td> </td><td class="right">/** backwards compatible accessors that work only with gcc */</td></tr>
      <tr><td class="left">#if defined(__GNUC__) &amp;&amp; !defined(__STRICT_ANSI__)</td><td> </td><td class="right">#if defined(__GNUC__) &amp;&amp; !defined(__STRICT_ANSI__)</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr id="end" bgcolor="gray"><th colspan="5" align="center">&nbsp;End of changes. 1 change blocks.&nbsp;</th></tr>
     <tr class="stats"><th><i>1 lines changed or deleted</i></th><th><i> </i></th><th><i>1 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr id="part-1" bgcolor="orange"><th>&nbsp;tag.h (2.1.12)&nbsp;</th><th> </th><th>&nbsp;tag.h (current)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-1" class="change" ><th><small>skipping to change at</small><a href="#part-1"><em> line 32<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-1"><em> line 32<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</td><td> </td><td class="right"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</td></tr>
      <tr><td class="left"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</td><td> </td><td class="right"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</td></tr>
      <tr><td class="left"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</td><td> </td><td class="right"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</td></tr>
      <tr><td class="left"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</td><td> </td><td class="right"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#ifndef EVENT2_TAG_H_INCLUDED_</td><td> </td><td class="right">#ifndef EVENT2_TAG_H_INCLUDED_</td></tr>
      <tr><td class="left">#define EVENT2_TAG_H_INCLUDED_</td><td> </td><td class="right">#define EVENT2_TAG_H_INCLUDED_</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @file event2/tag.h</td><td> </td><td class="right">/** @file event2/tag.h</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0001"></tr>
      <tr><td class="lblock">  Helper functions for reading and writing tagged data onto buffers.</td><td> </td><td class="rblock">  <span class="insert">@brief </span>Helper functions for reading and writing tagged data onto buffers.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#include &lt;event2/visibility.h&gt;</td><td> </td><td class="right">#include &lt;event2/visibility.h&gt;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">extern "C" {</td><td> </td><td class="right">extern "C" {</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#include &lt;event2/event-config.h&gt;</td><td> </td><td class="right">#include &lt;event2/event-config.h&gt;</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr id="end" bgcolor="gray"><th colspan="5" align="center">&nbsp;End of changes. 1 change blocks.&nbsp;</th></tr>
     <tr class="stats"><th><i>1 lines changed or deleted</i></th><th><i> </i></th><th><i>1 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr id="part-1" bgcolor="orange"><th>&nbsp;tag_compat.h (2.1.12)&nbsp;</th><th> </th><th>&nbsp;tag_compat.h (current)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-1" class="change" ><th><small>skipping to change at</small><a href="#part-1"><em> line 32<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-1"><em> line 32<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</td><td> </td><td class="right"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</td></tr>
      <tr><td class="left"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</td><td> </td><td class="right"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</td></tr>
      <tr><td class="left"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</td><td> </td><td class="right"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</td></tr>
      <tr><td class="left"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</td><td> </td><td class="right"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#ifndef EVENT2_TAG_COMPAT_H_INCLUDED_</td><td> </td><td class="right">#ifndef EVENT2_TAG_COMPAT_H_INCLUDED_</td></tr>
      <tr><td class="left">#define EVENT2_TAG_COMPAT_H_INCLUDED_</td><td> </td><td class="right">#define EVENT2_TAG_COMPAT_H_INCLUDED_</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @file event2/tag_compat.h</td><td> </td><td class="right">/** @file event2/tag_compat.h</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0001"></tr>
      <tr><td class="lblock">    <span class="delete">Obsolete/deprecated functions from tag.h; provided only for back</span>wards</td><td> </td><td class="rblock">    <span class="insert">@brief Obsolete/deprecated functions from tag.h; provided only for back
</span>wards</td></tr>
      <tr><td class="left">    compatibility.</td><td> </td><td class="right">    compatibility.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">   @name Misnamed functions</td><td> </td><td class="right">   @name Misnamed functions</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">   @deprecated These macros are deprecated because their names don't follow</td><td> </td><td class="right">   @deprecated These macros are deprecated because their names don't follow</td></tr>
      <tr><td class="left">     Libevent's naming conventions.  Use evtag_encode_int and</td><td> </td><td class="right">     Libevent's naming conventions.  Use evtag_encode_int and</td></tr>
      <tr><td class="left">     evtag_encode_int64 instead.</td><td> </td><td class="right">     evtag_encode_int64 instead.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr id="end" bgcolor="gray"><th colspan="5" align="center">&nbsp;End of changes. 1 change blocks.&nbsp;</th></tr>
     <tr class="stats"><th><i>1 lines changed or deleted</i></th><th><i> </i></th><th><i>1 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr id="part-1" bgcolor="orange"><th>&nbsp;thread.h (2.1.12)&nbsp;</th><th> </th><th>&nbsp;thread.h (current)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-1" class="change" ><th><small>skipping to change at</small><a href="#part-1"><em> line 31<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-1"><em> line 31<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</td><td> </td><td class="right"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</td></tr>
      <tr><td class="left"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</td><td> </td><td class="right"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</td></tr>
      <tr><td class="left"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</td><td> </td><td class="right"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</td></tr>
      <tr><td class="left"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</td><td> </td><td class="right"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#ifndef EVENT2_THREAD_H_INCLUDED_</td><td> </td><td class="right">#ifndef EVENT2_THREAD_H_INCLUDED_</td></tr>
      <tr><td class="left">#define EVENT2_THREAD_H_INCLUDED_</td><td> </td><td class="right">#define EVENT2_THREAD_H_INCLUDED_</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @file event2/thread.h</td><td> </td><td class="right">/** @file event2/thread.h</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0001"></tr>
      <tr><td class="lblock">  Functions for multi-threaded applications using Libevent.</td><td> </td><td class="rblock">  <span class="insert">@brief </span>Functions for multi-threaded applications using Libevent.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  When using a multi-threaded application in which multiple threads</td><td> </td><td class="right">  When using a multi-threaded application in which multiple threads</td></tr>
      <tr><td class="left">  add and delete events from a single event base, Libevent needs to</td><td> </td><td class="right">  add and delete events from a single event base, Libevent needs to</td></tr>
      <tr><td class="left">  lock its data structures.</td><td> </td><td class="right">  lock its data structures.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  Like the memory-management function hooks, all of the threading functions</td><td> </td><td class="right">  Like the memory-management function hooks, all of the threading functions</td></tr>
      <tr><td class="left">  _must_ be set up before an event_base is created if you want the base to</td><td> </td><td class="right">  _must_ be set up before an event_base is created if you want the base to</td></tr>
      <tr><td class="left">  use them.</td><td> </td><td class="right">  use them.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">  Most programs will either be using Windows threads or Posix threads.  You</td><td> </td><td class="right">  Most programs will either be using Windows threads or Posix threads.  You</td></tr>
      <tr id="diff0002"></tr>
      <tr><td class="lblock">  can configure Libevent to use one of these <span class="delete">event_use_windows_threads()</span> or</td><td> </td><td class="rblock">  can configure Libevent to use one of these <span class="insert">evthread_use_windows_threads()</span></td></tr>
      <tr><td class="lblock">  <span class="delete">event_use_pthreads()</span> respectively.  If you're using another threading</td><td> </td><td class="rblock"> or</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">  <span class="insert">evthread_use_pthreads()</span> respectively.  If you're using another threading</td></tr>
      <tr><td class="left">  library, you'll need to configure threading functions manually using</td><td> </td><td class="right">  library, you'll need to configure threading functions manually using</td></tr>
      <tr><td class="left">  evthread_set_lock_callbacks() and evthread_set_condition_callbacks().</td><td> </td><td class="right">  evthread_set_lock_callbacks() and evthread_set_condition_callbacks().</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#include &lt;event2/visibility.h&gt;</td><td> </td><td class="right">#include &lt;event2/visibility.h&gt;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">extern "C" {</td><td> </td><td class="right">extern "C" {</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-2" class="change" ><th><small>skipping to change at</small><a href="#part-2"><em> line 187<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-2"><em> line 187<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> * probably shouldn't call this function; instead, use</td><td> </td><td class="right"> * probably shouldn't call this function; instead, use</td></tr>
      <tr><td class="left"> * evthread_use_windows_threads() or evthread_use_pthreads() if you can.</td><td> </td><td class="right"> * evthread_use_windows_threads() or evthread_use_pthreads() if you can.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">int evthread_set_condition_callbacks(</td><td> </td><td class="right">int evthread_set_condition_callbacks(</td></tr>
      <tr><td class="left">       const struct evthread_condition_callbacks *);</td><td> </td><td class="right">       const struct evthread_condition_callbacks *);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">   Sets the function for determining the thread id.</td><td> </td><td class="right">   Sets the function for determining the thread id.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0003"></tr>
      <tr><td class="lblock"><span class="delete">   @param base the event base for which to set the id function</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left">   @param id_fn the identify function Libevent should invoke to</td><td> </td><td class="right">   @param id_fn the identify function Libevent should invoke to</td></tr>
      <tr><td class="left">     determine the identity of a thread.</td><td> </td><td class="right">     determine the identity of a thread.</td></tr>
      <tr><td class="left">*/</td><td> </td><td class="right">*/</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">void evthread_set_id_callback(</td><td> </td><td class="right">void evthread_set_id_callback(</td></tr>
      <tr><td class="left">    unsigned long (*id_fn)(void));</td><td> </td><td class="right">    unsigned long (*id_fn)(void));</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#if (defined(_WIN32) &amp;&amp; !defined(EVENT__DISABLE_THREAD_SUPPORT)) || defined
(EVENT_IN_DOXYGEN_)</td><td> </td><td class="right">#if (defined(_WIN32) &amp;&amp; !defined(EVENT__DISABLE_THREAD_SUPPORT)) || defined
(EVENT_IN_DOXYGEN_)</td></tr>
      <tr><td class="left">/** Sets up Libevent for use with Windows builtin locking and thread ID</td><td> </td><td class="right">/** Sets up Libevent for use with Windows builtin locking and thread ID</td></tr>
      <tr><td class="left">    functions.  Unavailable if Libevent is not built for Windows.</td><td> </td><td class="right">    functions.  Unavailable if Libevent is not built for Windows.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-3" class="change" ><th><small>skipping to change at</small><a href="#part-3"><em> line 216<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-3"><em> line 215<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#if defined(EVENT__HAVE_PTHREADS) || defined(EVENT_IN_DOXYGEN_)</td><td> </td><td class="right">#if defined(EVENT__HAVE_PTHREADS) || defined(EVENT_IN_DOXYGEN_)</td></tr>
      <tr><td class="left">/** Sets up Libevent for use with Pthreads locking and thread ID functions.</td><td> </td><td class="right">/** Sets up Libevent for use with Pthreads locking and thread ID functions.</td></tr>
      <tr><td class="left">    Unavailable if Libevent is not build for use with pthreads.  Requires</td><td> </td><td class="right">    Unavailable if Libevent is not build for use with pthreads.  Requires</td></tr>
      <tr><td class="left">    libraries to link against Libevent_pthreads as well as Libevent.</td><td> </td><td class="right">    libraries to link against Libevent_pthreads as well as Libevent.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">    @return 0 on success, -1 on failure. */</td><td> </td><td class="right">    @return 0 on success, -1 on failure. */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">int evthread_use_pthreads(void);</td><td> </td><td class="right">int evthread_use_pthreads(void);</td></tr>
      <tr id="diff0004"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* Enables posix mutex priority inheritance</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * (if pthread_mutexattr_setprotocol() is supported). */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define EVTHREAD_PTHREAD_PRIO_INHERIT 0x01</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Sets up Libevent for use with Pthreads locking and thread ID functions.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Use evthread_use_pthreads_with_flags() to use Pthreads locking, taking t</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">he</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * specified flags under consideration.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param flags the flags to apply when setting up Pthreads locking. @see E</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">VTHREAD_PTHREAD_*</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return 0 on success, -1 on failure.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> **/</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">EVENT2_EXPORT_SYMBOL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int evthread_use_pthreads_with_flags(int flags);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/** Defined if Libevent was built with support for evthread_use_pthreads() 
*/</td><td> </td><td class="right">/** Defined if Libevent was built with support for evthread_use_pthreads() 
*/</td></tr>
      <tr><td class="left">#define EVTHREAD_USE_PTHREADS_IMPLEMENTED 1</td><td> </td><td class="right">#define EVTHREAD_USE_PTHREADS_IMPLEMENTED 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Enable debugging wrappers around the current lock callbacks.  If Libeve
nt</td><td> </td><td class="right">/** Enable debugging wrappers around the current lock callbacks.  If Libeve
nt</td></tr>
      <tr><td class="left"> * makes one of several common locking errors, exit with an assertion failu
re.</td><td> </td><td class="right"> * makes one of several common locking errors, exit with an assertion failu
re.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * If you're going to call this function, you must do so before any locks a
re</td><td> </td><td class="right"> * If you're going to call this function, you must do so before any locks a
re</td></tr>
      <tr><td class="left"> * allocated.</td><td> </td><td class="right"> * allocated.</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr id="end" bgcolor="gray"><th colspan="5" align="center">&nbsp;End of changes. 4 change blocks.&nbsp;</th></tr>
     <tr class="stats"><th><i>4 lines changed or deleted</i></th><th><i> </i></th><th><i>22 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr id="part-1" bgcolor="orange"><th>&nbsp;util.h (2.1.12)&nbsp;</th><th> </th><th>&nbsp;util.h (current)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-1" class="change" ><th><small>skipping to change at</small><a href="#part-1"><em> line 31<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-1"><em> line 31<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</td><td> </td><td class="right"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</td></tr>
      <tr><td class="left"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</td><td> </td><td class="right"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</td></tr>
      <tr><td class="left"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</td><td> </td><td class="right"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</td></tr>
      <tr><td class="left"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</td><td> </td><td class="right"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#ifndef EVENT2_UTIL_H_INCLUDED_</td><td> </td><td class="right">#ifndef EVENT2_UTIL_H_INCLUDED_</td></tr>
      <tr><td class="left">#define EVENT2_UTIL_H_INCLUDED_</td><td> </td><td class="right">#define EVENT2_UTIL_H_INCLUDED_</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @file event2/util.h</td><td> </td><td class="right">/** @file event2/util.h</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0001"></tr>
      <tr><td class="lblock">  Common convenience functions for cross-platform portability and</td><td> </td><td class="rblock">  <span class="insert">@brief </span>Common convenience functions for cross-platform portability and</td></tr>
      <tr><td class="left">  related socket manipulations.</td><td> </td><td class="right">  related socket manipulations.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#include &lt;event2/visibility.h&gt;</td><td> </td><td class="right">#include &lt;event2/visibility.h&gt;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">extern "C" {</td><td> </td><td class="right">extern "C" {</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#include &lt;event2/event-config.h&gt;</td><td> </td><td class="right">#include &lt;event2/event-config.h&gt;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-2" class="change" ><th><small>skipping to change at</small><a href="#part-2"><em> line 431<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-2"><em> line 431<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">int evutil_make_listen_socket_reuseable_port(evutil_socket_t sock);</td><td> </td><td class="right">int evutil_make_listen_socket_reuseable_port(evutil_socket_t sock);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Set ipv6 only bind socket option to make listener work only in ipv6 soc
kets.</td><td> </td><td class="right">/** Set ipv6 only bind socket option to make listener work only in ipv6 soc
kets.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">    According to RFC3493 and most Linux distributions, default value for th
e</td><td> </td><td class="right">    According to RFC3493 and most Linux distributions, default value for th
e</td></tr>
      <tr><td class="left">    sockets is to work in IPv4-mapped mode. In IPv4-mapped mode, it is not 
possible</td><td> </td><td class="right">    sockets is to work in IPv4-mapped mode. In IPv4-mapped mode, it is not 
possible</td></tr>
      <tr><td class="left">    to bind same port from different IPv4 and IPv6 handlers.</td><td> </td><td class="right">    to bind same port from different IPv4 and IPv6 handlers.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0002"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">    <span class="insert">On Windows the default value is instead to only work in IPv6 mode.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">    @param sock The socket to make in ipv6only working mode</td><td> </td><td class="right">    @param sock The socket to make in ipv6only working mode</td></tr>
      <tr><td class="left">    @return 0 on success, -1 on failure</td><td> </td><td class="right">    @return 0 on success, -1 on failure</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">int evutil_make_listen_socket_ipv6only(evutil_socket_t sock);</td><td> </td><td class="right">int evutil_make_listen_socket_ipv6only(evutil_socket_t sock);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0003"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** Set ipv6 only bind socket option to make listener work in both ipv4 and</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> ipv6 sockets.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    According to RFC3493 and most Linux distributions, default value for th</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">e</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    sockets is to work in IPv4-mapped mode. In IPv4-mapped mode, it is not </span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">possible</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    to bind same port from different IPv4 and IPv6 handlers.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    On Windows the default value is instead to only work in IPv6 mode.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    @param sock The socket to make in ipv6only working mode</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    @return 0 on success, -1 on failure</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">EVENT2_EXPORT_SYMBOL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int evutil_make_listen_socket_not_ipv6only(evutil_socket_t sock);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/** Do platform-specific operations as needed to close a socket upon a</td><td> </td><td class="right">/** Do platform-specific operations as needed to close a socket upon a</td></tr>
      <tr><td class="left">    successful execution of one of the exec*() functions.</td><td> </td><td class="right">    successful execution of one of the exec*() functions.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">    @param sock The socket to be closed</td><td> </td><td class="right">    @param sock The socket to be closed</td></tr>
      <tr><td class="left">    @return 0 on success, -1 on failure</td><td> </td><td class="right">    @return 0 on success, -1 on failure</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">int evutil_make_socket_closeonexec(evutil_socket_t sock);</td><td> </td><td class="right">int evutil_make_socket_closeonexec(evutil_socket_t sock);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Do the platform-specific call needed to close a socket returned from</td><td> </td><td class="right">/** Do the platform-specific call needed to close a socket returned from</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-3" class="change" ><th><small>skipping to change at</small><a href="#part-3"><em> line 820<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-3"><em> line 836<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">void evutil_freeaddrinfo(struct evutil_addrinfo *ai);</td><td> </td><td class="right">void evutil_freeaddrinfo(struct evutil_addrinfo *ai);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">const char *evutil_gai_strerror(int err);</td><td> </td><td class="right">const char *evutil_gai_strerror(int err);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Generate n bytes of secure pseudorandom data, and store them in buf.</td><td> </td><td class="right">/** Generate n bytes of secure pseudorandom data, and store them in buf.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Current versions of Libevent use an ARC4-based random number generator,</td><td> </td><td class="right"> * Current versions of Libevent use an ARC4-based random number generator,</td></tr>
      <tr><td class="left"> * seeded using the platform's entropy source (/dev/urandom on Unix-like</td><td> </td><td class="right"> * seeded using the platform's entropy source (/dev/urandom on Unix-like</td></tr>
      <tr id="diff0004"></tr>
      <tr><td class="lblock"> * systems; <span class="delete">CryptGenRandom on Windows). </span> This is not actually as secure as 
it</td><td> </td><td class="rblock"> * systems; <span class="insert">BCryptGenRandom on Windows).</span> This is not actually as secure as 
it</td></tr>
      <tr><td class="left"> * should be: ARC4 is a pretty lousy cipher, and the current implementation</td><td> </td><td class="right"> * should be: ARC4 is a pretty lousy cipher, and the current implementation</td></tr>
      <tr><td class="left"> * provides only rudimentary prediction- and backtracking-resistance.  Don'
t</td><td> </td><td class="right"> * provides only rudimentary prediction- and backtracking-resistance.  Don'
t</td></tr>
      <tr><td class="left"> * use this for serious cryptographic applications.</td><td> </td><td class="right"> * use this for serious cryptographic applications.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">void evutil_secure_rng_get_bytes(void *buf, size_t n);</td><td> </td><td class="right">void evutil_secure_rng_get_bytes(void *buf, size_t n);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Seed the secure random number generator if needed, and return 0 on</td><td> </td><td class="right"> * Seed the secure random number generator if needed, and return 0 on</td></tr>
      <tr><td class="left"> * success or -1 on failure.</td><td> </td><td class="right"> * success or -1 on failure.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-4" class="change" ><th><small>skipping to change at</small><a href="#part-4"><em> line 863<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-4"><em> line 879<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * (This string will _NOT_ be copied internally. Do not free it while any</td><td> </td><td class="right"> * (This string will _NOT_ be copied internally. Do not free it while any</td></tr>
      <tr><td class="left"> * user of the secure RNG might be running. Don't pass anything other than 
a</td><td> </td><td class="right"> * user of the secure RNG might be running. Don't pass anything other than 
a</td></tr>
      <tr><td class="left"> * real /dev/...random device file here, or you might lose security.)</td><td> </td><td class="right"> * real /dev/...random device file here, or you might lose security.)</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * This API is unstable, and might change in a future libevent version.</td><td> </td><td class="right"> * This API is unstable, and might change in a future libevent version.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">int evutil_secure_rng_set_urandom_device_file(char *fname);</td><td> </td><td class="right">int evutil_secure_rng_set_urandom_device_file(char *fname);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0005"></tr>
      <tr><td class="lblock"><span class="delete">#if !defined(EVENT__HAVE_ARC4RANDOM) || defined(EVENT__HAVE_ARC4RANDOM_ADDR
ANDOM)</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left">/** Seed the random number generator with extra random bytes.</td><td> </td><td class="right">/** Seed the random number generator with extra random bytes.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">    You should almost never need to call this function; it should be</td><td> </td><td class="right">    You should almost never need to call this function; it should be</td></tr>
      <tr><td class="left">    sufficient to invoke evutil_secure_rng_init(), or let Libevent take</td><td> </td><td class="right">    sufficient to invoke evutil_secure_rng_init(), or let Libevent take</td></tr>
      <tr><td class="left">    care of calling evutil_secure_rng_init() on its own.</td><td> </td><td class="right">    care of calling evutil_secure_rng_init() on its own.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">    If you call this function as a _replacement_ for the regular</td><td> </td><td class="right">    If you call this function as a _replacement_ for the regular</td></tr>
      <tr><td class="left">    entropy sources, then you need to be sure that your input</td><td> </td><td class="right">    entropy sources, then you need to be sure that your input</td></tr>
      <tr><td class="left">    contains a fairly large amount of strong entropy.  Doing so is</td><td> </td><td class="right">    contains a fairly large amount of strong entropy.  Doing so is</td></tr>
      <tr><td class="left">    notoriously hard: most people who try get it wrong.  Watch out!</td><td> </td><td class="right">    notoriously hard: most people who try get it wrong.  Watch out!</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="diff0006"></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">    <span class="insert">This function does nothing when the system provides arc4random()</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    function because it will provide proper entropy.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">    @param dat a buffer full of a strong source of random numbers</td><td> </td><td class="right">    @param dat a buffer full of a strong source of random numbers</td></tr>
      <tr><td class="left">    @param datlen the number of bytes to read from datlen</td><td> </td><td class="right">    @param datlen the number of bytes to read from datlen</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">EVENT2_EXPORT_SYMBOL</td><td> </td><td class="right">EVENT2_EXPORT_SYMBOL</td></tr>
      <tr><td class="left">void evutil_secure_rng_add_bytes(const char *dat, size_t datlen);</td><td> </td><td class="right">void evutil_secure_rng_add_bytes(const char *dat, size_t datlen);</td></tr>
      <tr id="diff0007"></tr>
      <tr><td class="lblock"><span class="delete">#endif</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">}</td><td> </td><td class="right">}</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#endif /* EVENT1_EVUTIL_H_INCLUDED_ */</td><td> </td><td class="right">#endif /* EVENT1_EVUTIL_H_INCLUDED_ */</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr id="end" bgcolor="gray"><th colspan="5" align="center">&nbsp;End of changes. 7 change blocks.&nbsp;</th></tr>
     <tr class="stats"><th><i>4 lines changed or deleted</i></th><th><i> </i></th><th><i>24 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr id="part-1" bgcolor="orange"><th>&nbsp;visibility.h (2.1.12)&nbsp;</th><th> </th><th>&nbsp;visibility.h (current)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr id="part-1" class="change" ><th><small>skipping to change at</small><a href="#part-1"><em> line 36<span class="hide"> &para;</span></em></a></th><th> </th><th><small>skipping to change at</small><a href="#part-1"><em> line 36<span class="hide"> &para;</span></em></a></th></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#ifndef EVENT2_VISIBILITY_H_INCLUDED_</td><td> </td><td class="right">#ifndef EVENT2_VISIBILITY_H_INCLUDED_</td></tr>
      <tr><td class="left">#define EVENT2_VISIBILITY_H_INCLUDED_</td><td> </td><td class="right">#define EVENT2_VISIBILITY_H_INCLUDED_</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#include &lt;event2/event-config.h&gt;</td><td> </td><td class="right">#include &lt;event2/event-config.h&gt;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#if defined(event_shared_EXPORTS) || \</td><td> </td><td class="right">#if defined(event_shared_EXPORTS) || \</td></tr>
      <tr><td class="left">    defined(event_extra_shared_EXPORTS) || \</td><td> </td><td class="right">    defined(event_extra_shared_EXPORTS) || \</td></tr>
      <tr><td class="left">    defined(event_core_shared_EXPORTS) || \</td><td> </td><td class="right">    defined(event_core_shared_EXPORTS) || \</td></tr>
      <tr><td class="left">    defined(event_pthreads_shared_EXPORTS) || \</td><td> </td><td class="right">    defined(event_pthreads_shared_EXPORTS) || \</td></tr>
      <tr id="diff0001"></tr>
      <tr><td class="lblock">    defined(event_openssl_shared_EXPORTS)</td><td> </td><td class="rblock">    defined(event_openssl_shared_EXPORTS) <span class="insert">|| \</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    defined(event_mbedtls_shared_EXPORTS)</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left"># if defined (__SUNPRO_C) &amp;&amp; (__SUNPRO_C &gt;= 0x550)</td><td> </td><td class="right"># if defined (__SUNPRO_C) &amp;&amp; (__SUNPRO_C &gt;= 0x550)</td></tr>
      <tr><td class="left">#  define EVENT2_EXPORT_SYMBOL __global</td><td> </td><td class="right">#  define EVENT2_EXPORT_SYMBOL __global</td></tr>
      <tr><td class="left"># elif defined __GNUC__</td><td> </td><td class="right"># elif defined __GNUC__</td></tr>
      <tr><td class="left">#  define EVENT2_EXPORT_SYMBOL __attribute__ ((visibility("default")))</td><td> </td><td class="right">#  define EVENT2_EXPORT_SYMBOL __attribute__ ((visibility("default")))</td></tr>
      <tr><td class="left"># elif defined(_MSC_VER)</td><td> </td><td class="right"># elif defined(_MSC_VER)</td></tr>
      <tr><td class="left">#  define EVENT2_EXPORT_SYMBOL __declspec(dllexport)</td><td> </td><td class="right">#  define EVENT2_EXPORT_SYMBOL __declspec(dllexport)</td></tr>
      <tr><td class="left"># else</td><td> </td><td class="right"># else</td></tr>
      <tr><td class="left">#  define EVENT2_EXPORT_SYMBOL /* unknown compiler */</td><td> </td><td class="right">#  define EVENT2_EXPORT_SYMBOL /* unknown compiler */</td></tr>
      <tr><td class="left"># endif</td><td> </td><td class="right"># endif</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr id="end" bgcolor="gray"><th colspan="5" align="center">&nbsp;End of changes. 1 change blocks.&nbsp;</th></tr>
     <tr class="stats"><th><i>1 lines changed or deleted</i></th><th><i> </i></th><th><i>2 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><div style='width:100%;' align='left' class='small'>This html diff was produced by rfcdiff 1.41.The latest version is available from <a href='http://tools.ietf.org/tools/rfcdiff/'>http://tools.ietf.org/tools/rfcdiff/</a></div>
</td></tr></table>
</body>
</html>
